diff --exclude .svn -Nru package/hostapd/Config.in package/hostapd/Config.in
--- package/hostapd/Config.in	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/Config.in	2012-08-18 14:47:30.625458002 +0200
@@ -26,6 +26,17 @@
 	depends PACKAGE_wpa-supplicant || PACKAGE_wpa-supplicant-mini || PACKAGE_wpad || PACKAGE_wpad-mini
 	default n
 
+config WPA_MSG_MIN_PRIORITY
+	int "Minimum debug message priority"
+	default 3
+	help
+	  Useful values are:
+	    0 = all messages
+		1 = raw message dumps
+		2 = most debugging messages
+		3 = info messages
+		4 = warnings
+		5 = errors
 
 config DRIVER_WEXT_SUPPORT
 	bool
diff --exclude .svn -Nru package/hostapd/files/hostapd-full.config package/hostapd/files/hostapd-full.config
--- package/hostapd/files/hostapd-full.config	2012-08-17 15:40:41.301971000 +0200
+++ package/hostapd/files/hostapd-full.config	2012-08-18 14:47:30.575458002 +0200
@@ -157,6 +157,8 @@
 CONFIG_INTERNAL_AES=y
 NEED_AES_DEC=y
 
+CONFIG_NO_DUMP_STATE=y
+
 CONFIG_WPS=y
 CONFIG_FULL_DYNAMIC_VLAN=y
 
diff --exclude .svn -Nru package/hostapd/files/hostapd-mini.config package/hostapd/files/hostapd-mini.config
--- package/hostapd/files/hostapd-mini.config	2012-08-17 15:40:41.281971000 +0200
+++ package/hostapd/files/hostapd-mini.config	2012-08-18 14:47:30.575458002 +0200
@@ -153,3 +153,5 @@
 #CONFIG_NO_VLAN=y
 
 CONFIG_TLS=internal
+
+CONFIG_NO_DUMP_STATE=y
diff --exclude .svn -Nru package/hostapd/files/hostapd.sh package/hostapd/files/hostapd.sh
--- package/hostapd/files/hostapd.sh	2012-08-17 15:40:41.311971000 +0200
+++ package/hostapd/files/hostapd.sh	2012-09-30 10:13:29.400734001 +0200
@@ -9,6 +9,9 @@
 	config_get wpa_pair_rekey   "$vif" wpa_pair_rekey   # 300
 	config_get wpa_master_rekey "$vif" wpa_master_rekey # 640
 	config_get_bool ap_isolate "$vif" isolate 0
+	config_get_bool disassoc_low_ack "$vif" disassoc_low_ack 1
+	config_get max_num_sta "$vif" max_num_sta 0
+	config_get max_inactivity "$vif" max_inactivity 0
 
 	config_get device "$vif" device
 	config_get hwmode "$device" hwmode
@@ -19,6 +22,13 @@
 	if [ "$ap_isolate" -gt 0 ]; then
 		append "$var" "ap_isolate=$ap_isolate" "$N"
 	fi
+	if [ "$max_num_sta" -gt 0 ]; then
+		append "$var" "max_num_sta=$max_num_sta" "$N"
+	fi
+	if [ "$max_inactivity" -gt 0 ]; then
+		append "$var" "ap_max_inactivity=$max_inactivity" "$N"
+	fi
+	append "$var" "disassoc_low_ack=$disassoc_low_ack" "$N"
 
 	# Examples:
 	# psk-mixed/tkip 	=> WPA1+2 PSK, TKIP
@@ -84,6 +94,9 @@
 			config_get auth_secret "$vif" auth_secret
 			[ -z "$auth_secret" ] && config_get auth_secret "$vif" key
 			append "$var" "auth_server_shared_secret=$auth_secret" "$N"
+			config_get_bool auth_cache "$vif" auth_cache 0
+			[ "$auth_cache" -gt 0 ] || append "$var" "disable_pmksa_caching=1" "$N"
+			[ "$auth_cache" -gt 0 ] || append "$var" "okc=0" "$N"
 			config_get acct_server "$vif" acct_server
 			[ -n "$acct_server" ] && append "$var" "acct_server_addr=$acct_server" "$N"
 			config_get acct_port "$vif" acct_port
@@ -174,7 +187,7 @@
 	if [ "$wpa" -ge "2" ]
 	then
 		# RSN -> allow preauthentication
-		config_get rsn_preauth "$vif" rsn_preauth
+		config_get_bool rsn_preauth "$vif" rsn_preauth "$auth_cache"
 		if [ -n "$bridge" -a "$rsn_preauth" = 1 ]
 		then
 			append "$var" "rsn_preauth=1" "$N"
diff --exclude .svn -Nru package/hostapd/files/wpa_supplicant-full.config package/hostapd/files/wpa_supplicant-full.config
--- package/hostapd/files/wpa_supplicant-full.config	2012-08-17 15:40:41.311971000 +0200
+++ package/hostapd/files/wpa_supplicant-full.config	2012-08-18 14:47:30.585458002 +0200
@@ -404,3 +404,5 @@
 #LIBS_c += -lbfd -liberty -lz
 
 NEED_80211_COMMON=y
+
+CONFIG_IBSS_RSN=y
diff --exclude .svn -Nru package/hostapd/files/wpa_supplicant.sh package/hostapd/files/wpa_supplicant.sh
--- package/hostapd/files/wpa_supplicant.sh	2012-08-17 15:40:41.281971000 +0200
+++ package/hostapd/files/wpa_supplicant.sh	2012-08-18 14:47:30.575458002 +0200
@@ -3,9 +3,11 @@
 	local driver="$2"
 	local key="$key"
 	local options="$3"
-
-	# wpa_supplicant should use wext for mac80211 cards
-	[ "$driver" = "mac80211" ] && driver='wext'
+	local freq=""
+	local ht="$5"
+	local ap_scan=""
+	local scan_ssid="1"
+	[ -n "$4" ] && freq="frequency=$4"
 
 	# make sure we have the encryption type and the psk
 	[ -n "$enc" ] || {
@@ -23,7 +25,7 @@
 		config_set "$vif" bridge "$bridge"
 	}
 
-	local mode ifname wds
+	local mode ifname wds modestr=""
 	config_get mode "$vif" mode
 	config_get ifname "$vif" ifname
 	config_get_bool wds "$vif" wds 0
@@ -31,13 +33,16 @@
 		echo "wpa_supplicant_setup_vif($ifname): Refusing to bridge $mode mode interface"
 		return 1
 	}
+	[ "$mode" = "adhoc" ] && {
+		modestr="mode=1"
+		scan_ssid="0"
+		ap_scan="ap_scan=2"
+	}
 
+	key_mgmt='NONE'
 	case "$enc" in
-		*none*)
-			key_mgmt='NONE'
-		;;
+		*none*) ;;
 		*wep*)
-			key_mgmt='NONE'
 			config_get key "$vif" key
 			key="${key:-1}"
 			case "$key" in
@@ -59,11 +64,16 @@
 		;;
 		*psk*)
 			key_mgmt='WPA-PSK'
-			config_get_bool usepassphrase "$vif" passphrase 1
-			if [ "$usepassphrase" = "1" ]; then
-				passphrase="psk=\"${key}\""
-			else
+			# if you want to use PSK with a non-nl80211 driver you
+			# have to use WPA-NONE and wext driver for wpa_s
+			[ "$mode" = "adhoc" -a "$driver" != "nl80211" ] && {
+				key_mgmt='WPA-NONE'
+				driver='wext'
+			}
+			if [ ${#key} -eq 64 ]; then
 				passphrase="psk=${key}"
+			else
+				passphrase="psk=\"${key}\""
 			fi
 			case "$enc" in
 				*psk2*)
@@ -114,20 +124,54 @@
 		;;
 	esac
 
+	local fixed_freq bssid1 beacon_interval brates mrate
 	config_get ifname "$vif" ifname
 	config_get bridge "$vif" bridge
 	config_get ssid "$vif" ssid
 	config_get bssid "$vif" bssid
-	bssid=${bssid:+"bssid=$bssid"}
+	bssid1=${bssid:+"bssid=$bssid"}
+	beacon_interval=${beacon_int:+"beacon_interval=$beacon_int"}
+
+	local br brval brsub brstr
+	[ -n "$basic_rate_list" ] && {
+		for br in $basic_rate_list; do
+			brval="$(($br / 1000))"
+			brsub="$((($br / 100) % 10))"
+			[ "$brsub" -gt 0 ] && brval="$brval.$brsub"
+			[ -n "$brstr" ] && brstr="$brstr,"
+			brstr="$brstr$brval"
+		done
+		brates=${basic_rate_list:+"rates=$brstr"}
+	}
+
+	local mcval=""
+	[ -n "$mcast_rate" ] && {
+		mcval="$(($mcast_rate / 1000))"
+		mcsub="$(( ($mcast_rate / 100) % 10 ))"
+		[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
+		mrate=${mcast_rate:+"mcast_rate=$mcval"}
+	}
+
+	local ht_str
+	[ -n "$ht" ] && ht_str="htmode=$ht"
+
 	rm -rf /var/run/wpa_supplicant-$ifname
 	cat > /var/run/wpa_supplicant-$ifname.conf <<EOF
 ctrl_interface=/var/run/wpa_supplicant-$ifname
+$ap_scan
 network={
-	scan_ssid=1
+	$modestr
+	scan_ssid=$scan_ssid
 	ssid="$ssid"
-	$bssid
+	$bssid1
 	key_mgmt=$key_mgmt
 	$proto
+	$freq
+	${fixed:+"fixed_freq=1"}
+	$beacon_interval
+	$brates
+	$mrate
+	$ht_str
 	$ieee80211w
 	$passphrase
 	$pairwise
diff --exclude .svn -Nru package/hostapd/Makefile package/hostapd/Makefile
--- package/hostapd/Makefile	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/Makefile	2012-09-30 10:13:29.700734001 +0200
@@ -8,20 +8,21 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=hostapd
-PKG_VERSION:=20111103
-PKG_RELEASE:=3
-PKG_REV:=6caaae1e48da247b21b54ea6001646597e35d9b1
+PKG_VERSION:=20120910
+PKG_RELEASE:=1
+PKG_REV:=762b99db7a76803d1ad274e87caa6fe870d47441
 
 PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
 PKG_SOURCE_URL:=git://w1.fi/srv/git/hostap.git
 PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)
 PKG_SOURCE_VERSION:=$(PKG_REV)
 PKG_SOURCE_PROTO:=git
-PKG_MIRROR_MD5SUM:=2650d83c1d4649a5df9fe265f8a5775f
+PKG_MIRROR_MD5SUM:=fa3227c146cb50732fe8511ce6d1d862
+
+PKG_BUILD_PARALLEL:=1
 
 PKG_BUILD_DEPENDS:= \
 	PACKAGE_kmod-madwifi:madwifi \
-	PACKAGE_kmod-mac80211:mac80211 \
 
 PKG_CONFIG_DEPENDS:= \
 	CONFIG_WPA_SUPPLICANT_NO_TIMESTAMP_CHECK \
@@ -54,6 +55,8 @@
 
 include $(INCLUDE_DIR)/package.mk
 
+STAMP_CONFIGURED:=$(STAMP_CONFIGURED)_$(CONFIG_WPA_MSG_MIN_PRIORITY)
+
 ifneq ($(CONFIG_DRIVER_11N_SUPPORT),)
   HOSTAPD_IEEE80211N:=y
 endif
@@ -81,7 +84,7 @@
 	CONFIG_DRIVER_ROBOSWITCH=$(CONFIG_PACKAGE_kmod-switch)
 endif
 
-DRV_DEPENDS:=+PACKAGE_kmod-mac80211:libnl-tiny @(!(TARGET_avr32)||BROKEN)
+DRV_DEPENDS:=+PACKAGE_kmod-mac80211:libnl-tiny @(!(TARGET_avr32||TARGET_etrax)||BROKEN)
 
 define Package/hostapd/Default
   SECTION:=net
@@ -218,9 +221,9 @@
 	-I$(PKG_BUILD_DIR)/src/crypto \
 	$(TARGET_CPPFLAGS) \
 	-I$(STAGING_DIR)/usr/include/madwifi \
-	-I$(STAGING_DIR)/usr/include/mac80211 \
 	-DCONFIG_LIBNL20 \
-	-D_GNU_SOURCE
+	-D_GNU_SOURCE \
+	$(if $(CONFIG_WPA_MSG_MIN_PRIORITY),-DCONFIG_MSG_MIN_PRIORITY=$(CONFIG_WPA_MSG_MIN_PRIORITY))
 
 TARGET_CFLAGS += -ffunction-sections -fdata-sections
 TARGET_LDFLAGS += -Wl,--gc-sections
@@ -231,7 +234,7 @@
 
 define Build/RunMake
 	CFLAGS="$(TARGET_CPPFLAGS) $(TARGET_CFLAGS)" \
-	$(MAKE) -C $(PKG_BUILD_DIR)/$(1) \
+	$(MAKE) $(PKG_JOBS) -C $(PKG_BUILD_DIR)/$(1) \
 		$(TARGET_CONFIGURE_OPTS) \
 		$(DRIVER_MAKEOPTS) \
 		LIBS="$(TARGET_LDFLAGS)" \
@@ -244,12 +247,12 @@
 		$(call Build/RunMake,wpa_supplicant,-s MULTICALL=1 dump_cflags) | \
 		sed -e 's,-n ,,g' -e 's,$(TARGET_CFLAGS),,' \
 	` > $(PKG_BUILD_DIR)/.cflags
-	$(call Build/RunMake,hostapd, \
+	+$(call Build/RunMake,hostapd, \
 		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
 		MULTICALL=1 \
 		hostapd_cli hostapd_multi.a \
 	)
-	$(call Build/RunMake,wpa_supplicant, \
+	+$(call Build/RunMake,wpa_supplicant, \
 		CFLAGS="$$$$(cat $(PKG_BUILD_DIR)/.cflags)" \
 		MULTICALL=1 \
 		wpa_cli wpa_supplicant_multi.a \
diff --exclude .svn -Nru package/hostapd/patches/100-pending_work.patch package/hostapd/patches/100-pending_work.patch
--- package/hostapd/patches/100-pending_work.patch	2012-08-17 15:40:41.351971000 +0200
+++ package/hostapd/patches/100-pending_work.patch	2012-09-30 10:13:29.620734001 +0200
@@ -1,6 +1,6 @@
 --- a/src/ap/ieee802_11.c
 +++ b/src/ap/ieee802_11.c
-@@ -1471,13 +1471,6 @@ static void handle_assoc_cb(struct hosta
+@@ -1506,13 +1506,6 @@ static void handle_assoc_cb(struct hosta
  	int new_assoc = 1;
  	struct ieee80211_ht_capabilities ht_cap;
  
@@ -14,7 +14,7 @@
  	if (len < IEEE80211_HDRLEN + (reassoc ? sizeof(mgmt->u.reassoc_resp) :
  				      sizeof(mgmt->u.assoc_resp))) {
  		printf("handle_assoc_cb(reassoc=%d) - too short payload "
-@@ -1485,11 +1478,6 @@ static void handle_assoc_cb(struct hosta
+@@ -1520,11 +1513,6 @@ static void handle_assoc_cb(struct hosta
  		return;
  	}
  
@@ -26,7 +26,7 @@
  	sta = ap_get_sta(hapd, mgmt->da);
  	if (!sta) {
  		printf("handle_assoc_cb: STA " MACSTR " not found\n",
-@@ -1497,6 +1485,19 @@ static void handle_assoc_cb(struct hosta
+@@ -1532,6 +1520,19 @@ static void handle_assoc_cb(struct hosta
  		return;
  	}
  
@@ -46,34 +46,33 @@
  	if (status != WLAN_STATUS_SUCCESS)
  		goto fail;
  
+@@ -1830,6 +1831,9 @@ void ieee802_11_rx_from_unknown(struct h
+ 
+ 	sta = ap_get_sta(hapd, src);
+ 	if (sta && (sta->flags & WLAN_STA_ASSOC)) {
++		if (!hapd->conf->wds_sta)
++			return;
++
+ 		if (wds && !(sta->flags & WLAN_STA_WDS)) {
+ 			wpa_printf(MSG_DEBUG, "Enable 4-address WDS mode for "
+ 				   "STA " MACSTR " (aid %u)",
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -181,6 +181,7 @@ struct i802_bss {
- 	struct wpa_driver_nl80211_data *drv;
- 	struct i802_bss *next;
- 	int ifindex;
-+	u8 addr[ETH_ALEN];
- 	char ifname[IFNAMSIZ + 1];
- 	char brname[IFNAMSIZ];
- 	unsigned int beacon_set:1;
-@@ -191,7 +192,6 @@ struct i802_bss {
- struct wpa_driver_nl80211_data {
- 	struct nl80211_global *global;
- 	struct dl_list list;
--	u8 addr[ETH_ALEN];
- 	char phyname[32];
- 	void *ctx;
- 	int ifindex;
-@@ -2482,7 +2482,7 @@ wpa_driver_nl80211_finish_drv_init(struc
- 		return -1;
- 
- 	if (linux_get_ifhwaddr(drv->global->ioctl_sock, bss->ifname,
--			       drv->addr))
-+			       bss->addr))
- 		return -1;
+@@ -2661,10 +2661,10 @@ static int wpa_driver_nl80211_capa(struc
+ 	drv->data_tx_status = info.data_tx_status;
  
- 	if (nl80211_register_action_frames(drv) < 0) {
-@@ -5176,8 +5176,8 @@ static int wpa_driver_nl80211_hapd_send_
+ 	/*
+-	 * If poll command is supported mac80211 is new enough to
+-	 * have everything we need to not need monitor interfaces.
++	 * If poll command and tx status are supported, mac80211 is new enough
++	 * to have everything we need to not need monitor interfaces.
+ 	 */
+-	drv->use_monitor = !info.poll_command_supported;
++	drv->use_monitor = !info.poll_command_supported || !info.data_tx_status;
+ 
+ 	if (drv->device_ap_sme && drv->use_monitor) {
+ 		/*
+@@ -6392,8 +6392,8 @@ static int wpa_driver_nl80211_hapd_send_
  	pos = (u8 *) (hdr + 1);
  
  	if (qos) {
@@ -84,17 +83,8 @@
  		pos[1] = 0;
  		pos += 2;
  	}
-@@ -6407,7 +6407,7 @@ static int i802_set_wds_sta(void *priv, 
- 		if (!if_nametoindex(name)) {
- 			if (nl80211_create_iface(drv, name,
- 						 NL80211_IFTYPE_AP_VLAN,
--						 NULL, 1) < 0)
-+						 bss->addr, 1) < 0)
- 				return -1;
- 			if (bridge_ifname &&
- 			    linux_br_add_if(drv->global->ioctl_sock,
-@@ -6417,6 +6417,10 @@ static int i802_set_wds_sta(void *priv, 
- 		linux_set_iface_flags(drv->global->ioctl_sock, name, 1);
+@@ -7698,6 +7698,10 @@ static int i802_set_wds_sta(void *priv, 
+ 		}
  		return i802_set_sta_vlan(priv, addr, name, 0);
  	} else {
 +		if (bridge_ifname)
@@ -104,36 +94,7 @@
  		i802_set_sta_vlan(priv, addr, bss->ifname, 0);
  		return wpa_driver_nl80211_if_remove(priv, WPA_IF_AP_VLAN,
  						    name);
-@@ -6625,7 +6629,7 @@ static int nl80211_addr_in_use(struct nl
- 	struct wpa_driver_nl80211_data *drv;
- 	dl_list_for_each(drv, &global->interfaces,
- 			 struct wpa_driver_nl80211_data, list) {
--		if (os_memcmp(addr, drv->addr, ETH_ALEN) == 0)
-+		if (os_memcmp(addr, drv->first_bss.addr, ETH_ALEN) == 0)
- 			return 1;
- 	}
- 	return 0;
-@@ -6640,9 +6644,9 @@ static int nl80211_p2p_interface_addr(st
- 	if (!drv->global)
- 		return -1;
- 
--	os_memcpy(new_addr, drv->addr, ETH_ALEN);
-+	os_memcpy(new_addr, drv->first_bss.addr, ETH_ALEN);
- 	for (idx = 0; idx < 64; idx++) {
--		new_addr[0] = drv->addr[0] | 0x02;
-+		new_addr[0] = drv->first_bss.addr[0] | 0x02;
- 		new_addr[0] ^= idx << 2;
- 		if (!nl80211_addr_in_use(drv->global, new_addr))
- 			break;
-@@ -6745,6 +6749,7 @@ static int wpa_driver_nl80211_if_add(voi
- 			os_free(new_bss);
- 			return -1;
- 		}
-+		memcpy(new_bss->addr, addr ? addr : if_addr, ETH_ALEN);
- 		os_strlcpy(new_bss->ifname, ifname, IFNAMSIZ);
- 		new_bss->ifindex = ifidx;
- 		new_bss->drv = drv;
-@@ -6775,7 +6780,12 @@ static int wpa_driver_nl80211_if_remove(
+@@ -8065,7 +8069,12 @@ static int wpa_driver_nl80211_if_remove(
  	if (ifindex <= 0)
  		return -1;
  
@@ -146,7 +107,7 @@
  	if (bss->added_if_into_bridge) {
  		if (linux_br_del_if(drv->global->ioctl_sock, bss->brname,
  				    bss->ifname) < 0)
-@@ -6789,13 +6799,6 @@ static int wpa_driver_nl80211_if_remove(
+@@ -8079,13 +8088,6 @@ static int wpa_driver_nl80211_if_remove(
  				   "bridge %s: %s",
  				   bss->brname, strerror(errno));
  	}
diff --exclude .svn -Nru package/hostapd/patches/300-nl80211_multicall_fixes.patch package/hostapd/patches/300-nl80211_multicall_fixes.patch
--- package/hostapd/patches/300-nl80211_multicall_fixes.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/300-nl80211_multicall_fixes.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,60 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -2988,6 +2988,7 @@ static void * wpa_driver_nl80211_init(vo
+ 	drv->monitor_sock = -1;
+ 	drv->eapol_tx_sock = -1;
+ 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
++	drv->nlmode = NL80211_IFTYPE_STATION;
+ 
+ 	if (wpa_driver_nl80211_init_nl(drv)) {
+ 		os_free(drv);
+@@ -3302,17 +3303,12 @@ static void wpa_driver_nl80211_send_rfki
+ 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
+ }
+ 
+-
+ static int
+-wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
++wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
++				       int *send_rfkill_event)
+ {
+ 	struct i802_bss *bss = &drv->first_bss;
+-	int send_rfkill_event = 0;
+ 
+-	drv->ifindex = if_nametoindex(bss->ifname);
+-	drv->first_bss.ifindex = drv->ifindex;
+-
+-#ifndef HOSTAPD
+ 	/*
+ 	 * Make sure the interface starts up in station mode unless this is a
+ 	 * dynamically added interface (e.g., P2P) that was already configured
+@@ -3331,7 +3327,7 @@ wpa_driver_nl80211_finish_drv_init(struc
+ 				   "interface '%s' due to rfkill",
+ 				   bss->ifname);
+ 			drv->if_disabled = 1;
+-			send_rfkill_event = 1;
++			*send_rfkill_event = 1;
+ 		} else {
+ 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
+ 				   "interface '%s' UP", bss->ifname);
+@@ -3341,7 +3337,19 @@ wpa_driver_nl80211_finish_drv_init(struc
+ 
+ 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
+ 			       1, IF_OPER_DORMANT);
+-#endif /* HOSTAPD */
++}
++
++static int
++wpa_driver_nl80211_finish_drv_init(struct wpa_driver_nl80211_data *drv)
++{
++	struct i802_bss *bss = &drv->first_bss;
++	int send_rfkill_event = 0;
++
++	drv->ifindex = if_nametoindex(bss->ifname);
++	drv->first_bss.ifindex = drv->ifindex;
++
++	if (drv->nlmode == NL80211_IFTYPE_STATION)
++		wpa_driver_nl80211_finish_drv_init_sta(drv, &send_rfkill_event);
+ 
+ 	if (wpa_driver_nl80211_capa(drv))
+ 		return -1;
diff --exclude .svn -Nru package/hostapd/patches/300-scan_ssid.patch package/hostapd/patches/300-scan_ssid.patch
--- package/hostapd/patches/300-scan_ssid.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/300-scan_ssid.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
---- a/wpa_supplicant/scan.c
-+++ b/wpa_supplicant/scan.c
-@@ -423,6 +423,7 @@ static void wpa_supplicant_scan(void *el
- 	int scan_req = 0, ret;
- 	struct wpabuf *extra_ie;
- 	struct wpa_driver_scan_params params;
-+	int scan_ssid_all = 1;
- 	size_t max_ssids;
- 	enum wpa_states prev_state;
- 
-@@ -502,6 +503,16 @@ static void wpa_supplicant_scan(void *el
- 		}
- 	}
- 
-+	/* check if all configured ssids should be scanned directly */
-+	ssid = wpa_s->conf->ssid;
-+	while (ssid) {
-+		if (!ssid->scan_ssid) {
-+			scan_ssid_all = 0;
-+			break;
-+		}
-+		ssid = ssid->next;
-+	}
-+
- 	/* Find the starting point from which to continue scanning */
- 	ssid = wpa_s->conf->ssid;
- 	if (wpa_s->prev_scan_ssid != WILDCARD_SSID_SCAN) {
-@@ -564,6 +575,9 @@ static void wpa_supplicant_scan(void *el
- 		int_array_sort_unique(params.freqs);
- 	}
- 
-+	if (scan_ssid_all && !ssid)
-+		ssid = wpa_s->conf->ssid;
-+
- 	if (ssid) {
- 		wpa_s->prev_scan_ssid = ssid;
- 		if (max_ssids > 1) {
diff --exclude .svn -Nru package/hostapd/patches/310-madwifi_merge.patch package/hostapd/patches/310-madwifi_merge.patch
--- package/hostapd/patches/310-madwifi_merge.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/310-madwifi_merge.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,791 +0,0 @@
---- a/src/drivers/driver_madwifi.c
-+++ b/src/drivers/driver_madwifi.c
-@@ -71,7 +71,6 @@
- 
- #define WPA_KEY_RSC_LEN 8
- 
--#ifdef HOSTAPD
- 
- #include "priv_netlink.h"
- #include "netlink.h"
-@@ -82,17 +81,22 @@
- struct madwifi_driver_data {
- 	struct hostapd_data *hapd;		/* back pointer */
- 
--	char	iface[IFNAMSIZ + 1];
-+	void *wext; /* private data for driver_wext */
-+	void *ctx;
-+	char ifname[IFNAMSIZ + 1];
-+	int	ioctl_sock;			/* socket for ioctl() use */
-+
-+#ifdef HOSTAPD
- 	int     ifindex;
- 	struct l2_packet_data *sock_xmit;	/* raw packet xmit socket */
- 	struct l2_packet_data *sock_recv;	/* raw packet recv socket */
--	int	ioctl_sock;			/* socket for ioctl() use */
- 	struct netlink_data *netlink;
- 	int	we_version;
- 	u8	acct_mac[ETH_ALEN];
- 	struct hostap_sta_driver_data acct_data;
- 
- 	struct l2_packet_data *sock_raw; /* raw 802.11 management frames */
-+#endif
- };
- 
- static int madwifi_sta_deauth(void *priv, const u8 *own_addr, const u8 *addr,
-@@ -105,7 +109,7 @@ set80211priv(struct madwifi_driver_data 
- 	int do_inline = len < IFNAMSIZ;
- 
- 	memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- #ifdef IEEE80211_IOCTL_FILTERFRAME
- 	/* FILTERFRAME must be NOT inline, regardless of size. */
- 	if (op == IEEE80211_IOCTL_FILTERFRAME)
-@@ -206,7 +210,7 @@ set80211param(struct madwifi_driver_data
- 	struct iwreq iwr;
- 
- 	memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- 	iwr.u.mode = op;
- 	memcpy(iwr.u.name+sizeof(__u32), &arg, sizeof(arg));
- 
-@@ -233,6 +237,7 @@ ether_sprintf(const u8 *addr)
- }
- #endif /* CONFIG_NO_STDOUT_DEBUG */
- 
-+#ifdef HOSTAPD
- /*
-  * Configure WPA parameters.
-  */
-@@ -395,7 +400,7 @@ madwifi_sta_set_flags(void *priv, const 
- 		return madwifi_set_sta_authorized(priv, addr, 0);
- 	return 0;
- }
--
-+#endif /* HOSTAPD */
- static int
- madwifi_del_key(void *priv, const u8 *addr, int key_idx)
- {
-@@ -407,28 +412,20 @@ madwifi_del_key(void *priv, const u8 *ad
- 		   __func__, ether_sprintf(addr), key_idx);
- 
- 	memset(&wk, 0, sizeof(wk));
-+	wk.idk_keyix = key_idx;
- 	if (addr != NULL) {
- 		memcpy(wk.idk_macaddr, addr, IEEE80211_ADDR_LEN);
--		wk.idk_keyix = (u8) IEEE80211_KEYIX_NONE;
--	} else {
--		wk.idk_keyix = key_idx;
--	}
--
--	ret = set80211priv(drv, IEEE80211_IOCTL_DELKEY, &wk, sizeof(wk));
--	if (ret < 0) {
--		wpa_printf(MSG_DEBUG, "%s: Failed to delete key (addr %s"
--			   " key_idx %d)", __func__, ether_sprintf(addr),
--			   key_idx);
- 	}
- 
--	return ret;
-+	set80211priv(drv, IEEE80211_IOCTL_DELKEY, &wk, sizeof(wk));
-+	return 0;
- }
- 
- static int
--wpa_driver_madwifi_set_key(const char *ifname, void *priv, enum wpa_alg alg,
--			   const u8 *addr, int key_idx, int set_tx,
--			   const u8 *seq, size_t seq_len,
--			   const u8 *key, size_t key_len)
-+madwifi_set_key(const char *ifname, void *priv, enum wpa_alg alg,
-+		const u8 *addr, int key_idx, int set_tx,
-+		const u8 *seq, size_t seq_len,
-+		const u8 *key, size_t key_len)
- {
- 	struct madwifi_driver_data *drv = priv;
- 	struct ieee80211req_key wk;
-@@ -466,6 +463,9 @@ wpa_driver_madwifi_set_key(const char *i
- 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
- 		wk.ik_keyix = key_idx;
- 		wk.ik_flags |= IEEE80211_KEY_DEFAULT;
-+	} else if (!memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN)) {
-+		wk.ik_flags |= IEEE80211_KEY_GROUP;
-+		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
- 	} else {
- 		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
- 		wk.ik_keyix = IEEE80211_KEYIX_NONE;
-@@ -485,6 +485,7 @@ wpa_driver_madwifi_set_key(const char *i
- }
- 
- 
-+#ifdef HOSTAPD
- static int
- madwifi_get_seqnum(const char *ifname, void *priv, const u8 *addr, int idx,
- 		   u8 *seq)
-@@ -591,7 +592,7 @@ madwifi_read_sta_driver_data(void *priv,
- 
- 	memset(data, 0, sizeof(*data));
- 	snprintf(buf, sizeof(buf), "/proc/net/madwifi/%s/" MACSTR,
--		 drv->iface, MAC2STR(addr));
-+		 drv->ifname, MAC2STR(addr));
- 
- 	f = fopen(buf, "r");
- 	if (!f) {
-@@ -759,7 +760,7 @@ static int madwifi_receive_probe_req(str
- 	if (ret)
- 		return ret;
- 
--	drv->sock_raw = l2_packet_init(drv->iface, NULL, ETH_P_80211_RAW,
-+	drv->sock_raw = l2_packet_init(drv->ifname, NULL, ETH_P_80211_RAW,
- 				       madwifi_raw_receive, drv, 1);
- 	if (drv->sock_raw == NULL)
- 		return -1;
-@@ -812,7 +813,7 @@ static int madwifi_set_freq(void *priv, 
- 	struct iwreq iwr;
- 
- 	os_memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- 	iwr.u.freq.m = freq->channel;
- 	iwr.u.freq.e = 0;
- 
-@@ -1037,7 +1038,7 @@ madwifi_get_we_version(struct madwifi_dr
- 		return -1;
- 
- 	memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- 	iwr.u.data.pointer = (caddr_t) range;
- 	iwr.u.data.length = buflen;
- 
-@@ -1154,17 +1155,17 @@ madwifi_init(struct hostapd_data *hapd, 
- 		perror("socket[PF_INET,SOCK_DGRAM]");
- 		goto bad;
- 	}
--	memcpy(drv->iface, params->ifname, sizeof(drv->iface));
-+	memcpy(drv->ifname, params->ifname, sizeof(drv->ifname));
- 
- 	memset(&ifr, 0, sizeof(ifr));
--	os_strlcpy(ifr.ifr_name, drv->iface, sizeof(ifr.ifr_name));
-+	os_strlcpy(ifr.ifr_name, drv->ifname, sizeof(ifr.ifr_name));
- 	if (ioctl(drv->ioctl_sock, SIOCGIFINDEX, &ifr) != 0) {
- 		perror("ioctl(SIOCGIFINDEX)");
- 		goto bad;
- 	}
- 	drv->ifindex = ifr.ifr_ifindex;
- 
--	drv->sock_xmit = l2_packet_init(drv->iface, NULL, ETH_P_EAPOL,
-+	drv->sock_xmit = l2_packet_init(drv->ifname, NULL, ETH_P_EAPOL,
- 					handle_read, drv, 1);
- 	if (drv->sock_xmit == NULL)
- 		goto bad;
-@@ -1178,7 +1179,7 @@ madwifi_init(struct hostapd_data *hapd, 
- 						1);
- 		if (drv->sock_recv == NULL)
- 			goto bad;
--	} else if (linux_br_get(brname, drv->iface) == 0) {
-+	} else if (linux_br_get(brname, drv->ifname) == 0) {
- 		wpa_printf(MSG_DEBUG, "Interface in bridge %s; configure for "
- 			   "EAPOL receive", brname);
- 		drv->sock_recv = l2_packet_init(brname, NULL, ETH_P_EAPOL,
-@@ -1189,7 +1190,7 @@ madwifi_init(struct hostapd_data *hapd, 
- 		drv->sock_recv = drv->sock_xmit;
- 
- 	memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- 
- 	iwr.u.mode = IW_MODE_MASTER;
- 
-@@ -1200,7 +1201,7 @@ madwifi_init(struct hostapd_data *hapd, 
- 	}
- 
- 	/* mark down during setup */
--	linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
-+	linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0);
- 	madwifi_set_privacy(drv, 0); /* default to no privacy */
- 
- 	madwifi_receive_probe_req(drv);
-@@ -1226,7 +1227,7 @@ madwifi_deinit(void *priv)
- 	struct madwifi_driver_data *drv = priv;
- 
- 	netlink_deinit(drv->netlink);
--	(void) linux_set_iface_flags(drv->ioctl_sock, drv->iface, 0);
-+	(void) linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 0);
- 	if (drv->ioctl_sock >= 0)
- 		close(drv->ioctl_sock);
- 	if (drv->sock_recv != NULL && drv->sock_recv != drv->sock_xmit)
-@@ -1245,7 +1246,7 @@ madwifi_set_ssid(void *priv, const u8 *b
- 	struct iwreq iwr;
- 
- 	memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- 	iwr.u.essid.flags = 1; /* SSID active */
- 	iwr.u.essid.pointer = (caddr_t) buf;
- 	iwr.u.essid.length = len + 1;
-@@ -1266,7 +1267,7 @@ madwifi_get_ssid(void *priv, u8 *buf, in
- 	int ret = 0;
- 
- 	memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->iface, IFNAMSIZ);
-+	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
- 	iwr.u.essid.pointer = (caddr_t) buf;
- 	iwr.u.essid.length = len;
- 
-@@ -1291,140 +1292,19 @@ static int
- madwifi_commit(void *priv)
- {
- 	struct madwifi_driver_data *drv = priv;
--	return linux_set_iface_flags(drv->ioctl_sock, drv->iface, 1);
-+	return linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1);
- }
- 
--#else /* HOSTAPD */
-+#endif /* HOSTAPD */
- 
--struct wpa_driver_madwifi_data {
--	void *wext; /* private data for driver_wext */
--	void *ctx;
--	char ifname[IFNAMSIZ + 1];
--	int sock;
--};
-+#if !defined(NO_SUPPLICANT)
- 
- static int wpa_driver_madwifi_set_auth_alg(void *priv, int auth_alg);
- static int wpa_driver_madwifi_set_probe_req_ie(void *priv, const u8 *ies,
- 					       size_t ies_len);
- 
--
--static int
--set80211priv(struct wpa_driver_madwifi_data *drv, int op, void *data, int len,
--	     int show_err)
--{
--	struct iwreq iwr;
--
--	os_memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
--	if (len < IFNAMSIZ &&
--	    op != IEEE80211_IOCTL_SET_APPIEBUF) {
--		/*
--		 * Argument data fits inline; put it there.
--		 */
--		os_memcpy(iwr.u.name, data, len);
--	} else {
--		/*
--		 * Argument data too big for inline transfer; setup a
--		 * parameter block instead; the kernel will transfer
--		 * the data for the driver.
--		 */
--		iwr.u.data.pointer = data;
--		iwr.u.data.length = len;
--	}
--
--	if (ioctl(drv->sock, op, &iwr) < 0) {
--		if (show_err) {
--#ifdef MADWIFI_NG
--			int first = IEEE80211_IOCTL_SETPARAM;
--			int last = IEEE80211_IOCTL_KICKMAC;
--			static const char *opnames[] = {
--				"ioctl[IEEE80211_IOCTL_SETPARAM]",
--				"ioctl[IEEE80211_IOCTL_GETPARAM]",
--				"ioctl[IEEE80211_IOCTL_SETMODE]",
--				"ioctl[IEEE80211_IOCTL_GETMODE]",
--				"ioctl[IEEE80211_IOCTL_SETWMMPARAMS]",
--				"ioctl[IEEE80211_IOCTL_GETWMMPARAMS]",
--				"ioctl[IEEE80211_IOCTL_SETCHANLIST]",
--				"ioctl[IEEE80211_IOCTL_GETCHANLIST]",
--				"ioctl[IEEE80211_IOCTL_CHANSWITCH]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_SET_APPIEBUF]",
--				"ioctl[IEEE80211_IOCTL_GETSCANRESULTS]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_GETCHANINFO]",
--				"ioctl[IEEE80211_IOCTL_SETOPTIE]",
--				"ioctl[IEEE80211_IOCTL_GETOPTIE]",
--				"ioctl[IEEE80211_IOCTL_SETMLME]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_SETKEY]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_DELKEY]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_ADDMAC]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_DELMAC]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_WDSMAC]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_WDSDELMAC]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_KICKMAC]",
--			};
--#else /* MADWIFI_NG */
--			int first = IEEE80211_IOCTL_SETPARAM;
--			int last = IEEE80211_IOCTL_CHANLIST;
--			static const char *opnames[] = {
--				"ioctl[IEEE80211_IOCTL_SETPARAM]",
--				"ioctl[IEEE80211_IOCTL_GETPARAM]",
--				"ioctl[IEEE80211_IOCTL_SETKEY]",
--				"ioctl[IEEE80211_IOCTL_GETKEY]",
--				"ioctl[IEEE80211_IOCTL_DELKEY]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_SETMLME]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_SETOPTIE]",
--				"ioctl[IEEE80211_IOCTL_GETOPTIE]",
--				"ioctl[IEEE80211_IOCTL_ADDMAC]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_DELMAC]",
--				NULL,
--				"ioctl[IEEE80211_IOCTL_CHANLIST]",
--			};
--#endif /* MADWIFI_NG */
--			int idx = op - first;
--			if (first <= op && op <= last &&
--			    idx < (int) (sizeof(opnames) / sizeof(opnames[0]))
--			    && opnames[idx])
--				perror(opnames[idx]);
--			else
--				perror("ioctl[unknown???]");
--		}
--		return -1;
--	}
--	return 0;
--}
--
- static int
--set80211param(struct wpa_driver_madwifi_data *drv, int op, int arg,
--	      int show_err)
--{
--	struct iwreq iwr;
--
--	os_memset(&iwr, 0, sizeof(iwr));
--	os_strlcpy(iwr.ifr_name, drv->ifname, IFNAMSIZ);
--	iwr.u.mode = op;
--	os_memcpy(iwr.u.name+sizeof(u32), &arg, sizeof(arg));
--
--	if (ioctl(drv->sock, IEEE80211_IOCTL_SETPARAM, &iwr) < 0) {
--		if (show_err) 
--			perror("ioctl[IEEE80211_IOCTL_SETPARAM]");
--		return -1;
--	}
--	return 0;
--}
--
--static int
--wpa_driver_madwifi_set_wpa_ie(struct wpa_driver_madwifi_data *drv,
-+wpa_driver_madwifi_set_wpa_ie(struct madwifi_driver_data *drv,
- 			      const u8 *wpa_ie, size_t wpa_ie_len)
- {
- 	struct iwreq iwr;
-@@ -1435,7 +1315,7 @@ wpa_driver_madwifi_set_wpa_ie(struct wpa
- 	iwr.u.data.pointer = (void *) wpa_ie;
- 	iwr.u.data.length = wpa_ie_len;
- 
--	if (ioctl(drv->sock, IEEE80211_IOCTL_SETOPTIE, &iwr) < 0) {
-+	if (ioctl(drv->ioctl_sock, IEEE80211_IOCTL_SETOPTIE, &iwr) < 0) {
- 		perror("ioctl[IEEE80211_IOCTL_SETOPTIE]");
- 		return -1;
- 	}
-@@ -1443,157 +1323,51 @@ wpa_driver_madwifi_set_wpa_ie(struct wpa
- }
- 
- static int
--wpa_driver_madwifi_del_key(struct wpa_driver_madwifi_data *drv, int key_idx,
--			   const u8 *addr)
--{
--	struct ieee80211req_del_key wk;
--
--	wpa_printf(MSG_DEBUG, "%s: keyidx=%d", __FUNCTION__, key_idx);
--	os_memset(&wk, 0, sizeof(wk));
--	wk.idk_keyix = key_idx;
--	if (addr != NULL)
--		os_memcpy(wk.idk_macaddr, addr, IEEE80211_ADDR_LEN);
--
--	return set80211priv(drv, IEEE80211_IOCTL_DELKEY, &wk, sizeof(wk), 1);
--}
--
--static int
--wpa_driver_madwifi_set_key(const char *ifname, void *priv, enum wpa_alg alg,
--			   const u8 *addr, int key_idx, int set_tx,
--			   const u8 *seq, size_t seq_len,
--			   const u8 *key, size_t key_len)
--{
--	struct wpa_driver_madwifi_data *drv = priv;
--	struct ieee80211req_key wk;
--	char *alg_name;
--	u_int8_t cipher;
--
--	if (alg == WPA_ALG_NONE)
--		return wpa_driver_madwifi_del_key(drv, key_idx, addr);
--
--	switch (alg) {
--	case WPA_ALG_WEP:
--		if (addr == NULL || os_memcmp(addr, "\xff\xff\xff\xff\xff\xff",
--					      ETH_ALEN) == 0) {
--			/*
--			 * madwifi did not seem to like static WEP key
--			 * configuration with IEEE80211_IOCTL_SETKEY, so use
--			 * Linux wireless extensions ioctl for this.
--			 */
--			return wpa_driver_wext_set_key(ifname, drv->wext, alg,
--						       addr, key_idx, set_tx,
--						       seq, seq_len,
--						       key, key_len);
--		}
--		alg_name = "WEP";
--		cipher = IEEE80211_CIPHER_WEP;
--		break;
--	case WPA_ALG_TKIP:
--		alg_name = "TKIP";
--		cipher = IEEE80211_CIPHER_TKIP;
--		break;
--	case WPA_ALG_CCMP:
--		alg_name = "CCMP";
--		cipher = IEEE80211_CIPHER_AES_CCM;
--		break;
--	default:
--		wpa_printf(MSG_DEBUG, "%s: unknown/unsupported algorithm %d",
--			__FUNCTION__, alg);
--		return -1;
--	}
--
--	wpa_printf(MSG_DEBUG, "%s: alg=%s key_idx=%d set_tx=%d seq_len=%lu "
--		   "key_len=%lu", __FUNCTION__, alg_name, key_idx, set_tx,
--		   (unsigned long) seq_len, (unsigned long) key_len);
--
--	if (seq_len > sizeof(u_int64_t)) {
--		wpa_printf(MSG_DEBUG, "%s: seq_len %lu too big",
--			   __FUNCTION__, (unsigned long) seq_len);
--		return -2;
--	}
--	if (key_len > sizeof(wk.ik_keydata)) {
--		wpa_printf(MSG_DEBUG, "%s: key length %lu too big",
--			   __FUNCTION__, (unsigned long) key_len);
--		return -3;
--	}
--
--	os_memset(&wk, 0, sizeof(wk));
--	wk.ik_type = cipher;
--	wk.ik_flags = IEEE80211_KEY_RECV;
--	if (addr == NULL ||
--	    os_memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN) == 0)
--		wk.ik_flags |= IEEE80211_KEY_GROUP;
--	if (set_tx) {
--		wk.ik_flags |= IEEE80211_KEY_XMIT | IEEE80211_KEY_DEFAULT;
--		os_memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
--	} else
--		os_memset(wk.ik_macaddr, 0, IEEE80211_ADDR_LEN);
--	wk.ik_keyix = key_idx;
--	wk.ik_keylen = key_len;
--#ifdef WORDS_BIGENDIAN
--	if (seq) {
--		size_t i;
--		u8 tmp[WPA_KEY_RSC_LEN];
--		os_memset(tmp, 0, sizeof(tmp));
--		for (i = 0; i < seq_len; i++)
--			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
--		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
--	}
--#else /* WORDS_BIGENDIAN */
--	if (seq)
--		os_memcpy(&wk.ik_keyrsc, seq, seq_len);
--#endif /* WORDS_BIGENDIAN */
--	os_memcpy(wk.ik_keydata, key, key_len);
--
--	return set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk), 1);
--}
--
--static int
- wpa_driver_madwifi_set_countermeasures(void *priv, int enabled)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
--	return set80211param(drv, IEEE80211_PARAM_COUNTERMEASURES, enabled, 1);
-+	return set80211param(drv, IEEE80211_PARAM_COUNTERMEASURES, enabled);
- }
- 
- static int
- wpa_driver_madwifi_deauthenticate(void *priv, const u8 *addr, int reason_code)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	struct ieee80211req_mlme mlme;
- 
- 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
- 	mlme.im_op = IEEE80211_MLME_DEAUTH;
- 	mlme.im_reason = reason_code;
- 	os_memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
--	return set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme), 1);
-+	return set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
- }
- 
- static int
- wpa_driver_madwifi_disassociate(void *priv, const u8 *addr, int reason_code)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	struct ieee80211req_mlme mlme;
- 
- 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
- 	mlme.im_op = IEEE80211_MLME_DISASSOC;
- 	mlme.im_reason = reason_code;
- 	os_memcpy(mlme.im_macaddr, addr, IEEE80211_ADDR_LEN);
--	return set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme), 1);
-+	return set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme, sizeof(mlme));
- }
- 
- static int
- wpa_driver_madwifi_associate(void *priv,
- 			     struct wpa_driver_associate_params *params)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	struct ieee80211req_mlme mlme;
- 	int ret = 0, privacy = 1;
- 
- 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
- 
- 	if (set80211param(drv, IEEE80211_PARAM_DROPUNENCRYPTED,
--			  params->drop_unencrypted, 1) < 0)
-+			  params->drop_unencrypted) < 0)
- 		ret = -1;
- 	if (wpa_driver_madwifi_set_auth_alg(drv, params->auth_alg) < 0)
- 		ret = -1;
-@@ -1616,12 +1390,12 @@ wpa_driver_madwifi_associate(void *priv,
- 	    params->wpa_ie_len == 0)
- 		privacy = 0;
- 
--	if (set80211param(drv, IEEE80211_PARAM_PRIVACY, privacy, 1) < 0)
-+	if (set80211param(drv, IEEE80211_PARAM_PRIVACY, privacy) < 0)
- 		ret = -1;
- 
- 	if (params->wpa_ie_len &&
- 	    set80211param(drv, IEEE80211_PARAM_WPA,
--			  params->wpa_ie[0] == WLAN_EID_RSN ? 2 : 1, 1) < 0)
-+			  params->wpa_ie[0] == WLAN_EID_RSN ? 2 : 1) < 0)
- 		ret = -1;
- 
- 	if (params->bssid == NULL) {
-@@ -1629,14 +1403,14 @@ wpa_driver_madwifi_associate(void *priv,
- 		 * roaming */
- 		/* FIX: this does not seem to work; would probably need to
- 		 * change something in the driver */
--		if (set80211param(drv, IEEE80211_PARAM_ROAMING, 0, 1) < 0)
-+		if (set80211param(drv, IEEE80211_PARAM_ROAMING, 0) < 0)
- 			ret = -1;
- 
- 		if (wpa_driver_wext_set_ssid(drv->wext, params->ssid,
- 					     params->ssid_len) < 0)
- 			ret = -1;
- 	} else {
--		if (set80211param(drv, IEEE80211_PARAM_ROAMING, 2, 1) < 0)
-+		if (set80211param(drv, IEEE80211_PARAM_ROAMING, 2) < 0)
- 			ret = -1;
- 		if (wpa_driver_wext_set_ssid(drv->wext, params->ssid,
- 					     params->ssid_len) < 0)
-@@ -1645,7 +1419,7 @@ wpa_driver_madwifi_associate(void *priv,
- 		mlme.im_op = IEEE80211_MLME_ASSOC;
- 		os_memcpy(mlme.im_macaddr, params->bssid, IEEE80211_ADDR_LEN);
- 		if (set80211priv(drv, IEEE80211_IOCTL_SETMLME, &mlme,
--				 sizeof(mlme), 1) < 0) {
-+				 sizeof(mlme)) < 0) {
- 			wpa_printf(MSG_DEBUG, "%s: SETMLME[ASSOC] failed",
- 				   __func__);
- 			ret = -1;
-@@ -1658,7 +1432,7 @@ wpa_driver_madwifi_associate(void *priv,
- static int
- wpa_driver_madwifi_set_auth_alg(void *priv, int auth_alg)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	int authmode;
- 
- 	if ((auth_alg & WPA_AUTH_ALG_OPEN) &&
-@@ -1669,13 +1443,13 @@ wpa_driver_madwifi_set_auth_alg(void *pr
- 	else
- 		authmode = IEEE80211_AUTH_OPEN;
- 
--	return set80211param(drv, IEEE80211_PARAM_AUTHMODE, authmode, 1);
-+	return set80211param(drv, IEEE80211_PARAM_AUTHMODE, authmode);
- }
- 
- static int
- wpa_driver_madwifi_scan(void *priv, struct wpa_driver_scan_params *params)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	struct iwreq iwr;
- 	int ret = 0;
- 	const u8 *ssid = params->ssids[0].ssid;
-@@ -1693,7 +1467,7 @@ wpa_driver_madwifi_scan(void *priv, stru
- 	if (wpa_driver_wext_set_ssid(drv->wext, ssid, ssid_len) < 0)
- 		ret = -1;
- 
--	if (ioctl(drv->sock, SIOCSIWSCAN, &iwr) < 0) {
-+	if (ioctl(drv->ioctl_sock, SIOCSIWSCAN, &iwr) < 0) {
- 		perror("ioctl[SIOCSIWSCAN]");
- 		ret = -1;
- 	}
-@@ -1715,14 +1489,14 @@ wpa_driver_madwifi_scan(void *priv, stru
- 
- static int wpa_driver_madwifi_get_bssid(void *priv, u8 *bssid)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	return wpa_driver_wext_get_bssid(drv->wext, bssid);
- }
- 
- 
- static int wpa_driver_madwifi_get_ssid(void *priv, u8 *ssid)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	return wpa_driver_wext_get_ssid(drv->wext, ssid);
- }
- 
-@@ -1730,14 +1504,16 @@ static int wpa_driver_madwifi_get_ssid(v
- static struct wpa_scan_results *
- wpa_driver_madwifi_get_scan_results(void *priv)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 	return wpa_driver_wext_get_scan_results(drv->wext);
- }
- 
- 
- static int wpa_driver_madwifi_set_operstate(void *priv, int state)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
-+	if (!drv->wext)
-+		return 0;
- 	return wpa_driver_wext_set_operstate(drv->wext, state);
- }
- 
-@@ -1758,7 +1534,7 @@ static int wpa_driver_madwifi_set_probe_
- 
- 	ret = set80211priv(priv, IEEE80211_IOCTL_SET_APPIEBUF, probe_req_ie,
- 			   sizeof(struct ieee80211req_getset_appiebuf) +
--			   ies_len, 1);
-+			   ies_len);
- 
- 	os_free(probe_req_ie);
- 
-@@ -1768,7 +1544,7 @@ static int wpa_driver_madwifi_set_probe_
- 
- static void * wpa_driver_madwifi_init(void *ctx, const char *ifname)
- {
--	struct wpa_driver_madwifi_data *drv;
-+	struct madwifi_driver_data *drv;
- 
- 	drv = os_zalloc(sizeof(*drv));
- 	if (drv == NULL)
-@@ -1779,17 +1555,17 @@ static void * wpa_driver_madwifi_init(vo
- 
- 	drv->ctx = ctx;
- 	os_strlcpy(drv->ifname, ifname, sizeof(drv->ifname));
--	drv->sock = socket(PF_INET, SOCK_DGRAM, 0);
--	if (drv->sock < 0)
-+	drv->ioctl_sock = socket(PF_INET, SOCK_DGRAM, 0);
-+	if (drv->ioctl_sock < 0)
- 		goto fail2;
- 
--	if (set80211param(drv, IEEE80211_PARAM_ROAMING, 2, 1) < 0) {
-+	if (set80211param(drv, IEEE80211_PARAM_ROAMING, 2) < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: failed to set wpa_supplicant-based "
- 			   "roaming", __FUNCTION__);
- 		goto fail3;
- 	}
- 
--	if (set80211param(drv, IEEE80211_PARAM_WPA, 3, 1) < 0) {
-+	if (set80211param(drv, IEEE80211_PARAM_WPA, 3) < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: failed to enable WPA support",
- 			   __FUNCTION__);
- 		goto fail3;
-@@ -1798,7 +1574,7 @@ static void * wpa_driver_madwifi_init(vo
- 	return drv;
- 
- fail3:
--	close(drv->sock);
-+	close(drv->ioctl_sock);
- fail2:
- 	wpa_driver_wext_deinit(drv->wext);
- fail:
-@@ -1809,38 +1585,37 @@ fail:
- 
- static void wpa_driver_madwifi_deinit(void *priv)
- {
--	struct wpa_driver_madwifi_data *drv = priv;
-+	struct madwifi_driver_data *drv = priv;
- 
- 	if (wpa_driver_madwifi_set_wpa_ie(drv, NULL, 0) < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: failed to clear WPA IE",
- 			   __FUNCTION__);
- 	}
--	if (set80211param(drv, IEEE80211_PARAM_ROAMING, 0, 1) < 0) {
-+	if (set80211param(drv, IEEE80211_PARAM_ROAMING, 0) < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: failed to enable driver-based "
- 			   "roaming", __FUNCTION__);
- 	}
--	if (set80211param(drv, IEEE80211_PARAM_PRIVACY, 0, 1) < 0) {
-+	if (set80211param(drv, IEEE80211_PARAM_PRIVACY, 0) < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: failed to disable forced Privacy "
- 			   "flag", __FUNCTION__);
- 	}
--	if (set80211param(drv, IEEE80211_PARAM_WPA, 0, 1) < 0) {
-+	if (set80211param(drv, IEEE80211_PARAM_WPA, 0) < 0) {
- 		wpa_printf(MSG_DEBUG, "%s: failed to disable WPA",
- 			   __FUNCTION__);
- 	}
- 
- 	wpa_driver_wext_deinit(drv->wext);
- 
--	close(drv->sock);
-+	close(drv->ioctl_sock);
- 	os_free(drv);
- }
- 
--#endif /* HOSTAPD */
--
-+#endif
- 
- const struct wpa_driver_ops wpa_driver_madwifi_ops = {
- 	.name			= "madwifi",
- 	.desc			= "MADWIFI 802.11 support (Atheros, etc.)",
--	.set_key		= wpa_driver_madwifi_set_key,
-+	.set_key		= madwifi_set_key,
- #ifdef HOSTAPD
- 	.hapd_init		= madwifi_init,
- 	.hapd_deinit		= madwifi_deinit,
-@@ -1861,7 +1636,8 @@ const struct wpa_driver_ops wpa_driver_m
- 	.commit			= madwifi_commit,
- 	.set_ap_wps_ie		= madwifi_set_ap_wps_ie,
- 	.set_freq		= madwifi_set_freq,
--#else /* HOSTAPD */
-+#endif /* HOSTAPD */
-+#if !defined(NO_SUPPLICANT)
- 	.get_bssid		= wpa_driver_madwifi_get_bssid,
- 	.get_ssid		= wpa_driver_madwifi_get_ssid,
- 	.init			= wpa_driver_madwifi_init,
-@@ -1873,5 +1649,5 @@ const struct wpa_driver_ops wpa_driver_m
- 	.disassociate		= wpa_driver_madwifi_disassociate,
- 	.associate		= wpa_driver_madwifi_associate,
- 	.set_operstate		= wpa_driver_madwifi_set_operstate,
--#endif /* HOSTAPD */
-+#endif
- };
---- a/src/drivers/drivers.mak
-+++ b/src/drivers/drivers.mak
-@@ -144,8 +144,8 @@ DRV_WPA_OBJS += ../src/drivers/driver_ro
- endif
- 
- ifdef CONFIG_WIRELESS_EXTENSION
--DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
--DRV_WPA_OBJS += ../src/drivers/driver_wext.o
-+DRV_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
-+DRV_OBJS += ../src/drivers/driver_wext.o
- NEED_RFKILL=y
- endif
- 
diff --exclude .svn -Nru package/hostapd/patches/310-multicall_bridge_fix.patch package/hostapd/patches/310-multicall_bridge_fix.patch
--- package/hostapd/patches/310-multicall_bridge_fix.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/310-multicall_bridge_fix.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,45 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -893,6 +893,10 @@ static void wpa_driver_nl80211_event_rtm
+ 		return;
+ 	}
+ 
++	if (ifi->ifi_family == AF_BRIDGE &&
++	    drv->nlmode != NL80211_IFTYPE_AP)
++		return;
++
+ 	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
+ 		   "(%s%s%s%s)",
+ 		   drv->operstate, ifi->ifi_flags,
+@@ -1000,6 +1004,10 @@ static void wpa_driver_nl80211_event_rtm
+ 	attrlen = len;
+ 	attr = (struct rtattr *) buf;
+ 
++	if (ifi->ifi_family == AF_BRIDGE &&
++	    drv->nlmode != NL80211_IFTYPE_AP)
++		return;
++
+ 	rta_len = RTA_ALIGN(sizeof(struct rtattr));
+ 	while (RTA_OK(attr, attrlen)) {
+ 		if (attr->rta_type == IFLA_IFNAME) {
+@@ -2990,6 +2998,11 @@ static void * wpa_driver_nl80211_init(vo
+ 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
+ 	drv->nlmode = NL80211_IFTYPE_STATION;
+ 
++#ifdef HOSTAPD
++	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
++	drv->if_indices = drv->default_if_indices;
++#endif
++
+ 	if (wpa_driver_nl80211_init_nl(drv)) {
+ 		os_free(drv);
+ 		return NULL;
+@@ -7819,8 +7832,6 @@ static void *i802_init(struct hostapd_da
+ 		br_ifindex = 0;
+ 	}
+ 
+-	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
+-	drv->if_indices = drv->default_if_indices;
+ 	for (i = 0; i < params->num_bridge; i++) {
+ 		if (params->bridge[i]) {
+ 			ifindex = if_nametoindex(params->bridge[i]);
diff --exclude .svn -Nru package/hostapd/patches/320-madwifi_key_fixes.patch package/hostapd/patches/320-madwifi_key_fixes.patch
--- package/hostapd/patches/320-madwifi_key_fixes.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/320-madwifi_key_fixes.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,34 @@
+--- a/src/drivers/driver_madwifi.c
++++ b/src/drivers/driver_madwifi.c
+@@ -453,7 +453,9 @@ wpa_driver_madwifi_set_key(const char *i
+ 
+ 	memset(&wk, 0, sizeof(wk));
+ 	wk.ik_type = cipher;
+-	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
++	wk.ik_flags = IEEE80211_KEY_RECV;
++	if (set_tx)
++		wk.ik_flags |= IEEE80211_KEY_XMIT;
+ 	if (addr == NULL || is_broadcast_ether_addr(addr)) {
+ 		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
+ 		wk.ik_keyix = key_idx;
+@@ -465,6 +467,20 @@ wpa_driver_madwifi_set_key(const char *i
+ 	wk.ik_keylen = key_len;
+ 	memcpy(wk.ik_keydata, key, key_len);
+ 
++#ifdef WORDS_BIGENDIAN
++#define WPA_KEY_RSC_LEN 8
++	{
++		size_t i;
++		u8 tmp[WPA_KEY_RSC_LEN];
++		os_memset(tmp, 0, sizeof(tmp));
++		for (i = 0; i < seq_len; i++)
++			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
++		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
++	}
++#else /* WORDS_BIGENDIAN */
++	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
++#endif /* WORDS_BIGENDIAN */
++
+ 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
+ 	if (ret < 0) {
+ 		wpa_printf(MSG_DEBUG, "%s: Failed to set key (addr %s"
diff --exclude .svn -Nru package/hostapd/patches/320-nl80211_multicall_fixes.patch package/hostapd/patches/320-nl80211_multicall_fixes.patch
--- package/hostapd/patches/320-nl80211_multicall_fixes.patch	2012-08-17 15:40:41.391971000 +0200
+++ package/hostapd/patches/320-nl80211_multicall_fixes.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,76 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -2289,6 +2289,7 @@ static void * wpa_driver_nl80211_init(vo
- 	drv->monitor_ifidx = -1;
- 	drv->monitor_sock = -1;
- 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
-+	drv->nlmode = NL80211_IFTYPE_STATION;
- 
- 	if (wpa_driver_nl80211_init_nl(drv)) {
- 		os_free(drv);
-@@ -2446,37 +2447,37 @@ wpa_driver_nl80211_finish_drv_init(struc
- 	drv->ifindex = if_nametoindex(bss->ifname);
- 	drv->first_bss.ifindex = drv->ifindex;
- 
--#ifndef HOSTAPD
--	/*
--	 * Make sure the interface starts up in station mode unless this is a
--	 * dynamically added interface (e.g., P2P) that was already configured
--	 * with proper iftype.
--	 */
--	if ((drv->global == NULL ||
--	     drv->ifindex != drv->global->if_add_ifindex) &&
--	    wpa_driver_nl80211_set_mode(bss, NL80211_IFTYPE_STATION) < 0) {
--		wpa_printf(MSG_ERROR, "nl80211: Could not configure driver to "
--			   "use managed mode");
--		return -1;
--	}
--
--	if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
--		if (rfkill_is_blocked(drv->rfkill)) {
--			wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
--				   "interface '%s' due to rfkill",
--				   bss->ifname);
--			drv->if_disabled = 1;
--			send_rfkill_event = 1;
--		} else {
--			wpa_printf(MSG_ERROR, "nl80211: Could not set "
--				   "interface '%s' UP", bss->ifname);
-+	if (drv->nlmode == NL80211_IFTYPE_STATION) {
-+		/*
-+		 * Make sure the interface starts up in station mode unless this is a
-+		 * dynamically added interface (e.g., P2P) that was already configured
-+		 * with proper iftype.
-+		 */
-+		if ((drv->global == NULL ||
-+			 drv->ifindex != drv->global->if_add_ifindex) &&
-+			wpa_driver_nl80211_set_mode(bss, NL80211_IFTYPE_STATION) < 0) {
-+			wpa_printf(MSG_ERROR, "nl80211: Could not configure driver to "
-+				   "use managed mode");
- 			return -1;
- 		}
--	}
- 
--	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
--			       1, IF_OPER_DORMANT);
--#endif /* HOSTAPD */
-+		if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
-+			if (rfkill_is_blocked(drv->rfkill)) {
-+				wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
-+					   "interface '%s' due to rfkill",
-+					   bss->ifname);
-+				drv->if_disabled = 1;
-+				send_rfkill_event = 1;
-+			} else {
-+				wpa_printf(MSG_ERROR, "nl80211: Could not set "
-+					   "interface '%s' UP", bss->ifname);
-+				return -1;
-+			}
-+		}
-+
-+		netlink_send_oper_ifla(drv->global->netlink, drv->ifindex,
-+					   1, IF_OPER_DORMANT);
-+	}
- 
- 	if (wpa_driver_nl80211_capa(drv))
- 		return -1;
diff --exclude .svn -Nru package/hostapd/patches/330-multicall_bridge_fix.patch package/hostapd/patches/330-multicall_bridge_fix.patch
--- package/hostapd/patches/330-multicall_bridge_fix.patch	2012-08-17 15:40:41.381971000 +0200
+++ package/hostapd/patches/330-multicall_bridge_fix.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,45 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -600,6 +600,10 @@ static void wpa_driver_nl80211_event_rtm
- 		return;
- 	}
- 
-+	if (ifi->ifi_family == AF_BRIDGE &&
-+	    drv->nlmode != NL80211_IFTYPE_AP)
-+		return;
-+
- 	wpa_printf(MSG_DEBUG, "RTM_NEWLINK: operstate=%d ifi_flags=0x%x "
- 		   "(%s%s%s%s)",
- 		   drv->operstate, ifi->ifi_flags,
-@@ -692,6 +696,10 @@ static void wpa_driver_nl80211_event_rtm
- 	attrlen = len;
- 	attr = (struct rtattr *) buf;
- 
-+	if (ifi->ifi_family == AF_BRIDGE &&
-+	    drv->nlmode != NL80211_IFTYPE_AP)
-+		return;
-+
- 	rta_len = RTA_ALIGN(sizeof(struct rtattr));
- 	while (RTA_OK(attr, attrlen)) {
- 		if (attr->rta_type == IFLA_IFNAME) {
-@@ -2291,6 +2299,11 @@ static void * wpa_driver_nl80211_init(vo
- 	drv->ap_scan_as_station = NL80211_IFTYPE_UNSPECIFIED;
- 	drv->nlmode = NL80211_IFTYPE_STATION;
- 
-+#ifdef HOSTAPD
-+	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
-+	drv->if_indices = drv->default_if_indices;
-+#endif
-+
- 	if (wpa_driver_nl80211_init_nl(drv)) {
- 		os_free(drv);
- 		return NULL;
-@@ -6531,8 +6544,6 @@ static void *i802_init(struct hostapd_da
- 		br_ifindex = 0;
- 	}
- 
--	drv->num_if_indices = sizeof(drv->default_if_indices) / sizeof(int);
--	drv->if_indices = drv->default_if_indices;
- 	for (i = 0; i < params->num_bridge; i++) {
- 		if (params->bridge[i]) {
- 			ifindex = if_nametoindex(params->bridge[i]);
diff --exclude .svn -Nru package/hostapd/patches/340-madwifi_key_fixes.patch package/hostapd/patches/340-madwifi_key_fixes.patch
--- package/hostapd/patches/340-madwifi_key_fixes.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/340-madwifi_key_fixes.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,69 +0,0 @@
---- a/src/drivers/driver_madwifi.c
-+++ b/src/drivers/driver_madwifi.c
-@@ -439,7 +439,11 @@ madwifi_set_key(const char *ifname, void
- 		   __func__, alg, ether_sprintf(addr), key_idx);
- 
- 	if (alg == WPA_ALG_WEP)
-+	{
- 		cipher = IEEE80211_CIPHER_WEP;
-+		if ((!addr || !memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN)) && drv->wext)
-+			return wpa_driver_wext_set_key(ifname, drv->wext, alg, addr, key_idx, set_tx, seq, seq_len, key, key_len);
-+	}
- 	else if (alg == WPA_ALG_TKIP)
- 		cipher = IEEE80211_CIPHER_TKIP;
- 	else if (alg == WPA_ALG_CCMP)
-@@ -458,20 +462,45 @@ madwifi_set_key(const char *ifname, void
- 
- 	memset(&wk, 0, sizeof(wk));
- 	wk.ik_type = cipher;
--	wk.ik_flags = IEEE80211_KEY_RECV | IEEE80211_KEY_XMIT;
--	if (addr == NULL || is_broadcast_ether_addr(addr)) {
--		memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
-+	wk.ik_flags = IEEE80211_KEY_RECV;
-+	if (set_tx)
-+		wk.ik_flags |= IEEE80211_KEY_XMIT;
-+	if (addr == NULL) {
-+		os_memset(wk.ik_macaddr, 0xff, IEEE80211_ADDR_LEN);
- 		wk.ik_keyix = key_idx;
--		wk.ik_flags |= IEEE80211_KEY_DEFAULT;
--	} else if (!memcmp(addr, "\xff\xff\xff\xff\xff\xff", ETH_ALEN)) {
--		wk.ik_flags |= IEEE80211_KEY_GROUP;
--		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
- 	} else {
--		memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
--		wk.ik_keyix = IEEE80211_KEYIX_NONE;
-+		os_memcpy(wk.ik_macaddr, addr, IEEE80211_ADDR_LEN);
-+		/*
-+		 * Deduce whether group/global or unicast key by checking
-+		 * the address (yech).  Note also that we can only mark global
-+		 * keys default; doing this for a unicast key is an error.
-+		 */
-+		if (os_memcmp(addr, "\xff\xff\xff\xff\xff\xff",
-+			      IEEE80211_ADDR_LEN) == 0) {
-+			wk.ik_flags |= IEEE80211_KEY_GROUP;
-+			wk.ik_keyix = key_idx;
-+		} else {
-+			wk.ik_keyix = key_idx == 0 ? IEEE80211_KEYIX_NONE :
-+				key_idx;
-+		}
- 	}
-+	if (wk.ik_keyix != IEEE80211_KEYIX_NONE && set_tx)
-+		wk.ik_flags |= IEEE80211_KEY_DEFAULT;
- 	wk.ik_keylen = key_len;
- 	memcpy(wk.ik_keydata, key, key_len);
-+#ifdef WORDS_BIGENDIAN
-+#define WPA_KEY_RSC_LEN 8
-+	{
-+		size_t i;
-+		u8 tmp[WPA_KEY_RSC_LEN];
-+		os_memset(tmp, 0, sizeof(tmp));
-+		for (i = 0; i < seq_len; i++)
-+			tmp[WPA_KEY_RSC_LEN - i - 1] = seq[i];
-+		os_memcpy(&wk.ik_keyrsc, tmp, WPA_KEY_RSC_LEN);
-+	}
-+#else /* WORDS_BIGENDIAN */
-+	os_memcpy(&wk.ik_keyrsc, seq, seq_len);
-+#endif /* WORDS_BIGENDIAN */
- 
- 	ret = set80211priv(drv, IEEE80211_IOCTL_SETKEY, &wk, sizeof(wk));
- 	if (ret < 0) {
diff --exclude .svn -Nru package/hostapd/patches/350-hostap_multicall_fix.patch package/hostapd/patches/350-hostap_multicall_fix.patch
--- package/hostapd/patches/350-hostap_multicall_fix.patch	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/patches/350-hostap_multicall_fix.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,554 +0,0 @@
---- a/src/drivers/driver_hostap.c
-+++ b/src/drivers/driver_hostap.c
-@@ -22,9 +22,6 @@
- #include "eloop.h"
- #include "driver_hostap.h"
- 
--
--#ifdef HOSTAPD
--
- #include <net/if_arp.h>
- #include <netpacket/packet.h>
- 
-@@ -43,10 +40,16 @@
- static const u8 rfc1042_header[6] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
- 
- struct hostap_driver_data {
-+	void *wext; /* private data for driver_wext */
-+	void *ctx;
-+	char ifname[IFNAMSIZ + 1];
-+	int sock;
-+	int current_mode; /* infra/adhoc */
-+
-+#ifdef HOSTAPD
- 	struct hostapd_data *hapd;
- 
- 	char iface[IFNAMSIZ + 1];
--	int sock; /* raw packet socket for driver access */
- 	int ioctl_sock; /* socket for ioctl() use */
- 	struct netlink_data *netlink;
- 
-@@ -56,9 +59,11 @@ struct hostap_driver_data {
- 	size_t generic_ie_len;
- 	u8 *wps_ie;
- 	size_t wps_ie_len;
-+#endif
- };
- 
- 
-+#ifdef HOSTAPD
- static int hostapd_ioctl(void *priv, struct prism2_hostapd_param *param,
- 			 int len);
- static int hostap_set_iface_flags(void *priv, int dev_up);
-@@ -399,65 +404,6 @@ static int hostapd_ioctl(void *priv, str
- }
- 
- 
--static int wpa_driver_hostap_set_key(const char *ifname, void *priv,
--				     enum wpa_alg alg, const u8 *addr,
--				     int key_idx, int set_tx,
--				     const u8 *seq, size_t seq_len,
--				     const u8 *key, size_t key_len)
--{
--	struct hostap_driver_data *drv = priv;
--	struct prism2_hostapd_param *param;
--	u8 *buf;
--	size_t blen;
--	int ret = 0;
--
--	blen = sizeof(*param) + key_len;
--	buf = os_zalloc(blen);
--	if (buf == NULL)
--		return -1;
--
--	param = (struct prism2_hostapd_param *) buf;
--	param->cmd = PRISM2_SET_ENCRYPTION;
--	if (addr == NULL)
--		memset(param->sta_addr, 0xff, ETH_ALEN);
--	else
--		memcpy(param->sta_addr, addr, ETH_ALEN);
--	switch (alg) {
--	case WPA_ALG_NONE:
--		os_strlcpy((char *) param->u.crypt.alg, "NONE",
--			   HOSTAP_CRYPT_ALG_NAME_LEN);
--		break;
--	case WPA_ALG_WEP:
--		os_strlcpy((char *) param->u.crypt.alg, "WEP",
--			   HOSTAP_CRYPT_ALG_NAME_LEN);
--		break;
--	case WPA_ALG_TKIP:
--		os_strlcpy((char *) param->u.crypt.alg, "TKIP",
--			   HOSTAP_CRYPT_ALG_NAME_LEN);
--		break;
--	case WPA_ALG_CCMP:
--		os_strlcpy((char *) param->u.crypt.alg, "CCMP",
--			   HOSTAP_CRYPT_ALG_NAME_LEN);
--		break;
--	default:
--		os_free(buf);
--		return -1;
--	}
--	param->u.crypt.flags = set_tx ? HOSTAP_CRYPT_FLAG_SET_TX_KEY : 0;
--	param->u.crypt.idx = key_idx;
--	param->u.crypt.key_len = key_len;
--	memcpy((u8 *) (param + 1), key, key_len);
--
--	if (hostapd_ioctl(drv, param, blen)) {
--		printf("Failed to set encryption.\n");
--		ret = -1;
--	}
--	free(buf);
--
--	return ret;
--}
--
--
- static int hostap_get_seqnum(const char *ifname, void *priv, const u8 *addr,
- 			     int idx, u8 *seq)
- {
-@@ -1171,21 +1117,9 @@ static void wpa_driver_hostap_poll_clien
- 	hostap_send_mlme(priv, (u8 *)&hdr, sizeof(hdr));
- }
- 
--#else /* HOSTAPD */
--
--struct wpa_driver_hostap_data {
--	void *wext; /* private data for driver_wext */
--	void *ctx;
--	char ifname[IFNAMSIZ + 1];
--	int sock;
--	int current_mode; /* infra/adhoc */
--};
--
--
--static int wpa_driver_hostap_set_auth_alg(void *priv, int auth_alg);
--
-+#endif /* HOSTAPD */
- 
--static int hostapd_ioctl(struct wpa_driver_hostap_data *drv,
-+static int wpa_hostapd_ioctl(struct hostap_driver_data *drv,
- 			 struct prism2_hostapd_param *param,
- 			 int len, int show_err)
- {
-@@ -1207,7 +1141,12 @@ static int hostapd_ioctl(struct wpa_driv
- }
- 
- 
--static int wpa_driver_hostap_set_wpa_ie(struct wpa_driver_hostap_data *drv,
-+#if !defined(NO_SUPPLICANT)
-+
-+static int wpa_driver_hostap_set_auth_alg(void *priv, int auth_alg);
-+
-+
-+static int wpa_driver_hostap_set_wpa_ie(struct hostap_driver_data *drv,
- 					const u8 *wpa_ie, size_t wpa_ie_len)
- {
- 	struct prism2_hostapd_param *param;
-@@ -1223,7 +1162,7 @@ static int wpa_driver_hostap_set_wpa_ie(
- 	param->cmd = PRISM2_HOSTAPD_SET_GENERIC_ELEMENT;
- 	param->u.generic_elem.len = wpa_ie_len;
- 	os_memcpy(param->u.generic_elem.data, wpa_ie, wpa_ie_len);
--	res = hostapd_ioctl(drv, param, blen, 1);
-+	res = wpa_hostapd_ioctl(drv, param, blen, 1);
- 
- 	os_free(param);
- 
-@@ -1231,7 +1170,7 @@ static int wpa_driver_hostap_set_wpa_ie(
- }
- 
- 
--static int prism2param(struct wpa_driver_hostap_data *drv, int param,
-+static int prism2param(struct hostap_driver_data *drv, int param,
- 		       int value)
- {
- 	struct iwreq iwr;
-@@ -1253,7 +1192,7 @@ static int prism2param(struct wpa_driver
- 
- static int wpa_driver_hostap_set_wpa(void *priv, int enabled)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	int ret = 0;
- 
- 	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
-@@ -1269,125 +1208,15 @@ static int wpa_driver_hostap_set_wpa(voi
- }
- 
- 
--static void show_set_key_error(struct prism2_hostapd_param *param)
--{
--	switch (param->u.crypt.err) {
--	case HOSTAP_CRYPT_ERR_UNKNOWN_ALG:
--		wpa_printf(MSG_INFO, "Unknown algorithm '%s'.",
--			   param->u.crypt.alg);
--		wpa_printf(MSG_INFO, "You may need to load kernel module to "
--			   "register that algorithm.");
--		wpa_printf(MSG_INFO, "E.g., 'modprobe hostap_crypt_wep' for "
--			   "WEP.");
--		break;
--	case HOSTAP_CRYPT_ERR_UNKNOWN_ADDR:
--		wpa_printf(MSG_INFO, "Unknown address " MACSTR ".",
--			   MAC2STR(param->sta_addr));
--		break;
--	case HOSTAP_CRYPT_ERR_CRYPT_INIT_FAILED:
--		wpa_printf(MSG_INFO, "Crypt algorithm initialization failed.");
--		break;
--	case HOSTAP_CRYPT_ERR_KEY_SET_FAILED:
--		wpa_printf(MSG_INFO, "Key setting failed.");
--		break;
--	case HOSTAP_CRYPT_ERR_TX_KEY_SET_FAILED:
--		wpa_printf(MSG_INFO, "TX key index setting failed.");
--		break;
--	case HOSTAP_CRYPT_ERR_CARD_CONF_FAILED:
--		wpa_printf(MSG_INFO, "Card configuration failed.");
--		break;
--	}
--}
--
--
--static int wpa_driver_hostap_set_key(const char *ifname, void *priv,
--				     enum wpa_alg alg, const u8 *addr,
--				     int key_idx, int set_tx,
--				     const u8 *seq, size_t seq_len,
--				     const u8 *key, size_t key_len)
--{
--	struct wpa_driver_hostap_data *drv = priv;
--	struct prism2_hostapd_param *param;
--	u8 *buf;
--	size_t blen;
--	int ret = 0;
--	char *alg_name;
--
--	switch (alg) {
--	case WPA_ALG_NONE:
--		alg_name = "none";
--		break;
--	case WPA_ALG_WEP:
--		alg_name = "WEP";
--		break;
--	case WPA_ALG_TKIP:
--		alg_name = "TKIP";
--		break;
--	case WPA_ALG_CCMP:
--		alg_name = "CCMP";
--		break;
--	default:
--		return -1;
--	}
--
--	wpa_printf(MSG_DEBUG, "%s: alg=%s key_idx=%d set_tx=%d seq_len=%lu "
--		   "key_len=%lu", __FUNCTION__, alg_name, key_idx, set_tx,
--		   (unsigned long) seq_len, (unsigned long) key_len);
--
--	if (seq_len > 8)
--		return -2;
--
--	blen = sizeof(*param) + key_len;
--	buf = os_zalloc(blen);
--	if (buf == NULL)
--		return -1;
--
--	param = (struct prism2_hostapd_param *) buf;
--	param->cmd = PRISM2_SET_ENCRYPTION;
--	/* TODO: In theory, STA in client mode can use five keys; four default
--	 * keys for receiving (with keyidx 0..3) and one individual key for
--	 * both transmitting and receiving (keyidx 0) _unicast_ packets. Now,
--	 * keyidx 0 is reserved for this unicast use and default keys can only
--	 * use keyidx 1..3 (i.e., default key with keyidx 0 is not supported).
--	 * This should be fine for more or less all cases, but for completeness
--	 * sake, the driver could be enhanced to support the missing key. */
--#if 0
--	if (addr == NULL)
--		os_memset(param->sta_addr, 0xff, ETH_ALEN);
--	else
--		os_memcpy(param->sta_addr, addr, ETH_ALEN);
--#else
--	os_memset(param->sta_addr, 0xff, ETH_ALEN);
--#endif
--	os_strlcpy((char *) param->u.crypt.alg, alg_name,
--		   HOSTAP_CRYPT_ALG_NAME_LEN);
--	param->u.crypt.flags = set_tx ? HOSTAP_CRYPT_FLAG_SET_TX_KEY : 0;
--	param->u.crypt.idx = key_idx;
--	if (seq)
--		os_memcpy(param->u.crypt.seq, seq, seq_len);
--	param->u.crypt.key_len = key_len;
--	os_memcpy((u8 *) (param + 1), key, key_len);
--
--	if (hostapd_ioctl(drv, param, blen, 1)) {
--		wpa_printf(MSG_WARNING, "Failed to set encryption.");
--		show_set_key_error(param);
--		ret = -1;
--	}
--	os_free(buf);
--
--	return ret;
--}
--
--
- static int wpa_driver_hostap_set_countermeasures(void *priv, int enabled)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	wpa_printf(MSG_DEBUG, "%s: enabled=%d", __FUNCTION__, enabled);
- 	return prism2param(drv, PRISM2_PARAM_TKIP_COUNTERMEASURES, enabled);
- }
- 
- 
--static int wpa_driver_hostap_reset(struct wpa_driver_hostap_data *drv,
-+static int wpa_driver_hostap_reset(struct hostap_driver_data *drv,
- 				   int type)
- {
- 	struct iwreq iwr;
-@@ -1408,7 +1237,7 @@ static int wpa_driver_hostap_reset(struc
- }
- 
- 
--static int wpa_driver_hostap_mlme(struct wpa_driver_hostap_data *drv,
-+static int wpa_driver_hostap_mlme(struct hostap_driver_data *drv,
- 				  const u8 *addr, int cmd, int reason_code)
- {
- 	struct prism2_hostapd_param param;
-@@ -1423,7 +1252,7 @@ static int wpa_driver_hostap_mlme(struct
- 	os_memcpy(param.sta_addr, addr, ETH_ALEN);
- 	param.u.mlme.cmd = cmd;
- 	param.u.mlme.reason_code = reason_code;
--	ret = hostapd_ioctl(drv, &param, sizeof(param), 1);
-+	ret = wpa_hostapd_ioctl(drv, &param, sizeof(param), 1);
- 	if (ret == 0) {
- 		os_sleep(0, 100000);
- 		ret = wpa_driver_hostap_reset(drv, 2);
-@@ -1435,7 +1264,7 @@ static int wpa_driver_hostap_mlme(struct
- static int wpa_driver_hostap_deauthenticate(void *priv, const u8 *addr,
- 					    int reason_code)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
- 	return wpa_driver_hostap_mlme(drv, addr, MLME_STA_DEAUTH,
- 				      reason_code);
-@@ -1445,7 +1274,7 @@ static int wpa_driver_hostap_deauthentic
- static int wpa_driver_hostap_disassociate(void *priv, const u8 *addr,
- 					  int reason_code)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	wpa_printf(MSG_DEBUG, "%s", __FUNCTION__);
- 	return wpa_driver_hostap_mlme(drv, addr, MLME_STA_DISASSOC,
- 				      reason_code);
-@@ -1456,7 +1285,7 @@ static int
- wpa_driver_hostap_associate(void *priv,
- 			    struct wpa_driver_associate_params *params)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	int ret = 0;
- 	int allow_unencrypted_eapol;
- 
-@@ -1520,7 +1349,7 @@ wpa_driver_hostap_associate(void *priv,
- static int wpa_driver_hostap_scan(void *priv,
- 				  struct wpa_driver_scan_params *params)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	struct prism2_hostapd_param param;
- 	int ret;
- 	const u8 *ssid = params->ssids[0].ssid;
-@@ -1541,7 +1370,7 @@ static int wpa_driver_hostap_scan(void *
- 	param.cmd = PRISM2_HOSTAPD_SCAN_REQ;
- 	param.u.scan_req.ssid_len = ssid_len;
- 	os_memcpy(param.u.scan_req.ssid, ssid, ssid_len);
--	ret = hostapd_ioctl(drv, &param, sizeof(param), 1);
-+	ret = wpa_hostapd_ioctl(drv, &param, sizeof(param), 1);
- 
- 	/* Not all drivers generate "scan completed" wireless event, so try to
- 	 * read results after a timeout. */
-@@ -1556,7 +1385,7 @@ static int wpa_driver_hostap_scan(void *
- 
- static int wpa_driver_hostap_set_auth_alg(void *priv, int auth_alg)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	int algs = 0;
- 
- 	if (auth_alg & WPA_AUTH_ALG_OPEN)
-@@ -1574,35 +1403,35 @@ static int wpa_driver_hostap_set_auth_al
- 
- static int wpa_driver_hostap_get_bssid(void *priv, u8 *bssid)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	return wpa_driver_wext_get_bssid(drv->wext, bssid);
- }
- 
- 
- static int wpa_driver_hostap_get_ssid(void *priv, u8 *ssid)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	return wpa_driver_wext_get_ssid(drv->wext, ssid);
- }
- 
- 
- static struct wpa_scan_results * wpa_driver_hostap_get_scan_results(void *priv)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	return wpa_driver_wext_get_scan_results(drv->wext);
- }
- 
- 
- static int wpa_driver_hostap_set_operstate(void *priv, int state)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	return wpa_driver_wext_set_operstate(drv->wext, state);
- }
- 
- 
- static void * wpa_driver_hostap_init(void *ctx, const char *ifname)
- {
--	struct wpa_driver_hostap_data *drv;
-+	struct hostap_driver_data *drv;
- 
- 	drv = os_zalloc(sizeof(*drv));
- 	if (drv == NULL)
-@@ -1642,14 +1471,120 @@ static void * wpa_driver_hostap_init(voi
- 
- static void wpa_driver_hostap_deinit(void *priv)
- {
--	struct wpa_driver_hostap_data *drv = priv;
-+	struct hostap_driver_data *drv = priv;
- 	wpa_driver_hostap_set_wpa(drv, 0);
- 	wpa_driver_wext_deinit(drv->wext);
- 	close(drv->sock);
- 	os_free(drv);
- }
- 
--#endif /* HOSTAPD */
-+#endif
-+
-+
-+static void show_set_key_error(struct prism2_hostapd_param *param)
-+{
-+	switch (param->u.crypt.err) {
-+	case HOSTAP_CRYPT_ERR_UNKNOWN_ALG:
-+		wpa_printf(MSG_INFO, "Unknown algorithm '%s'.",
-+			   param->u.crypt.alg);
-+		wpa_printf(MSG_INFO, "You may need to load kernel module to "
-+			   "register that algorithm.");
-+		wpa_printf(MSG_INFO, "E.g., 'modprobe hostap_crypt_wep' for "
-+			   "WEP.");
-+		break;
-+	case HOSTAP_CRYPT_ERR_UNKNOWN_ADDR:
-+		wpa_printf(MSG_INFO, "Unknown address " MACSTR ".",
-+			   MAC2STR(param->sta_addr));
-+		break;
-+	case HOSTAP_CRYPT_ERR_CRYPT_INIT_FAILED:
-+		wpa_printf(MSG_INFO, "Crypt algorithm initialization failed.");
-+		break;
-+	case HOSTAP_CRYPT_ERR_KEY_SET_FAILED:
-+		wpa_printf(MSG_INFO, "Key setting failed.");
-+		break;
-+	case HOSTAP_CRYPT_ERR_TX_KEY_SET_FAILED:
-+		wpa_printf(MSG_INFO, "TX key index setting failed.");
-+		break;
-+	case HOSTAP_CRYPT_ERR_CARD_CONF_FAILED:
-+		wpa_printf(MSG_INFO, "Card configuration failed.");
-+		break;
-+	}
-+}
-+
-+
-+static int wpa_driver_hostap_set_key(const char *ifname, void *priv,
-+				     enum wpa_alg alg, const u8 *addr,
-+				     int key_idx, int set_tx,
-+				     const u8 *seq, size_t seq_len,
-+				     const u8 *key, size_t key_len)
-+{
-+	struct hostap_driver_data *drv = priv;
-+	struct prism2_hostapd_param *param;
-+	u8 *buf;
-+	size_t blen;
-+	int ret = 0;
-+	char *alg_name;
-+
-+	switch (alg) {
-+	case WPA_ALG_NONE:
-+		alg_name = "none";
-+		break;
-+	case WPA_ALG_WEP:
-+		alg_name = "WEP";
-+		break;
-+	case WPA_ALG_TKIP:
-+		alg_name = "TKIP";
-+		break;
-+	case WPA_ALG_CCMP:
-+		alg_name = "CCMP";
-+		break;
-+	default:
-+		return -1;
-+	}
-+
-+	wpa_printf(MSG_DEBUG, "%s: alg=%s key_idx=%d set_tx=%d seq_len=%lu "
-+		   "key_len=%lu", __FUNCTION__, alg_name, key_idx, set_tx,
-+		   (unsigned long) seq_len, (unsigned long) key_len);
-+
-+	if (seq_len > 8)
-+		return -2;
-+
-+	blen = sizeof(*param) + key_len;
-+	buf = os_zalloc(blen);
-+	if (buf == NULL)
-+		return -1;
-+
-+	param = (struct prism2_hostapd_param *) buf;
-+	param->cmd = PRISM2_SET_ENCRYPTION;
-+	/* TODO: In theory, STA in client mode can use five keys; four default
-+	 * keys for receiving (with keyidx 0..3) and one individual key for
-+	 * both transmitting and receiving (keyidx 0) _unicast_ packets. Now,
-+	 * keyidx 0 is reserved for this unicast use and default keys can only
-+	 * use keyidx 1..3 (i.e., default key with keyidx 0 is not supported).
-+	 * This should be fine for more or less all cases, but for completeness
-+	 * sake, the driver could be enhanced to support the missing key. */
-+	if (addr == NULL)
-+		os_memset(param->sta_addr, 0xff, ETH_ALEN);
-+	else
-+		os_memcpy(param->sta_addr, addr, ETH_ALEN);
-+	os_strlcpy((char *) param->u.crypt.alg, alg_name,
-+		   HOSTAP_CRYPT_ALG_NAME_LEN);
-+	param->u.crypt.flags = set_tx ? HOSTAP_CRYPT_FLAG_SET_TX_KEY : 0;
-+	param->u.crypt.idx = key_idx;
-+	if (seq)
-+		os_memcpy(param->u.crypt.seq, seq, seq_len);
-+	param->u.crypt.key_len = key_len;
-+	os_memcpy((u8 *) (param + 1), key, key_len);
-+
-+	if (wpa_hostapd_ioctl(drv, param, blen, 1)) {
-+		wpa_printf(MSG_WARNING, "Failed to set encryption.");
-+		show_set_key_error(param);
-+		ret = -1;
-+	}
-+	os_free(buf);
-+
-+	return ret;
-+}
- 
- 
- const struct wpa_driver_ops wpa_driver_hostap_ops = {
-@@ -1679,7 +1614,8 @@ const struct wpa_driver_ops wpa_driver_h
- 	.set_ap_wps_ie = hostap_set_ap_wps_ie,
- 	.set_freq = hostap_set_freq,
- 	.poll_client = wpa_driver_hostap_poll_client,
--#else /* HOSTAPD */
-+#endif /* HOSTAPD */
-+#if !defined(NO_SUPPLICANT)
- 	.get_bssid = wpa_driver_hostap_get_bssid,
- 	.get_ssid = wpa_driver_hostap_get_ssid,
- 	.set_countermeasures = wpa_driver_hostap_set_countermeasures,
-@@ -1691,5 +1627,5 @@ const struct wpa_driver_ops wpa_driver_h
- 	.init = wpa_driver_hostap_init,
- 	.deinit = wpa_driver_hostap_deinit,
- 	.set_operstate = wpa_driver_hostap_set_operstate,
--#endif /* HOSTAPD */
-+#endif
- };
diff --exclude .svn -Nru package/hostapd/patches/360-fix_ctrl_iface.patch package/hostapd/patches/360-fix_ctrl_iface.patch
--- package/hostapd/patches/360-fix_ctrl_iface.patch	2012-08-17 15:40:41.381971000 +0200
+++ package/hostapd/patches/360-fix_ctrl_iface.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
---- a/wpa_supplicant/ctrl_iface.c
-+++ b/wpa_supplicant/ctrl_iface.c
-@@ -685,6 +685,7 @@ static int wpa_supplicant_ctrl_iface_ibs
- #endif /* CONFIG_IBSS_RSN */
- 
- 
-+#ifdef IEEE8021X_EAPOL
- int wpa_supplicant_ctrl_iface_ctrl_rsp_handle(struct wpa_supplicant *wpa_s,
- 					      struct wpa_ssid *ssid,
- 					      const char *field,
-@@ -750,6 +751,7 @@ int wpa_supplicant_ctrl_iface_ctrl_rsp_h
- 
- 	return 0;
- }
-+#endif
- 
- 
- static int wpa_supplicant_ctrl_iface_ctrl_rsp(struct wpa_supplicant *wpa_s,
diff --exclude .svn -Nru package/hostapd/patches/400-noscan.patch package/hostapd/patches/400-noscan.patch
--- package/hostapd/patches/400-noscan.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/400-noscan.patch	2012-09-30 10:13:29.620734001 +0200
@@ -0,0 +1,32 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -2485,6 +2485,8 @@ static int hostapd_config_fill(struct ho
+ 			}
+ #endif /* CONFIG_IEEE80211W */
+ #ifdef CONFIG_IEEE80211N
++		} else if (os_strcmp(buf, "noscan") == 0) {
++			conf->noscan = atoi(pos);
+ 		} else if (os_strcmp(buf, "ieee80211n") == 0) {
+ 			conf->ieee80211n = atoi(pos);
+ 		} else if (os_strcmp(buf, "ht_capab") == 0) {
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -497,6 +497,7 @@ struct hostapd_config {
+ 
+ 	int ht_op_mode_fixed;
+ 	u16 ht_capab;
++	int noscan;
+ 	int ieee80211n;
+ 	int secondary_channel;
+ 	int require_ht;
+--- a/src/ap/hw_features.c
++++ b/src/ap/hw_features.c
+@@ -493,7 +493,7 @@ static int ieee80211n_check_40mhz(struct
+ {
+ 	struct wpa_driver_scan_params params;
+ 
+-	if (!iface->conf->secondary_channel)
++	if (!iface->conf->secondary_channel || iface->conf->noscan)
+ 		return 0; /* HT40 not used */
+ 
+ 	wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes prior to enabling "
diff --exclude .svn -Nru package/hostapd/patches/410-multicall.patch package/hostapd/patches/410-multicall.patch
--- package/hostapd/patches/410-multicall.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/410-multicall.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,246 @@
+--- a/hostapd/Makefile
++++ b/hostapd/Makefile
+@@ -14,6 +14,7 @@ CFLAGS += -I../src/utils
+ # CFLAGS += -DUSE_KERNEL_HEADERS -I/usr/src/linux/include
+ 
+ -include .config
++-include $(if $(MULTICALL), ../wpa_supplicant/.config)
+ 
+ ifndef CONFIG_OS
+ ifdef CONFIG_NATIVE_WINDOWS
+@@ -188,10 +189,14 @@ ifdef CONFIG_IEEE80211AC
+ CFLAGS += -DCONFIG_IEEE80211AC
+ endif
+ 
++ifndef MULTICALL
++CFLAGS += -DNO_SUPPLICANT
++endif
++
+ include ../src/drivers/drivers.mak
+-OBJS += $(DRV_AP_OBJS)
+-CFLAGS += $(DRV_AP_CFLAGS)
+-LDFLAGS += $(DRV_AP_LDFLAGS)
++OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
++CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
++LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
+ LIBS += $(DRV_AP_LIBS)
+ 
+ ifdef CONFIG_L2_PACKET
+@@ -867,6 +872,12 @@ install: all
+ 
+ BCHECK=../src/drivers/build.hostapd
+ 
++hostapd_multi.a: $(BCHECK) $(OBJS)
++	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
++	@$(E) "  CC " $<
++	@rm -f $@
++	@$(AR) cr $@ hostapd_multi.o $(OBJS)
++
+ hostapd: $(BCHECK) $(OBJS)
+ 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
+ 	@$(E) "  LD " $@
+@@ -905,6 +916,12 @@ HOBJS += ../src/crypto/aes-internal.o
+ HOBJS += ../src/crypto/aes-internal-enc.o
+ endif
+ 
++dump_cflags:
++	@echo -n $(CFLAGS) " "
++
++dump_ldflags:
++	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
++
+ nt_password_hash: $(NOBJS)
+ 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
+ 	@$(E) "  LD " $@
+--- a/wpa_supplicant/Makefile
++++ b/wpa_supplicant/Makefile
+@@ -14,6 +14,7 @@ CFLAGS += -I../src
+ CFLAGS += -I../src/utils
+ 
+ -include .config
++-include $(if $(MULTICALL),../hostapd/.config)
+ 
+ BINALL=wpa_supplicant wpa_cli
+ 
+@@ -705,6 +706,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
+ CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
+ LIBS += -ldl -rdynamic
+ endif
++else
++  ifdef MULTICALL
++    OBJS += ../src/eap_common/eap_common.o
++  endif
+ endif
+ 
+ ifdef CONFIG_AP
+@@ -713,9 +718,11 @@ NEED_EAP_COMMON=y
+ NEED_RSN_AUTHENTICATOR=y
+ CFLAGS += -DCONFIG_AP
+ OBJS += ap.o
++ifndef MULTICALL
+ CFLAGS += -DCONFIG_NO_RADIUS
+ CFLAGS += -DCONFIG_NO_ACCOUNTING
+ CFLAGS += -DCONFIG_NO_VLAN
++endif
+ OBJS += ../src/ap/hostapd.o
+ OBJS += ../src/ap/wpa_auth_glue.o
+ OBJS += ../src/ap/utils.o
+@@ -770,10 +777,18 @@ endif
+ ifdef CONFIG_HS20
+ OBJS += ../src/ap/hs20.o
+ endif
++else
++  ifdef MULTICALL
++    OBJS += ../src/eap_server/eap_server.o
++    OBJS += ../src/eap_server/eap_server_identity.o
++    OBJS += ../src/eap_server/eap_server_methods.o
++  endif
+ endif
+ 
+ ifdef NEED_RSN_AUTHENTICATOR
++ifndef MULTICALL
+ CFLAGS += -DCONFIG_NO_RADIUS
++endif
+ NEED_AES_WRAP=y
+ OBJS += ../src/ap/wpa_auth.o
+ OBJS += ../src/ap/wpa_auth_ie.o
+@@ -1515,6 +1530,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
+ 
+ $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
+ 
++wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
++	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
++	@$(E) "  CC " $<
++	@rm -f $@
++	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
++
+ wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
+ 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
+ 	@$(E) "  LD " $@
+@@ -1585,6 +1606,12 @@ eap_ikev2.so: ../src/eap_peer/eap_ikev2.
+ %@.service: %.service.arg.in
+ 	sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
+ 
++dump_cflags:
++	@echo -n $(CFLAGS) " "
++
++dump_ldflags:
++	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
++
+ wpa_supplicant.exe: wpa_supplicant
+ 	mv -f $< $@
+ wpa_cli.exe: wpa_cli
+--- a/src/drivers/driver.h
++++ b/src/drivers/driver.h
+@@ -3686,8 +3686,8 @@ union wpa_event_data {
+  * Driver wrapper code should call this function whenever an event is received
+  * from the driver.
+  */
+-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
+-			  union wpa_event_data *data);
++extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
++				    union wpa_event_data *data);
+ 
+ 
+ /*
+--- a/src/ap/drv_callbacks.c
++++ b/src/ap/drv_callbacks.c
+@@ -685,8 +685,8 @@ static void hostapd_event_eapol_rx(struc
+ }
+ 
+ 
+-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
+-			  union wpa_event_data *data)
++void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
++		       union wpa_event_data *data)
+ {
+ 	struct hostapd_data *hapd = ctx;
+ #ifndef CONFIG_NO_STDOUT_DEBUG
+--- a/wpa_supplicant/wpa_priv.c
++++ b/wpa_supplicant/wpa_priv.c
+@@ -819,8 +819,8 @@ static void wpa_priv_send_ft_response(st
+ }
+ 
+ 
+-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
+-			  union wpa_event_data *data)
++static void supplicant_event(void *ctx, enum wpa_event_type event,
++			     union wpa_event_data *data)
+ {
+ 	struct wpa_priv_interface *iface = ctx;
+ 
+@@ -962,6 +962,7 @@ int main(int argc, char *argv[])
+ 	if (os_program_init())
+ 		return -1;
+ 
++	wpa_supplicant_event = supplicant_event;
+ 	wpa_priv_fd_workaround();
+ 
+ 	for (;;) {
+--- a/wpa_supplicant/events.c
++++ b/wpa_supplicant/events.c
+@@ -2258,8 +2258,8 @@ static void wnm_action_rx(struct wpa_sup
+ }
+ 
+ 
+-void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
+-			  union wpa_event_data *data)
++void supplicant_event(void *ctx, enum wpa_event_type event,
++		      union wpa_event_data *data)
+ {
+ 	struct wpa_supplicant *wpa_s = ctx;
+ 	u16 reason_code = 0;
+--- a/wpa_supplicant/wpa_supplicant.c
++++ b/wpa_supplicant/wpa_supplicant.c
+@@ -2921,6 +2921,9 @@ static void wpa_supplicant_deinit_iface(
+ 	}
+ }
+ 
++extern void supplicant_event(void *ctx, enum wpa_event_type event,
++			     union wpa_event_data *data);
++
+ 
+ /**
+  * wpa_supplicant_add_iface - Add a new network interface
+@@ -3113,6 +3116,7 @@ struct wpa_global * wpa_supplicant_init(
+ 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
+ #endif /* CONFIG_NO_WPA_MSG */
+ 
++	wpa_supplicant_event = supplicant_event;
+ 	wpa_debug_open_file(params->wpa_debug_file_path);
+ 	if (params->wpa_debug_syslog)
+ 		wpa_debug_open_syslog();
+--- a/hostapd/main.c
++++ b/hostapd/main.c
+@@ -530,6 +530,9 @@ static int hostapd_get_global_ctrl_iface
+ 	return 0;
+ }
+ 
++void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
++                       union wpa_event_data *data);
++
+ 
+ int main(int argc, char *argv[])
+ {
+@@ -555,6 +558,7 @@ int main(int argc, char *argv[])
+ 	interfaces.global_iface_name = NULL;
+ 	interfaces.global_ctrl_sock = -1;
+ 
++	wpa_supplicant_event = hostapd_wpa_event;
+ 	for (;;) {
+ 		c = getopt(argc, argv, "Bde:f:hKP:tvg:");
+ 		if (c < 0)
+--- a/src/drivers/drivers.c
++++ b/src/drivers/drivers.c
+@@ -7,7 +7,11 @@
+  */
+ 
+ #include "includes.h"
++#include "common.h"
++#include "driver.h"
+ 
++void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
++			     union wpa_event_data *data);
+ 
+ #ifdef CONFIG_DRIVER_WEXT
+ extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
diff --exclude .svn -Nru package/hostapd/patches/420-timestamp_check.patch package/hostapd/patches/420-timestamp_check.patch
--- package/hostapd/patches/420-timestamp_check.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/420-timestamp_check.patch	2012-08-18 14:47:30.615458002 +0200
@@ -0,0 +1,12 @@
+--- a/src/tls/x509v3.c
++++ b/src/tls/x509v3.c
+@@ -1848,6 +1848,9 @@ int x509_certificate_chain_validate(stru
+ 		if (chain_trusted)
+ 			continue;
+ 
++#ifdef NO_TIMESTAMP_CHECK
++		disable_time_checks = 1;
++#endif
+ 		if (!disable_time_checks &&
+ 		    ((unsigned long) now.sec <
+ 		     (unsigned long) cert->not_before ||
diff --exclude .svn -Nru package/hostapd/patches/430-rescan_immediately.patch package/hostapd/patches/430-rescan_immediately.patch
--- package/hostapd/patches/430-rescan_immediately.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/430-rescan_immediately.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,11 @@
+--- a/wpa_supplicant/wpa_supplicant.c
++++ b/wpa_supplicant/wpa_supplicant.c
+@@ -2388,7 +2388,7 @@ static struct wpa_supplicant * wpa_suppl
+ 	if (wpa_s == NULL)
+ 		return NULL;
+ 	wpa_s->scan_req = 1;
+-	wpa_s->scan_interval = 5;
++	wpa_s->scan_interval = 1;
+ 	wpa_s->new_connection = 1;
+ 	wpa_s->parent = wpa_s;
+ 	wpa_s->sched_scanning = 0;
diff --exclude .svn -Nru package/hostapd/patches/440-optional_rfkill.patch package/hostapd/patches/440-optional_rfkill.patch
--- package/hostapd/patches/440-optional_rfkill.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/440-optional_rfkill.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,261 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -218,7 +218,9 @@ struct wpa_driver_nl80211_data {
+ 	int if_removed;
+ 	int if_disabled;
+ 	int ignore_if_down_event;
++#ifdef CONFIG_RFKILL
+ 	struct rfkill_data *rfkill;
++#endif
+ 	struct wpa_driver_capa capa;
+ 	int has_capability;
+ 
+@@ -2828,7 +2830,7 @@ static int wpa_driver_nl80211_init_nl(st
+ 	return 0;
+ }
+ 
+-
++#ifdef CONFIG_RFKILL
+ static void wpa_driver_nl80211_rfkill_blocked(void *ctx)
+ {
+ 	wpa_printf(MSG_DEBUG, "nl80211: RFKILL blocked");
+@@ -2851,6 +2853,7 @@ static void wpa_driver_nl80211_rfkill_un
+ 	}
+ 	/* rtnetlink ifup handler will report interface as enabled */
+ }
++#endif /* CONFIG_RFKILL */
+ 
+ 
+ static void nl80211_get_phy_name(struct wpa_driver_nl80211_data *drv)
+@@ -2979,7 +2982,9 @@ static void * wpa_driver_nl80211_init(vo
+ 				      void *global_priv)
+ {
+ 	struct wpa_driver_nl80211_data *drv;
++#ifdef CONFIG_RFKILL
+ 	struct rfkill_config *rcfg;
++#endif
+ 	struct i802_bss *bss;
+ 
+ 	if (global_priv == NULL)
+@@ -3013,6 +3018,7 @@ static void * wpa_driver_nl80211_init(vo
+ 
+ 	nl80211_get_phy_name(drv);
+ 
++#ifdef CONFIG_RFKILL
+ 	rcfg = os_zalloc(sizeof(*rcfg));
+ 	if (rcfg == NULL)
+ 		goto failed;
+@@ -3025,6 +3031,7 @@ static void * wpa_driver_nl80211_init(vo
+ 		wpa_printf(MSG_DEBUG, "nl80211: RFKILL status not available");
+ 		os_free(rcfg);
+ 	}
++#endif /* CONFIG_RFKILL */
+ 
+ 	if (wpa_driver_nl80211_finish_drv_init(drv))
+ 		goto failed;
+@@ -3311,10 +3318,12 @@ static void nl80211_mgmt_unsubscribe(str
+ }
+ 
+ 
++#ifdef CONFIG_RFKILL
+ static void wpa_driver_nl80211_send_rfkill(void *eloop_ctx, void *timeout_ctx)
+ {
+ 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
+ }
++#endif /* CONFIG_RFKILL */
+ 
+ static int
+ wpa_driver_nl80211_finish_drv_init_sta(struct wpa_driver_nl80211_data *drv,
+@@ -3335,13 +3344,16 @@ wpa_driver_nl80211_finish_drv_init_sta(s
+ 	}
+ 
+ 	if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
++#ifdef CONFIG_RFKILL
+ 		if (rfkill_is_blocked(drv->rfkill)) {
+ 			wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
+ 				   "interface '%s' due to rfkill",
+ 				   bss->ifname);
+ 			drv->if_disabled = 1;
+ 			*send_rfkill_event = 1;
+-		} else {
++		} else
++#endif
++		{
+ 			wpa_printf(MSG_ERROR, "nl80211: Could not set "
+ 				   "interface '%s' UP", bss->ifname);
+ 			return -1;
+@@ -3372,8 +3384,10 @@ wpa_driver_nl80211_finish_drv_init(struc
+ 		return -1;
+ 
+ 	if (send_rfkill_event) {
++#ifdef CONFIG_RFKILL
+ 		eloop_register_timeout(0, 0, wpa_driver_nl80211_send_rfkill,
+ 				       drv, drv->ctx);
++#endif
+ 	}
+ 
+ 	return 0;
+@@ -3460,7 +3474,9 @@ static void wpa_driver_nl80211_deinit(vo
+ 
+ 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, 0,
+ 			       IF_OPER_UP);
++#ifdef CONFIG_RFKILL
+ 	rfkill_deinit(drv->rfkill);
++#endif
+ 
+ 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
+ 
+--- a/src/drivers/driver_wext.c
++++ b/src/drivers/driver_wext.c
+@@ -742,7 +742,7 @@ static void wpa_driver_wext_event_rtm_de
+ 	}
+ }
+ 
+-
++#ifdef CONFIG_RFKILL
+ static void wpa_driver_wext_rfkill_blocked(void *ctx)
+ {
+ 	wpa_printf(MSG_DEBUG, "WEXT: RFKILL blocked");
+@@ -764,7 +764,7 @@ static void wpa_driver_wext_rfkill_unblo
+ 	}
+ 	/* rtnetlink ifup handler will report interface as enabled */
+ }
+-
++#endif /* CONFIG_RFKILL */
+ 
+ static void wext_get_phy_name(struct wpa_driver_wext_data *drv)
+ {
+@@ -810,7 +810,9 @@ void * wpa_driver_wext_init(void *ctx, c
+ {
+ 	struct wpa_driver_wext_data *drv;
+ 	struct netlink_config *cfg;
++#ifdef CONFIG_RFKILL
+ 	struct rfkill_config *rcfg;
++#endif
+ 	char path[128];
+ 	struct stat buf;
+ 
+@@ -845,6 +847,7 @@ void * wpa_driver_wext_init(void *ctx, c
+ 		goto err2;
+ 	}
+ 
++#ifdef CONFIG_RFKILL
+ 	rcfg = os_zalloc(sizeof(*rcfg));
+ 	if (rcfg == NULL)
+ 		goto err3;
+@@ -857,6 +860,7 @@ void * wpa_driver_wext_init(void *ctx, c
+ 		wpa_printf(MSG_DEBUG, "WEXT: RFKILL status not available");
+ 		os_free(rcfg);
+ 	}
++#endif /* CONFIG_RFKILL */
+ 
+ 	drv->mlme_sock = -1;
+ 
+@@ -874,7 +878,9 @@ void * wpa_driver_wext_init(void *ctx, c
+ 	return drv;
+ 
+ err3:
++#ifdef CONFIG_RFKILL
+ 	rfkill_deinit(drv->rfkill);
++#endif
+ 	netlink_deinit(drv->netlink);
+ err2:
+ 	close(drv->ioctl_sock);
+@@ -884,10 +890,12 @@ err1:
+ }
+ 
+ 
++#ifdef CONFIG_RFKILL
+ static void wpa_driver_wext_send_rfkill(void *eloop_ctx, void *timeout_ctx)
+ {
+ 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
+ }
++#endif /* CONFIG_RFKILL */
+ 
+ 
+ static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
+@@ -895,13 +903,16 @@ static int wpa_driver_wext_finish_drv_in
+ 	int send_rfkill_event = 0;
+ 
+ 	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
++#ifdef CONFIG_RFKILL
+ 		if (rfkill_is_blocked(drv->rfkill)) {
+ 			wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
+ 				   "interface '%s' due to rfkill",
+ 				   drv->ifname);
+ 			drv->if_disabled = 1;
+ 			send_rfkill_event = 1;
+-		} else {
++		} else
++#endif
++		{
+ 			wpa_printf(MSG_ERROR, "WEXT: Could not set "
+ 				   "interface '%s' UP", drv->ifname);
+ 			return -1;
+@@ -949,8 +960,10 @@ static int wpa_driver_wext_finish_drv_in
+ 			       1, IF_OPER_DORMANT);
+ 
+ 	if (send_rfkill_event) {
++#ifdef CONFIG_RFKILL
+ 		eloop_register_timeout(0, 0, wpa_driver_wext_send_rfkill,
+ 				       drv, drv->ctx);
++#endif
+ 	}
+ 
+ 	return 0;
+@@ -980,7 +993,9 @@ void wpa_driver_wext_deinit(void *priv)
+ 
+ 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
+ 	netlink_deinit(drv->netlink);
++#ifdef CONFIG_RFKILL
+ 	rfkill_deinit(drv->rfkill);
++#endif
+ 
+ 	if (drv->mlme_sock >= 0)
+ 		eloop_unregister_read_sock(drv->mlme_sock);
+--- a/src/drivers/drivers.mak
++++ b/src/drivers/drivers.mak
+@@ -25,7 +25,6 @@ NEED_SME=y
+ NEED_AP_MLME=y
+ NEED_NETLINK=y
+ NEED_LINUX_IOCTL=y
+-NEED_RFKILL=y
+ 
+ ifdef CONFIG_LIBNL32
+   DRV_LIBS += -lnl-3
+@@ -101,7 +100,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
+ CONFIG_WIRELESS_EXTENSION=y
+ NEED_NETLINK=y
+ NEED_LINUX_IOCTL=y
+-NEED_RFKILL=y
+ endif
+ 
+ ifdef CONFIG_DRIVER_NDIS
+@@ -127,7 +125,6 @@ endif
+ ifdef CONFIG_WIRELESS_EXTENSION
+ DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
+ DRV_WPA_OBJS += ../src/drivers/driver_wext.o
+-NEED_RFKILL=y
+ endif
+ 
+ ifdef NEED_NETLINK
+@@ -140,6 +137,7 @@ endif
+ 
+ ifdef NEED_RFKILL
+ DRV_OBJS += ../src/drivers/rfkill.o
++DRV_WPA_CFLAGS += -DCONFIG_RFKILL
+ endif
+ 
+ ifdef CONFIG_VLAN_NETLINK
+--- a/src/drivers/driver_wext.h
++++ b/src/drivers/driver_wext.h
+@@ -22,7 +22,9 @@ struct wpa_driver_wext_data {
+ 	int ifindex2;
+ 	int if_removed;
+ 	int if_disabled;
++#ifdef CONFIG_RFKILL
+ 	struct rfkill_data *rfkill;
++#endif
+ 	u8 *assoc_req_ies;
+ 	size_t assoc_req_ies_len;
+ 	u8 *assoc_resp_ies;
diff --exclude .svn -Nru package/hostapd/patches/450-reload_freq_change.patch package/hostapd/patches/450-reload_freq_change.patch
--- package/hostapd/patches/450-reload_freq_change.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/450-reload_freq_change.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,23 @@
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -140,6 +140,20 @@ int hostapd_reload_config(struct hostapd
+ 	oldconf = hapd->iconf;
+ 	iface->conf = newconf;
+ 
++	hostapd_select_hw_mode(iface);
++	iface->freq = hostapd_hw_get_freq(hapd, newconf->channel);
++
++	if (hostapd_set_freq(hapd, newconf->hw_mode, iface->freq,
++			     newconf->channel,
++			     newconf->ieee80211n,
++			     newconf->secondary_channel)) {
++		wpa_printf(MSG_ERROR, "Could not set channel for "
++			   "kernel driver");
++	}
++
++	if (iface->current_mode)
++		hostapd_prepare_rates(iface, iface->current_mode);
++
+ 	for (j = 0; j < iface->num_bss; j++) {
+ 		hapd = iface->bss[j];
+ 		hapd->iconf = newconf;
diff --exclude .svn -Nru package/hostapd/patches/451-nl80211_del_beacon_bss.patch package/hostapd/patches/451-nl80211_del_beacon_bss.patch
--- package/hostapd/patches/451-nl80211_del_beacon_bss.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/451-nl80211_del_beacon_bss.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,63 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -3394,16 +3394,18 @@ wpa_driver_nl80211_finish_drv_init(struc
+ }
+ 
+ 
+-static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
++static int wpa_driver_nl80211_del_bss_beacon(struct i802_bss *bss)
+ {
++	struct wpa_driver_nl80211_data *drv = bss->drv;
+ 	struct nl_msg *msg;
+ 
++	bss->beacon_set = 0;
+ 	msg = nlmsg_alloc();
+ 	if (!msg)
+ 		return -ENOMEM;
+ 
+ 	nl80211_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
+-	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
++	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
+ 
+ 	return send_and_recv_msgs(drv, msg, NULL, NULL);
+  nla_put_failure:
+@@ -3411,6 +3413,21 @@ static int wpa_driver_nl80211_del_beacon
+ 	return -ENOBUFS;
+ }
+ 
++static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
++{
++	struct i802_bss *bss;
++
++	for (bss = &drv->first_bss; bss; bss = bss->next)
++		wpa_driver_nl80211_del_bss_beacon(bss);
++
++	return 0;
++}
++
++static int wpa_driver_nl80211_stop_ap(void *priv)
++{
++	struct i802_bss *bss = priv;
++	return wpa_driver_nl80211_del_beacon(bss->drv);
++}
+ 
+ /**
+  * wpa_driver_nl80211_deinit - Deinitialize nl80211 driver interface
+@@ -9238,4 +9255,5 @@ const struct wpa_driver_ops wpa_driver_n
+ 	.send_tdls_mgmt = nl80211_send_tdls_mgmt,
+ 	.tdls_oper = nl80211_tdls_oper,
+ #endif /* CONFIG_TDLS */
++	.stop_ap = wpa_driver_nl80211_stop_ap,
+ };
+--- a/src/drivers/driver.h
++++ b/src/drivers/driver.h
+@@ -2053,6 +2053,9 @@ struct wpa_driver_ops {
+ 	 */
+ 	int (*probe_req_report)(void *priv, int report);
+ 
++
++	int (*stop_ap)(void *priv);
++
+ 	/**
+ 	 * deinit_ap - Deinitialize AP mode
+ 	 * @priv: Private driver interface data
diff --exclude .svn -Nru package/hostapd/patches/452-ctrl_iface_reload.patch package/hostapd/patches/452-ctrl_iface_reload.patch
--- package/hostapd/patches/452-ctrl_iface_reload.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/452-ctrl_iface_reload.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,98 @@
+--- a/hostapd/ctrl_iface.c
++++ b/hostapd/ctrl_iface.c
+@@ -33,6 +33,7 @@
+ #include "wps/wps.h"
+ #include "config_file.h"
+ #include "ctrl_iface.h"
++#include "config_file.h"
+ 
+ 
+ struct wpa_ctrl_dst {
+@@ -43,6 +44,7 @@ struct wpa_ctrl_dst {
+ 	int errors;
+ };
+ 
++static char *reload_opts = NULL;
+ 
+ static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
+ 				    const char *buf, size_t len);
+@@ -152,6 +154,68 @@ static int hostapd_ctrl_iface_new_sta(st
+ 	return 0;
+ }
+ 
++static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
++{
++	if (hapd->driver->stop_ap)
++		hapd->driver->stop_ap(hapd->drv_priv);
++	return 0;
++}
++
++static char *get_option(char *opt, char *str)
++{
++	int len = strlen(str);
++
++	if (!strncmp(opt, str, len))
++		return opt + len;
++	else
++		return NULL;
++}
++
++static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
++{
++	struct hostapd_config *conf;
++	char *opt, *val;
++
++	conf = hostapd_config_read(fname);
++	if (!conf)
++		return NULL;
++
++	for (opt = strtok(reload_opts, " ");
++	     opt;
++		 opt = strtok(NULL, " ")) {
++
++		if ((val = get_option(opt, "channel=")))
++			conf->channel = atoi(val);
++		else if ((val = get_option(opt, "ht_capab=")))
++			conf->ht_capab = atoi(val);
++		else if ((val = get_option(opt, "ht_capab_mask=")))
++			conf->ht_capab &= atoi(val);
++		else if ((val = get_option(opt, "sec_chan=")))
++			conf->secondary_channel = atoi(val);
++		else if ((val = get_option(opt, "hw_mode=")))
++			conf->hw_mode = atoi(val);
++		else if ((val = get_option(opt, "ieee80211n=")))
++			conf->ieee80211n = atoi(val);
++		else
++			break;
++	}
++
++	return conf;
++}
++
++static int hostapd_ctrl_iface_update(struct hostapd_data *hapd, char *txt)
++{
++	struct hostapd_config * (*config_read_cb)(const char *config_fname);
++	struct hostapd_iface *iface = hapd->iface;
++
++	config_read_cb = iface->interfaces->config_read_cb;
++	iface->interfaces->config_read_cb = hostapd_ctrl_iface_config_read;
++	reload_opts = txt;
++
++	hostapd_reload_config(iface);
++
++	iface->interfaces->config_read_cb = config_read_cb;
++}
+ 
+ #ifdef CONFIG_IEEE80211W
+ #ifdef NEED_AP_MLME
+@@ -864,6 +928,10 @@ static void hostapd_ctrl_iface_receive(i
+ 				reply_len += res;
+ 		}
+ #endif /* CONFIG_NO_RADIUS */
++	} else if (os_strcmp(buf, "DOWN") == 0) {
++		hostapd_ctrl_iface_set_down(hapd);
++	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
++		hostapd_ctrl_iface_update(hapd, buf + 7);
+ 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
+ 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
+ 							 reply_size);
diff --exclude .svn -Nru package/hostapd/patches/453-ap_sta_support.patch package/hostapd/patches/453-ap_sta_support.patch
--- package/hostapd/patches/453-ap_sta_support.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/453-ap_sta_support.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,221 @@
+--- a/wpa_supplicant/wpa_supplicant_i.h
++++ b/wpa_supplicant/wpa_supplicant_i.h
+@@ -95,6 +95,8 @@ struct wpa_interface {
+ 	 * receiving of EAPOL frames from an additional interface.
+ 	 */
+ 	const char *bridge_ifname;
++
++	const char *hostapd_ctrl;
+ };
+ 
+ /**
+@@ -294,6 +296,8 @@ struct wpa_supplicant {
+ #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
+ 	char bridge_ifname[16];
+ 
++	struct wpa_ctrl *hostapd;
++
+ 	char *confname;
+ 	struct wpa_config *conf;
+ 	int countermeasures;
+--- a/wpa_supplicant/Makefile
++++ b/wpa_supplicant/Makefile
+@@ -13,6 +13,10 @@ PKG_CONFIG ?= pkg-config
+ CFLAGS += -I../src
+ CFLAGS += -I../src/utils
+ 
++ifdef MULTICALL
++CFLAGS += -DMULTICALL
++endif
++
+ -include .config
+ -include $(if $(MULTICALL),../hostapd/.config)
+ 
+@@ -76,6 +80,10 @@ OBJS_c = wpa_cli.o ../src/common/wpa_ctr
+ OBJS_c += ../src/utils/wpa_debug.o
+ OBJS_c += ../src/utils/common.o
+ 
++ifdef MULTICALL
++OBJS += ../src/common/wpa_ctrl.o
++endif
++
+ ifndef CONFIG_OS
+ ifdef CONFIG_NATIVE_WINDOWS
+ CONFIG_OS=win32
+--- a/wpa_supplicant/wpa_supplicant.c
++++ b/wpa_supplicant/wpa_supplicant.c
+@@ -107,6 +107,55 @@ extern int wpa_debug_show_keys;
+ extern int wpa_debug_timestamp;
+ extern struct wpa_driver_ops *wpa_drivers[];
+ 
++#ifdef MULTICALL
++static int hostapd_stop(struct wpa_supplicant *wpa_s)
++{
++	const char *cmd = "DOWN";
++	char buf[256];
++	int len = sizeof(buf);
++
++	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
++		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
++		return -1;
++	}
++	return 0;
++}
++
++static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
++{
++	char *cmd = NULL;
++	char buf[256];
++	int len = sizeof(buf);
++	int channel, hw_mode;
++	int ret;
++
++	if (!bss)
++		return;
++
++	if (bss->freq < 4000) {
++		hw_mode = HOSTAPD_MODE_IEEE80211G;
++		channel = (bss->freq - 2407) / 5;
++	} else {
++		hw_mode = HOSTAPD_MODE_IEEE80211A;
++		channel = (bss->freq - 5000) / 5;
++	}
++
++	if (asprintf(&cmd, "UPDATE channel=%d sec_chan=0 hw_mode=%d ieee80211n=%d",
++		     channel, hw_mode, !!bss->ht_capab) < 0) {
++		return -1;
++	}
++
++	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
++	free(cmd);
++
++	if (ret < 0) {
++		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
++		return -1;
++	}
++	return 0;
++}
++#endif
++
+ /* Configure default/group WEP keys for static WEP */
+ int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
+ {
+@@ -672,8 +721,16 @@ void wpa_supplicant_set_state(struct wpa
+ #endif /* CONFIG_P2P */
+ 
+ 		sme_sched_obss_scan(wpa_s, 1);
++#ifdef MULTICALL
++		if (wpa_s->hostapd)
++			hostapd_reload(wpa_s, wpa_s->current_bss);
++#endif
+ 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
+ 		   state == WPA_ASSOCIATED) {
++#ifdef MULTICALL
++		if (wpa_s->hostapd)
++			hostapd_stop(wpa_s);
++#endif
+ 		wpa_s->new_connection = 1;
+ 		wpa_drv_set_operstate(wpa_s, 0);
+ #ifndef IEEE8021X_EAPOL
+@@ -2727,6 +2784,21 @@ static int wpa_supplicant_init_iface(str
+ 		os_strlcpy(wpa_s->bridge_ifname, iface->bridge_ifname,
+ 			   sizeof(wpa_s->bridge_ifname));
+ 	}
++#ifdef MULTICALL
++	if (iface->hostapd_ctrl) {
++		char *cmd = "DOWN";
++		char buf[256];
++		int len = sizeof(buf);
++
++		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
++		if (!wpa_s->hostapd) {
++			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
++			return -1;
++		}
++		if (hostapd_stop(wpa_s) < 0)
++			return -1;
++	}
++#endif
+ 
+ 	/* RSNA Supplicant Key Management - INITIALIZE */
+ 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
+--- a/wpa_supplicant/bss.c
++++ b/wpa_supplicant/bss.c
+@@ -11,6 +11,7 @@
+ #include "utils/common.h"
+ #include "utils/eloop.h"
+ #include "common/ieee802_11_defs.h"
++#include "common/ieee802_11_common.h"
+ #include "drivers/driver.h"
+ #include "wpa_supplicant_i.h"
+ #include "config.h"
+@@ -139,6 +140,8 @@ struct wpa_bss * wpa_bss_get(struct wpa_
+ 
+ static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src)
+ {
++	struct ieee80211_ht_capabilities *capab;
++	struct ieee802_11_elems elems;
+ 	os_time_t usec;
+ 
+ 	dst->flags = src->flags;
+@@ -151,6 +154,12 @@ static void wpa_bss_copy_res(struct wpa_
+ 	dst->level = src->level;
+ 	dst->tsf = src->tsf;
+ 
++	memset(&elems, 0, sizeof(elems));
++	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
++	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
++	if (capab)
++		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
++
+ 	os_get_time(&dst->last_update);
+ 	dst->last_update.sec -= src->age / 1000;
+ 	usec = (src->age % 1000) * 1000;
+--- a/wpa_supplicant/bss.h
++++ b/wpa_supplicant/bss.h
+@@ -72,6 +72,7 @@ struct wpa_bss {
+ 	u8 bssid[ETH_ALEN];
+ 	u8 hessid[ETH_ALEN];
+ 	u8 ssid[32];
++	u16 ht_capab;
+ 	size_t ssid_len;
+ 	int freq;
+ 	u16 beacon_int;
+--- a/wpa_supplicant/main.c
++++ b/wpa_supplicant/main.c
+@@ -25,7 +25,7 @@ static void usage(void)
+ 	       "usage:\n"
+ 	       "  wpa_supplicant [-BddhKLqqstuvW] [-P<pid file>] "
+ 	       "[-g<global ctrl>] \\\n"
+-	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
++	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>]"
+ 	       "[-p<driver_param>] \\\n"
+ 	       "        [-b<br_ifname>] [-f<debug file>] [-e<entropy file>] "
+ 	       "\\\n"
+@@ -67,6 +67,7 @@ static void usage(void)
+ #endif /* CONFIG_DEBUG_LINUX_TRACING */
+ 	printf("  -t = include timestamp in debug messages\n"
+ 	       "  -h = show this help text\n"
++		   "  -H = connect to a hostapd instance to manage state changes\n"
+ 	       "  -L = show license (BSD)\n"
+ 	       "  -o = override driver parameter for new interfaces\n"
+ 	       "  -O = override ctrl_interface parameter for new interfaces\n"
+@@ -155,7 +156,7 @@ int main(int argc, char *argv[])
+ 
+ 	for (;;) {
+ 		c = getopt(argc, argv,
+-			   "b:Bc:C:D:de:f:g:hi:KLNo:O:p:P:qsTtuvW");
++			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuvW");
+ 		if (c < 0)
+ 			break;
+ 		switch (c) {
+@@ -199,6 +200,9 @@ int main(int argc, char *argv[])
+ 			usage();
+ 			exitcode = 0;
+ 			goto out;
++		case 'H':
++			iface->hostapd_ctrl = optarg;
++			break;
+ 		case 'i':
+ 			iface->ifname = optarg;
+ 			break;
diff --exclude .svn -Nru package/hostapd/patches/460-disable_ctrl_iface_mib.patch package/hostapd/patches/460-disable_ctrl_iface_mib.patch
--- package/hostapd/patches/460-disable_ctrl_iface_mib.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/460-disable_ctrl_iface_mib.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,168 @@
+--- a/hostapd/Makefile
++++ b/hostapd/Makefile
+@@ -135,6 +135,9 @@ endif
+ ifdef CONFIG_NO_CTRL_IFACE
+ CFLAGS += -DCONFIG_NO_CTRL_IFACE
+ else
++ifdef CONFIG_CTRL_IFACE_MIB
++CFLAGS += -DCONFIG_CTRL_IFACE_MIB
++endif
+ OBJS += ctrl_iface.o
+ OBJS += ../src/ap/ctrl_iface_ap.o
+ endif
+--- a/hostapd/ctrl_iface.c
++++ b/hostapd/ctrl_iface.c
+@@ -899,6 +899,7 @@ static void hostapd_ctrl_iface_receive(i
+ 	} else if (os_strncmp(buf, "RELOG", 5) == 0) {
+ 		if (wpa_debug_reopen_file() < 0)
+ 			reply_len = -1;
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 	} else if (os_strcmp(buf, "MIB") == 0) {
+ 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
+ 		if (reply_len >= 0) {
+@@ -928,10 +929,12 @@ static void hostapd_ctrl_iface_receive(i
+ 				reply_len += res;
+ 		}
+ #endif /* CONFIG_NO_RADIUS */
++#endif
+ 	} else if (os_strcmp(buf, "DOWN") == 0) {
+ 		hostapd_ctrl_iface_set_down(hapd);
+ 	} else if (os_strncmp(buf, "UPDATE ", 7) == 0) {
+ 		hostapd_ctrl_iface_update(hapd, buf + 7);
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
+ 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
+ 							 reply_size);
+@@ -941,6 +944,7 @@ static void hostapd_ctrl_iface_receive(i
+ 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
+ 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
+ 							reply_size);
++#endif
+ 	} else if (os_strcmp(buf, "ATTACH") == 0) {
+ 		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
+ 			reply_len = -1;
+--- a/wpa_supplicant/Makefile
++++ b/wpa_supplicant/Makefile
+@@ -751,6 +751,9 @@ ifdef CONFIG_IEEE80211N
+ OBJS += ../src/ap/ieee802_11_ht.o
+ endif
+ ifdef CONFIG_CTRL_IFACE
++ifdef CONFIG_CTRL_IFACE_MIB
++CFLAGS += -DCONFIG_CTRL_IFACE_MIB
++endif
+ OBJS += ../src/ap/ctrl_iface_ap.o
+ endif
+ 
+--- a/wpa_supplicant/ctrl_iface.c
++++ b/wpa_supplicant/ctrl_iface.c
+@@ -4382,6 +4382,7 @@ char * wpa_supplicant_ctrl_iface_process
+ 			reply_len = -1;
+ 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
+ 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 	} else if (os_strcmp(buf, "MIB") == 0) {
+ 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
+ 		if (reply_len >= 0) {
+@@ -4393,6 +4394,7 @@ char * wpa_supplicant_ctrl_iface_process
+ 			else
+ 				reply_len += res;
+ 		}
++#endif
+ 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
+ 		reply_len = wpa_supplicant_ctrl_iface_status(
+ 			wpa_s, buf + 6, reply, reply_size);
+@@ -4792,6 +4794,7 @@ char * wpa_supplicant_ctrl_iface_process
+ 		reply_len = wpa_supplicant_ctrl_iface_bss(
+ 			wpa_s, buf + 4, reply, reply_size);
+ #ifdef CONFIG_AP
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
+ 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
+ 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
+@@ -4800,6 +4803,7 @@ char * wpa_supplicant_ctrl_iface_process
+ 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
+ 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
+ 						   reply_size);
++#endif
+ 	} else if (os_strncmp(buf, "DEAUTHENTICATE ", 15) == 0) {
+ 		if (ap_ctrl_iface_sta_deauthenticate(wpa_s, buf + 15))
+ 			reply_len = -1;
+--- a/src/ap/ctrl_iface_ap.c
++++ b/src/ap/ctrl_iface_ap.c
+@@ -20,6 +20,7 @@
+ #include "ctrl_iface_ap.h"
+ #include "ap_drv_ops.h"
+ 
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 
+ static int hostapd_ctrl_iface_sta_mib(struct hostapd_data *hapd,
+ 				      struct sta_info *sta,
+@@ -103,6 +104,7 @@ int hostapd_ctrl_iface_sta_next(struct h
+ 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
+ }
+ 
++#endif
+ 
+ #ifdef CONFIG_P2P_MANAGER
+ static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
+@@ -269,3 +271,4 @@ int hostapd_ctrl_iface_disassociate(stru
+ 
+ 	return 0;
+ }
++
+--- a/src/ap/ieee802_1x.c
++++ b/src/ap/ieee802_1x.c
+@@ -2034,6 +2034,7 @@ static const char * bool_txt(Boolean boo
+ 	return bool ? "TRUE" : "FALSE";
+ }
+ 
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 
+ int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
+ {
+@@ -2186,6 +2187,7 @@ int ieee802_1x_get_mib_sta(struct hostap
+ 	return len;
+ }
+ 
++#endif
+ 
+ static void ieee802_1x_finished(struct hostapd_data *hapd,
+ 				struct sta_info *sta, int success)
+--- a/src/ap/wpa_auth.c
++++ b/src/ap/wpa_auth.c
+@@ -2729,6 +2729,7 @@ static const char * wpa_bool_txt(int boo
+ 	return bool ? "TRUE" : "FALSE";
+ }
+ 
++#ifdef CONFIG_CTRL_IFACE_MIB
+ 
+ #define RSN_SUITE "%02x-%02x-%02x-%d"
+ #define RSN_SUITE_ARG(s) \
+@@ -2873,7 +2874,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
+ 
+ 	return len;
+ }
+-
++#endif
+ 
+ void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
+ {
+--- a/src/rsn_supp/wpa.c
++++ b/src/rsn_supp/wpa.c
+@@ -1844,6 +1844,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
+ }
+ 
+ 
++#ifdef CONFIG_CTRL_IFACE_MIB
++
+ #define RSN_SUITE "%02x-%02x-%02x-%d"
+ #define RSN_SUITE_ARG(s) \
+ ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
+@@ -1927,6 +1929,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
+ 
+ 	return (int) len;
+ }
++#endif
+ #endif /* CONFIG_CTRL_IFACE */
+ 
+ 
diff --exclude .svn -Nru package/hostapd/patches/470-wpa_ie_cap_workaround.patch package/hostapd/patches/470-wpa_ie_cap_workaround.patch
--- package/hostapd/patches/470-wpa_ie_cap_workaround.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/470-wpa_ie_cap_workaround.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,56 @@
+--- a/src/common/wpa_common.c
++++ b/src/common/wpa_common.c
+@@ -959,6 +959,31 @@ const char * wpa_key_mgmt_txt(int key_mg
+ }
+ 
+ 
++static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
++				 size_t rsn_ie_len)
++{
++	int pos, count;
++
++	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
++	if (rsn_ie_len < pos + 2)
++		return;
++
++	count = WPA_GET_LE16(wpa_msg_ie + pos);
++	pos += 2 + count * RSN_SELECTOR_LEN;
++	if (rsn_ie_len < pos + 2)
++		return;
++
++	count = WPA_GET_LE16(wpa_msg_ie + pos);
++	pos += 2 + count * RSN_SELECTOR_LEN;
++	if (rsn_ie_len < pos + 2)
++		return;
++
++	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
++	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
++		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
++}
++
++
+ int wpa_compare_rsn_ie(int ft_initial_assoc,
+ 		       const u8 *ie1, size_t ie1len,
+ 		       const u8 *ie2, size_t ie2len)
+@@ -966,8 +991,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
+ 	if (ie1 == NULL || ie2 == NULL)
+ 		return -1;
+ 
+-	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
+-		return 0; /* identical IEs */
++	if (ie1len == ie2len) {
++		u8 *ie_tmp;
++
++		if (os_memcmp(ie1, ie2, ie1len) == 0)
++			return 0; /* identical IEs */
++
++		ie_tmp = alloca(ie1len);
++		memcpy(ie_tmp, ie1, ie1len);
++		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
++
++		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
++			return 0; /* only mismatch in RSN capabilties */
++	}
+ 
+ #ifdef CONFIG_IEEE80211R
+ 	if (ft_initial_assoc) {
diff --exclude .svn -Nru package/hostapd/patches/480-terminate_on_setup_failure.patch package/hostapd/patches/480-terminate_on_setup_failure.patch
--- package/hostapd/patches/480-terminate_on_setup_failure.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/480-terminate_on_setup_failure.patch	2012-09-30 10:13:29.620734001 +0200
@@ -0,0 +1,81 @@
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -886,11 +886,8 @@ int hostapd_setup_interface_complete(str
+ 	size_t j;
+ 	u8 *prev_addr;
+ 
+-	if (err) {
+-		wpa_printf(MSG_ERROR, "Interface initialization failed");
+-		eloop_terminate();
+-		return -1;
+-	}
++	if (err)
++		goto error;
+ 
+ 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
+ 	if (hapd->iconf->channel) {
+@@ -906,7 +903,7 @@ int hostapd_setup_interface_complete(str
+ 				     hapd->iconf->secondary_channel)) {
+ 			wpa_printf(MSG_ERROR, "Could not set channel for "
+ 				   "kernel driver");
+-			return -1;
++			goto error;
+ 		}
+ 	}
+ 
+@@ -917,7 +914,7 @@ int hostapd_setup_interface_complete(str
+ 			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
+ 				       HOSTAPD_LEVEL_WARNING,
+ 				       "Failed to prepare rates table.");
+-			return -1;
++			goto error;
+ 		}
+ 	}
+ 
+@@ -925,14 +922,14 @@ int hostapd_setup_interface_complete(str
+ 	    hostapd_set_rts(hapd, hapd->iconf->rts_threshold)) {
+ 		wpa_printf(MSG_ERROR, "Could not set RTS threshold for "
+ 			   "kernel driver");
+-		return -1;
++		goto error;
+ 	}
+ 
+ 	if (hapd->iconf->fragm_threshold > -1 &&
+ 	    hostapd_set_frag(hapd, hapd->iconf->fragm_threshold)) {
+ 		wpa_printf(MSG_ERROR, "Could not set fragmentation threshold "
+ 			   "for kernel driver");
+-		return -1;
++		goto error;
+ 	}
+ 
+ 	prev_addr = hapd->own_addr;
+@@ -942,7 +939,7 @@ int hostapd_setup_interface_complete(str
+ 		if (j)
+ 			os_memcpy(hapd->own_addr, prev_addr, ETH_ALEN);
+ 		if (hostapd_setup_bss(hapd, j == 0))
+-			return -1;
++			goto error;
+ 		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
+ 			prev_addr = hapd->own_addr;
+ 	}
+@@ -954,7 +951,7 @@ int hostapd_setup_interface_complete(str
+ 	if (hostapd_driver_commit(hapd) < 0) {
+ 		wpa_printf(MSG_ERROR, "%s: Failed to commit driver "
+ 			   "configuration", __func__);
+-		return -1;
++		goto error;
+ 	}
+ 
+ 	/*
+@@ -975,6 +972,11 @@ int hostapd_setup_interface_complete(str
+ 		   iface->bss[0]->conf->iface);
+ 
+ 	return 0;
++
++error:
++	wpa_printf(MSG_ERROR, "Interface initialization failed");
++	eloop_terminate();
++	return -1;
+ }
+ 
+ 
diff --exclude .svn -Nru package/hostapd/patches/500-random_pool_add_kernel.patch package/hostapd/patches/500-random_pool_add_kernel.patch
--- package/hostapd/patches/500-random_pool_add_kernel.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/500-random_pool_add_kernel.patch	2012-09-30 10:13:29.620734001 +0200
@@ -0,0 +1,168 @@
+--- a/src/crypto/random.c
++++ b/src/crypto/random.c
+@@ -33,6 +33,8 @@
+ #include "sha1.h"
+ #include "random.h"
+ 
++#define RANDOM_STAMPFILE "/var/run/.random_available"
++
+ #define POOL_WORDS 32
+ #define POOL_WORDS_MASK (POOL_WORDS - 1)
+ #define POOL_TAP1 26
+@@ -43,6 +45,8 @@
+ #define EXTRACT_LEN 16
+ #define MIN_READY_MARK 2
+ 
++#ifndef CONFIG_NO_RANDOM_POOL
++
+ static u32 pool[POOL_WORDS];
+ static unsigned int input_rotate = 0;
+ static unsigned int pool_pos = 0;
+@@ -123,7 +127,7 @@ static void random_extract(u8 *out)
+ }
+ 
+ 
+-void random_add_randomness(const void *buf, size_t len)
++static void random_pool_add_randomness(const void *buf, size_t len)
+ {
+ 	struct os_time t;
+ 	static unsigned int count = 0;
+@@ -213,16 +217,22 @@ int random_get_bytes(void *buf, size_t l
+ int random_pool_ready(void)
+ {
+ #ifdef __linux__
++	struct stat st;
+ 	int fd;
+ 	ssize_t res;
+ 
++	if (stat(RANDOM_STAMPFILE, &st) == 0)
++		return 1;
++
+ 	/*
+ 	 * Make sure that there is reasonable entropy available before allowing
+ 	 * some key derivation operations to proceed.
+ 	 */
+ 
+-	if (dummy_key_avail == sizeof(dummy_key))
++	if (dummy_key_avail == sizeof(dummy_key)) {
++		random_mark_pool_ready();
+ 		return 1; /* Already initialized - good to continue */
++	}
+ 
+ 	/*
+ 	 * Try to fetch some more data from the kernel high quality
+@@ -257,6 +267,7 @@ int random_pool_ready(void)
+ 	if (dummy_key_avail == sizeof(dummy_key)) {
+ 		if (own_pool_ready < MIN_READY_MARK)
+ 			own_pool_ready = MIN_READY_MARK;
++		random_mark_pool_ready();
+ 		random_write_entropy();
+ 		return 1;
+ 	}
+@@ -269,6 +280,7 @@ int random_pool_ready(void)
+ 	    total_collected + 10 * own_pool_ready > MIN_COLLECT_ENTROPY) {
+ 		wpa_printf(MSG_INFO, "random: Allow operation to proceed "
+ 			   "based on internal entropy");
++		random_mark_pool_ready();
+ 		return 1;
+ 	}
+ 
+@@ -284,10 +296,16 @@ int random_pool_ready(void)
+ 
+ void random_mark_pool_ready(void)
+ {
++	int fd;
++
+ 	own_pool_ready++;
+ 	wpa_printf(MSG_DEBUG, "random: Mark internal entropy pool to be "
+ 		   "ready (count=%u/%u)", own_pool_ready, MIN_READY_MARK);
+ 	random_write_entropy();
++
++	fd = open(RANDOM_STAMPFILE, O_CREAT | O_WRONLY | O_EXCL | O_NOFOLLOW, 0600);
++	if (fd >= 0)
++		close(fd);
+ }
+ 
+ 
+@@ -444,3 +462,22 @@ void random_deinit(void)
+ 	os_free(random_entropy_file);
+ 	random_entropy_file = NULL;
+ }
++
++#endif /* CONFIG_NO_RANDOM_POOL */
++
++
++void random_add_randomness(const void *buf, size_t len)
++{
++#ifdef __linux__
++	int fd;
++
++	fd = open("/dev/random", O_RDWR);
++	if (fd >= 0) {
++		write(fd, buf, len);
++		close(fd);
++	}
++#endif
++#ifndef CONFIG_NO_RANDOM_POOL
++	random_pool_add_randomness(buf, len);
++#endif
++}
+--- a/wpa_supplicant/Makefile
++++ b/wpa_supplicant/Makefile
+@@ -1217,9 +1217,8 @@ endif
+ 
+ ifdef CONFIG_NO_RANDOM_POOL
+ CFLAGS += -DCONFIG_NO_RANDOM_POOL
+-else
+-OBJS += ../src/crypto/random.o
+ endif
++OBJS += ../src/crypto/random.o
+ 
+ ifdef CONFIG_CTRL_IFACE
+ ifeq ($(CONFIG_CTRL_IFACE), y)
+--- a/wpa_supplicant/Android.mk
++++ b/wpa_supplicant/Android.mk
+@@ -1161,9 +1161,8 @@ endif
+ 
+ ifdef CONFIG_NO_RANDOM_POOL
+ L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
+-else
+-OBJS += src/crypto/random.c
+ endif
++OBJS += src/crypto/random.c
+ 
+ ifdef CONFIG_CTRL_IFACE
+ ifeq ($(CONFIG_CTRL_IFACE), y)
+--- a/hostapd/Android.mk
++++ b/hostapd/Android.mk
+@@ -748,11 +748,11 @@ endif
+ ifdef CONFIG_NO_RANDOM_POOL
+ L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
+ else
+-OBJS += src/crypto/random.c
+-HOBJS += src/crypto/random.c
+ HOBJS += $(SHA1OBJS)
+ HOBJS += src/crypto/md5.c
+ endif
++OBJS += src/crypto/random.c
++HOBJS += src/crypto/random.c
+ 
+ ifdef CONFIG_RADIUS_SERVER
+ L_CFLAGS += -DRADIUS_SERVER
+--- a/hostapd/Makefile
++++ b/hostapd/Makefile
+@@ -755,12 +755,12 @@ endif
+ ifdef CONFIG_NO_RANDOM_POOL
+ CFLAGS += -DCONFIG_NO_RANDOM_POOL
+ else
+-OBJS += ../src/crypto/random.o
+-HOBJS += ../src/crypto/random.o
+ HOBJS += ../src/utils/eloop.o
+ HOBJS += $(SHA1OBJS)
+ HOBJS += ../src/crypto/md5.o
+ endif
++OBJS += ../src/crypto/random.o
++HOBJS += ../src/crypto/random.o
+ 
+ ifdef CONFIG_RADIUS_SERVER
+ CFLAGS += -DRADIUS_SERVER
diff --exclude .svn -Nru package/hostapd/patches/500-scan_wait.patch package/hostapd/patches/500-scan_wait.patch
--- package/hostapd/patches/500-scan_wait.patch	2012-08-17 15:40:41.381971000 +0200
+++ package/hostapd/patches/500-scan_wait.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,149 +0,0 @@
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -235,6 +235,7 @@ struct hostapd_iface {
- 	int (*for_each_interface)(struct hapd_interfaces *interfaces,
- 				  int (*cb)(struct hostapd_iface *iface,
- 					    void *ctx), void *ctx);
-+	int (*init_complete)(struct hostapd_iface *iface);
- };
- 
- /* hostapd.c */
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -804,6 +804,9 @@ int hostapd_setup_interface_complete(str
- 	wpa_printf(MSG_DEBUG, "%s: Setup of interface done.",
- 		   iface->bss[0]->conf->iface);
- 
-+	if (iface->init_complete)
-+		iface->init_complete(iface);
-+
- 	return 0;
- }
- 
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -36,6 +36,8 @@
- extern int wpa_debug_level;
- extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
-+static int daemonize = 0;
-+static char *pid_file = NULL;
- 
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-@@ -173,6 +175,16 @@ static void hostapd_logger_cb(void *ctx,
- }
- #endif /* CONFIG_NO_HOSTAPD_LOGGER */
- 
-+static int hostapd_init_complete(struct hostapd_iface *iface)
-+{
-+	if (daemonize && os_daemonize(pid_file)) {
-+		perror("daemon");
-+		return -1;
-+	}
-+	daemonize = 0;
-+	return 0;
-+}
-+
- 
- /**
-  * hostapd_init - Allocate and initialize per-interface data
-@@ -194,6 +206,7 @@ static struct hostapd_iface * hostapd_in
- 	if (hapd_iface == NULL)
- 		goto fail;
- 
-+	hapd_iface->init_complete = hostapd_init_complete;
- 	hapd_iface->reload_config = hostapd_reload_config;
- 	hapd_iface->config_read_cb = hostapd_config_read;
- 	hapd_iface->config_fname = os_strdup(config_file);
-@@ -442,7 +455,7 @@ static int hostapd_global_init(struct ha
- }
- 
- 
--static void hostapd_global_deinit(const char *pid_file)
-+static void hostapd_global_deinit(void)
- {
- 	int i;
- 
-@@ -472,8 +485,7 @@ static void hostapd_global_deinit(const 
- }
- 
- 
--static int hostapd_global_run(struct hapd_interfaces *ifaces, int daemonize,
--			      const char *pid_file)
-+static int hostapd_global_run(struct hapd_interfaces *iface)
- {
- #ifdef EAP_SERVER_TNC
- 	int tnc = 0;
-@@ -494,11 +506,6 @@ static int hostapd_global_run(struct hap
- 	}
- #endif /* EAP_SERVER_TNC */
- 
--	if (daemonize && os_daemonize(pid_file)) {
--		perror("daemon");
--		return -1;
--	}
--
- 	eloop_run();
- 
- 	return 0;
-@@ -555,8 +562,7 @@ int main(int argc, char *argv[])
- 	struct hapd_interfaces interfaces;
- 	int ret = 1;
- 	size_t i;
--	int c, debug = 0, daemonize = 0;
--	char *pid_file = NULL;
-+	int c, debug = 0;
- 	const char *log_file = NULL;
- 	const char *entropy_file = NULL;
- 
-@@ -634,7 +640,7 @@ int main(int argc, char *argv[])
- 			goto out;
- 	}
- 
--	if (hostapd_global_run(&interfaces, daemonize, pid_file))
-+	if (hostapd_global_run(&interfaces))
- 		goto out;
- 
- 	ret = 0;
-@@ -645,7 +651,7 @@ int main(int argc, char *argv[])
- 		hostapd_interface_deinit_free(interfaces.iface[i]);
- 	os_free(interfaces.iface);
- 
--	hostapd_global_deinit(pid_file);
-+	hostapd_global_deinit();
- 	os_free(pid_file);
- 
- 	if (log_file)
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -1925,6 +1925,8 @@ struct hostapd_config * hostapd_config_r
- 			}
- #endif /* CONFIG_IEEE80211W */
- #ifdef CONFIG_IEEE80211N
-+		} else if (os_strcmp(buf, "noscan") == 0) {
-+			conf->noscan = atoi(pos);
- 		} else if (os_strcmp(buf, "ieee80211n") == 0) {
- 			conf->ieee80211n = atoi(pos);
- 		} else if (os_strcmp(buf, "ht_capab") == 0) {
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -412,6 +412,7 @@ struct hostapd_config {
- 
- 	int ht_op_mode_fixed;
- 	u16 ht_capab;
-+	int noscan;
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
---- a/src/ap/hw_features.c
-+++ b/src/ap/hw_features.c
-@@ -449,7 +449,7 @@ static int ieee80211n_check_40mhz(struct
- {
- 	struct wpa_driver_scan_params params;
- 
--	if (!iface->conf->secondary_channel)
-+	if (!iface->conf->secondary_channel || iface->conf->noscan)
- 		return 0; /* HT40 not used */
- 
- 	wpa_printf(MSG_DEBUG, "Scan for neighboring BSSes prior to enabling "
diff --exclude .svn -Nru package/hostapd/patches/510-bring_down_interface.patch package/hostapd/patches/510-bring_down_interface.patch
--- package/hostapd/patches/510-bring_down_interface.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/510-bring_down_interface.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,19 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -7144,8 +7144,6 @@ static int wpa_driver_nl80211_set_mode(s
+ 			ret = nl80211_set_mode(drv, drv->ifindex, nlmode);
+ 			if (ret == -EACCES)
+ 				break;
+-			res = linux_set_iface_flags(drv->global->ioctl_sock,
+-						    bss->ifname, 1);
+ 			if (res && !ret)
+ 				ret = -1;
+ 			else if (ret != -EBUSY)
+@@ -7161,6 +7159,7 @@ static int wpa_driver_nl80211_set_mode(s
+ 			   "interface is down");
+ 		drv->nlmode = nlmode;
+ 		drv->ignore_if_down_event = 1;
++		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
+ 	}
+ 
+ done:
diff --exclude .svn -Nru package/hostapd/patches/510-multicall.patch package/hostapd/patches/510-multicall.patch
--- package/hostapd/patches/510-multicall.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/510-multicall.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,246 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src/utils
- # CFLAGS += -DUSE_KERNEL_HEADERS -I/usr/src/linux/include
- 
- -include .config
-+-include $(if $(MULTICALL), ../wpa_supplicant/.config)
- 
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
-@@ -168,10 +169,14 @@ ifdef CONFIG_IEEE80211N
- CFLAGS += -DCONFIG_IEEE80211N
- endif
- 
-+ifndef MULTICALL
-+CFLAGS += -DNO_SUPPLICANT
-+endif
-+
- include ../src/drivers/drivers.mak
--OBJS += $(DRV_AP_OBJS)
--CFLAGS += $(DRV_AP_CFLAGS)
--LDFLAGS += $(DRV_AP_LDFLAGS)
-+OBJS += $(sort $(DRV_AP_OBJS) $(if $(MULTICALL),$(DRV_WPA_OBJS)))
-+CFLAGS += $(DRV_AP_CFLAGS) $(if $(MULTICALL),$(DRV_WPA_CFLAGS))
-+LDFLAGS += $(DRV_AP_LDFLAGS) $(if $(MULTICALL),$(DRV_WPA_LDFLAGS))
- LIBS += $(DRV_AP_LIBS)
- 
- ifdef CONFIG_L2_PACKET
-@@ -799,6 +804,12 @@ install: all
- 
- BCHECK=../src/drivers/build.hostapd
- 
-+hostapd_multi.a: $(BCHECK) $(OBJS)
-+	$(Q)$(CC) -c -o hostapd_multi.o -Dmain=hostapd_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ hostapd_multi.o $(OBJS)
-+
- hostapd: $(BCHECK) $(OBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
- 	@$(E) "  LD " $@
-@@ -837,6 +848,12 @@ HOBJS += ../src/crypto/aes-internal.o
- HOBJS += ../src/crypto/aes-internal-enc.o
- endif
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- nt_password_hash: $(NOBJS)
- 	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
- 	@$(E) "  LD " $@
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -14,6 +14,7 @@ CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
- -include .config
-+-include $(if $(MULTICALL),../hostapd/.config)
- 
- ALL=wpa_supplicant wpa_cli
- 
-@@ -663,6 +664,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
- CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
- LIBS += -ldl -rdynamic
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_common/eap_common.o
-+  endif
- endif
- 
- ifdef CONFIG_AP
-@@ -671,9 +676,11 @@ NEED_EAP_COMMON=y
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_AP
- OBJS += ap.o
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
- CFLAGS += -DCONFIG_NO_ACCOUNTING
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ../src/ap/hostapd.o
- OBJS += ../src/ap/wpa_auth_glue.o
- OBJS += ../src/ap/utils.o
-@@ -718,10 +725,18 @@ CFLAGS += -DEAP_SERVER_WSC
- OBJS += ../src/ap/wps_hostapd.o
- OBJS += ../src/eap_server/eap_server_wsc.o
- endif
-+else
-+  ifdef MULTICALL
-+    OBJS += ../src/eap_server/eap_server.o
-+    OBJS += ../src/eap_server/eap_server_identity.o
-+    OBJS += ../src/eap_server/eap_server_methods.o
-+  endif
- endif
- 
- ifdef NEED_RSN_AUTHENTICATOR
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_RADIUS
-+endif
- NEED_AES_WRAP=y
- OBJS += ../src/ap/wpa_auth.o
- OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1397,6 +1412,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
- 	$(Q)$(LDO) $(LDFLAGS) -o wpa_priv $(OBJS_priv) $(LIBS)
- 	@$(E) "  LD " $@
- 
-+wpa_supplicant_multi.a: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
-+	$(Q)$(CC) -c -o wpa_supplicant_multi.o -Dmain=wpa_supplicant_main $(CFLAGS) main.c
-+	@$(E) "  CC " $<
-+	@rm -f $@
-+	@$(AR) cr $@ wpa_supplicant_multi.o $(OBJS)
-+
- wpa_supplicant: .config $(BCHECK) $(OBJS) $(EXTRA_progs)
- 	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
- 	@$(E) "  LD " $@
-@@ -1460,6 +1481,12 @@ eap_ikev2.so: ../src/eap_peer/eap_ikev2.
- %.service: %.service.in
- 	sed -e 's|\@BINDIR\@|$(BINDIR)|g' $< >$@
- 
-+dump_cflags:
-+	@echo -n $(CFLAGS) " "
-+
-+dump_ldflags:
-+	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
-+
- wpa_supplicant.exe: wpa_supplicant
- 	mv -f $< $@
- wpa_cli.exe: wpa_cli
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -3452,8 +3452,8 @@ union wpa_event_data {
-  * Driver wrapper code should call this function whenever an event is received
-  * from the driver.
-  */
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data);
-+extern void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+				    union wpa_event_data *data);
- 
- 
- /*
---- a/src/ap/drv_callbacks.c
-+++ b/src/ap/drv_callbacks.c
-@@ -467,8 +467,8 @@ static void hostapd_event_eapol_rx(struc
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+		       union wpa_event_data *data)
- {
- 	struct hostapd_data *hapd = ctx;
- 
---- a/wpa_supplicant/wpa_priv.c
-+++ b/wpa_supplicant/wpa_priv.c
-@@ -825,8 +825,8 @@ static void wpa_priv_send_ft_response(st
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+static void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data)
- {
- 	struct wpa_priv_interface *iface = ctx;
- 
-@@ -968,6 +968,7 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_priv_fd_workaround();
- 
- 	for (;;) {
---- a/wpa_supplicant/events.c
-+++ b/wpa_supplicant/events.c
-@@ -1936,8 +1936,8 @@ static void wnm_action_rx(struct wpa_sup
- }
- 
- 
--void wpa_supplicant_event(void *ctx, enum wpa_event_type event,
--			  union wpa_event_data *data)
-+void supplicant_event(void *ctx, enum wpa_event_type event,
-+		      union wpa_event_data *data)
- {
- 	struct wpa_supplicant *wpa_s = ctx;
- 	u16 reason_code = 0;
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2412,6 +2412,9 @@ static void wpa_supplicant_deinit_iface(
- 		wpa_drv_deinit(wpa_s);
- }
- 
-+extern void supplicant_event(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
-+
- 
- /**
-  * wpa_supplicant_add_iface - Add a new network interface
-@@ -2602,6 +2605,7 @@ struct wpa_global * wpa_supplicant_init(
- 	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
- #endif /* CONFIG_NO_WPA_MSG */
- 
-+	wpa_supplicant_event = supplicant_event;
- 	wpa_debug_open_file(params->wpa_debug_file_path);
- 	if (params->wpa_debug_syslog)
- 		wpa_debug_open_syslog();
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -556,6 +556,9 @@ static const char * hostapd_msg_ifname_c
- 	return NULL;
- }
- 
-+void hostapd_wpa_event(void *ctx, enum wpa_event_type event,
-+                       union wpa_event_data *data);
-+
- 
- int main(int argc, char *argv[])
- {
-@@ -569,6 +572,7 @@ int main(int argc, char *argv[])
- 	if (os_program_init())
- 		return -1;
- 
-+	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
- 		c = getopt(argc, argv, "Bde:f:hKP:tv");
- 		if (c < 0)
---- a/src/drivers/drivers.c
-+++ b/src/drivers/drivers.c
-@@ -13,7 +13,11 @@
-  */
- 
- #include "includes.h"
-+#include "common.h"
-+#include "driver.h"
- 
-+void (*wpa_supplicant_event)(void *ctx, enum wpa_event_type event,
-+			     union wpa_event_data *data);
- 
- #ifdef CONFIG_DRIVER_WEXT
- extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
diff --exclude .svn -Nru package/hostapd/patches/520-fix_wps_pin_crash.patch package/hostapd/patches/520-fix_wps_pin_crash.patch
--- package/hostapd/patches/520-fix_wps_pin_crash.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/520-fix_wps_pin_crash.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,12 @@
+--- a/hostapd/ctrl_iface.c
++++ b/hostapd/ctrl_iface.c
+@@ -450,6 +450,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
+ 	char *pos;
+ 	const char *pin_txt;
+ 
++	if (!hapd->wps)
++		return -1;
++
+ 	pos = os_strchr(txt, ' ');
+ 	if (pos)
+ 		*pos++ = '\0';
diff --exclude .svn -Nru package/hostapd/patches/520-timestamp_check.patch package/hostapd/patches/520-timestamp_check.patch
--- package/hostapd/patches/520-timestamp_check.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/520-timestamp_check.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
---- a/src/tls/x509v3.c
-+++ b/src/tls/x509v3.c
-@@ -1854,6 +1854,9 @@ int x509_certificate_chain_validate(stru
- 		if (chain_trusted)
- 			continue;
- 
-+#ifdef NO_TIMESTAMP_CHECK
-+		disable_time_checks = 1;
-+#endif
- 		if (!disable_time_checks &&
- 		    ((unsigned long) now.sec <
- 		     (unsigned long) cert->not_before ||
diff --exclude .svn -Nru package/hostapd/patches/530-rescan_immediately.patch package/hostapd/patches/530-rescan_immediately.patch
--- package/hostapd/patches/530-rescan_immediately.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/530-rescan_immediately.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2157,7 +2157,7 @@ static struct wpa_supplicant * wpa_suppl
- 	if (wpa_s == NULL)
- 		return NULL;
- 	wpa_s->scan_req = 1;
--	wpa_s->scan_interval = 5;
-+	wpa_s->scan_interval = 1;
- 	wpa_s->new_connection = 1;
- 	wpa_s->parent = wpa_s;
- 	wpa_s->sched_scanning = 0;
diff --exclude .svn -Nru package/hostapd/patches/530-wps_single_auth_enc_type.patch package/hostapd/patches/530-wps_single_auth_enc_type.patch
--- package/hostapd/patches/530-wps_single_auth_enc_type.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/530-wps_single_auth_enc_type.patch	2012-09-30 10:13:29.620734001 +0200
@@ -0,0 +1,25 @@
+--- a/src/ap/wps_hostapd.c
++++ b/src/ap/wps_hostapd.c
+@@ -873,11 +873,9 @@ int hostapd_init_wps(struct hostapd_data
+ 
+ 		if (conf->rsn_pairwise & WPA_CIPHER_CCMP)
+ 			wps->encr_types |= WPS_ENCR_AES;
+-		if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
++		else if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
+ 			wps->encr_types |= WPS_ENCR_TKIP;
+-	}
+-
+-	if (conf->wpa & WPA_PROTO_WPA) {
++	} else if (conf->wpa & WPA_PROTO_WPA) {
+ 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
+ 			wps->auth_types |= WPS_AUTH_WPAPSK;
+ 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X)
+@@ -885,7 +883,7 @@ int hostapd_init_wps(struct hostapd_data
+ 
+ 		if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
+ 			wps->encr_types |= WPS_ENCR_AES;
+-		if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
++		else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
+ 			wps->encr_types |= WPS_ENCR_TKIP;
+ 	}
+ 
diff --exclude .svn -Nru package/hostapd/patches/540-dynamic_20_40_mhz.patch package/hostapd/patches/540-dynamic_20_40_mhz.patch
--- package/hostapd/patches/540-dynamic_20_40_mhz.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/540-dynamic_20_40_mhz.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,202 @@
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -2495,6 +2495,10 @@ static int hostapd_config_fill(struct ho
+ 					   "ht_capab", line);
+ 				errors++;
+ 			}
++		} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
++			conf->dynamic_ht40 = atoi(pos);
++			if (conf->dynamic_ht40 == 1)
++				conf->dynamic_ht40 = 1500;
+ 		} else if (os_strcmp(buf, "require_ht") == 0) {
+ 			conf->require_ht = atoi(pos);
+ #endif /* CONFIG_IEEE80211N */
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -501,6 +501,7 @@ struct hostapd_config {
+ 	int ieee80211n;
+ 	int secondary_channel;
+ 	int require_ht;
++	int dynamic_ht40;
+ 	u32 vht_capab;
+ 	int ieee80211ac;
+ 	int require_vht;
+--- a/src/ap/hostapd.c
++++ b/src/ap/hostapd.c
+@@ -22,6 +22,7 @@
+ #include "beacon.h"
+ #include "iapp.h"
+ #include "ieee802_1x.h"
++#include "ieee802_11.h"
+ #include "ieee802_11_auth.h"
+ #include "vlan_init.h"
+ #include "wpa_auth.h"
+@@ -323,6 +324,7 @@ static void hostapd_cleanup_iface_pre(st
+ 
+ static void hostapd_cleanup_iface_partial(struct hostapd_iface *iface)
+ {
++	hostapd_deinit_ht(iface);
+ 	hostapd_free_hw_features(iface->hw_features, iface->num_hw_features);
+ 	iface->hw_features = NULL;
+ 	os_free(iface->current_rates);
+--- a/src/ap/hostapd.h
++++ b/src/ap/hostapd.h
+@@ -251,6 +251,9 @@ struct hostapd_iface {
+ 	/* Overlapping BSS information */
+ 	int olbc_ht;
+ 
++	int force_20mhz;
++	struct os_time last_20mhz_trigger;
++
+ 	u16 ht_op_mode;
+ 	void (*scan_cb)(struct hostapd_iface *iface);
+ };
+--- a/src/ap/ieee802_11.c
++++ b/src/ap/ieee802_11.c
+@@ -1220,6 +1220,9 @@ static void handle_beacon(struct hostapd
+ 					     sizeof(mgmt->u.beacon)), &elems,
+ 				      0);
+ 
++	if (!elems.ht_capabilities)
++		hostapd_trigger_20mhz(hapd->iface);
++
+ 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
+ }
+ 
+--- a/src/ap/ieee802_11.h
++++ b/src/ap/ieee802_11.h
+@@ -78,4 +78,17 @@ int hostapd_update_time_adv(struct hosta
+ void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
+ u8 * hostapd_eid_bss_max_idle_period(struct hostapd_data *hapd, u8 *eid);
+ 
++#ifdef CONFIG_IEEE80211N
++void hostapd_trigger_20mhz(struct hostapd_iface *iface);
++void hostapd_deinit_ht(struct hostapd_iface *iface);
++
++#else
++static inline void hostapd_deinit_ht(struct hostapd_iface *iface)
++{
++}
++static inline void hostapd_trigger_20mhz(struct hostapd_iface *iface)
++{
++}
++#endif /* CONFIG_IEEE80211N */
++
+ #endif /* IEEE802_11_H */
+--- a/src/ap/ieee802_11_ht.c
++++ b/src/ap/ieee802_11_ht.c
+@@ -20,9 +20,11 @@
+ #include "drivers/driver.h"
+ #include "hostapd.h"
+ #include "ap_config.h"
++#include "ap_drv_ops.h"
+ #include "sta_info.h"
+ #include "beacon.h"
+ #include "ieee802_11.h"
++#include "utils/eloop.h"
+ 
+ 
+ u8 * hostapd_eid_ht_capabilities(struct hostapd_data *hapd, u8 *eid)
+@@ -70,12 +72,15 @@ u8 * hostapd_eid_ht_operation(struct hos
+ 
+ 	oper->control_chan = hapd->iconf->channel;
+ 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
+-	if (hapd->iconf->secondary_channel == 1)
+-		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
+-			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
+-	if (hapd->iconf->secondary_channel == -1)
+-		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
+-			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
++
++	if (!hapd->iface->force_20mhz) {
++		if (hapd->iconf->secondary_channel == 1)
++			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
++				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
++		if (hapd->iconf->secondary_channel == -1)
++			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
++				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
++	}
+ 
+ 	pos += sizeof(*oper);
+ 
+@@ -271,3 +276,80 @@ void hostapd_get_ht_capab(struct hostapd
+ 
+ 	neg_ht_cap->ht_capabilities_info = host_to_le16(cap);
+ }
++
++static void hostapd_set_force_20mhz(struct hostapd_iface *iface);
++
++static void hostapd_restore_40mhz(void *eloop_data, void *user_ctx)
++{
++	struct hostapd_iface *iface = eloop_data;
++	struct os_time time;
++	int timeout;
++
++	if (!iface->last_20mhz_trigger.sec)
++	    return;
++
++	os_get_time(&time);
++	timeout = iface->last_20mhz_trigger.sec + iface->conf->dynamic_ht40 -
++		  time.sec;
++
++	if (timeout > 0) {
++		eloop_register_timeout(timeout, 0, hostapd_restore_40mhz,
++				       iface, NULL);
++		return;
++	}
++
++	iface->last_20mhz_trigger.sec = 0;
++	iface->last_20mhz_trigger.usec = 0;
++
++	iface->force_20mhz = 0;
++	hostapd_set_force_20mhz(iface);
++}
++
++static void hostapd_set_force_20mhz(struct hostapd_iface *iface)
++{
++	int secondary_channel;
++	int i;
++
++	ieee802_11_set_beacons(iface);
++
++	for (i = 0; i < iface->num_bss; i++) {
++		struct hostapd_data *hapd = iface->bss[i];
++
++		if (iface->force_20mhz)
++			secondary_channel = 0;
++		else
++			secondary_channel = hapd->iconf->secondary_channel;
++
++		if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
++					 hapd->iconf->channel,
++					 hapd->iconf->ieee80211n,
++					 secondary_channel)) {
++			wpa_printf(MSG_ERROR, "Could not set channel for "
++				   "kernel driver");
++		}
++	}
++}
++
++void hostapd_deinit_ht(struct hostapd_iface *iface)
++{
++	eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
++}
++
++void hostapd_trigger_20mhz(struct hostapd_iface *iface)
++{
++	if (!iface->conf->dynamic_ht40)
++		return;
++
++	if (!iface->force_20mhz) {
++		iface->force_20mhz = 1;
++		hostapd_set_force_20mhz(iface);
++	}
++
++	if (!iface->last_20mhz_trigger.sec) {
++		eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
++		eloop_register_timeout(iface->conf->dynamic_ht40, 0,
++				       hostapd_restore_40mhz, iface, NULL);
++	}
++
++	os_get_time(&iface->last_20mhz_trigger);
++}
diff --exclude .svn -Nru package/hostapd/patches/540-optional_rfkill.patch package/hostapd/patches/540-optional_rfkill.patch
--- package/hostapd/patches/540-optional_rfkill.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/540-optional_rfkill.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,261 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -198,7 +198,9 @@ struct wpa_driver_nl80211_data {
- 	int if_removed;
- 	int if_disabled;
- 	int ignore_if_down_event;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	struct wpa_driver_capa capa;
- 	int has_capability;
- 
-@@ -2203,7 +2205,7 @@ err3:
- 	return -1;
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "nl80211: RFKILL blocked");
-@@ -2226,6 +2228,7 @@ static void wpa_driver_nl80211_rfkill_un
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static void nl80211_get_phy_name(struct wpa_driver_nl80211_data *drv)
-@@ -2283,7 +2286,9 @@ static void * wpa_driver_nl80211_init(vo
- 				      void *global_priv)
- {
- 	struct wpa_driver_nl80211_data *drv;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	struct i802_bss *bss;
- 
- 	drv = os_zalloc(sizeof(*drv));
-@@ -2311,6 +2316,7 @@ static void * wpa_driver_nl80211_init(vo
- 
- 	nl80211_get_phy_name(drv);
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto failed;
-@@ -2323,6 +2329,7 @@ static void * wpa_driver_nl80211_init(vo
- 		wpa_printf(MSG_DEBUG, "nl80211: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	if (wpa_driver_nl80211_finish_drv_init(drv))
- 		goto failed;
-@@ -2445,10 +2452,12 @@ static int nl80211_register_action_frame
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_nl80211_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static int
-@@ -2475,13 +2484,16 @@ wpa_driver_nl80211_finish_drv_init(struc
- 		}
- 
- 		if (linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1)) {
-+#ifdef CONFIG_RFKILL
- 			if (rfkill_is_blocked(drv->rfkill)) {
- 				wpa_printf(MSG_DEBUG, "nl80211: Could not yet enable "
- 					   "interface '%s' due to rfkill",
- 					   bss->ifname);
- 				drv->if_disabled = 1;
- 				send_rfkill_event = 1;
--			} else {
-+			} else
-+#endif
-+			{
- 				wpa_printf(MSG_ERROR, "nl80211: Could not set "
- 					   "interface '%s' UP", bss->ifname);
- 				return -1;
-@@ -2510,8 +2522,10 @@ wpa_driver_nl80211_finish_drv_init(struc
- 	}
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_nl80211_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -2596,7 +2610,9 @@ static void wpa_driver_nl80211_deinit(vo
- 
- 	netlink_send_oper_ifla(drv->global->netlink, drv->ifindex, 0,
- 			       IF_OPER_UP);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	eloop_cancel_timeout(wpa_driver_nl80211_scan_timeout, drv, drv->ctx);
- 
---- a/src/drivers/driver_wext.c
-+++ b/src/drivers/driver_wext.c
-@@ -702,7 +702,7 @@ static void wpa_driver_wext_event_rtm_de
- 	}
- }
- 
--
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_rfkill_blocked(void *ctx)
- {
- 	wpa_printf(MSG_DEBUG, "WEXT: RFKILL blocked");
-@@ -724,7 +724,7 @@ static void wpa_driver_wext_rfkill_unblo
- 	}
- 	/* rtnetlink ifup handler will report interface as enabled */
- }
--
-+#endif /* CONFIG_RFKILL */
- 
- static void wext_get_phy_name(struct wpa_driver_wext_data *drv)
- {
-@@ -770,7 +770,9 @@ void * wpa_driver_wext_init(void *ctx, c
- {
- 	struct wpa_driver_wext_data *drv;
- 	struct netlink_config *cfg;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_config *rcfg;
-+#endif
- 	char path[128];
- 	struct stat buf;
- 
-@@ -805,6 +807,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		goto err2;
- 	}
- 
-+#ifdef CONFIG_RFKILL
- 	rcfg = os_zalloc(sizeof(*rcfg));
- 	if (rcfg == NULL)
- 		goto err3;
-@@ -817,6 +820,7 @@ void * wpa_driver_wext_init(void *ctx, c
- 		wpa_printf(MSG_DEBUG, "WEXT: RFKILL status not available");
- 		os_free(rcfg);
- 	}
-+#endif /* CONFIG_RFKILL */
- 
- 	drv->mlme_sock = -1;
- 
-@@ -828,7 +832,9 @@ void * wpa_driver_wext_init(void *ctx, c
- 	return drv;
- 
- err3:
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 	netlink_deinit(drv->netlink);
- err2:
- 	close(drv->ioctl_sock);
-@@ -838,10 +844,12 @@ err1:
- }
- 
- 
-+#ifdef CONFIG_RFKILL
- static void wpa_driver_wext_send_rfkill(void *eloop_ctx, void *timeout_ctx)
- {
- 	wpa_supplicant_event(timeout_ctx, EVENT_INTERFACE_DISABLED, NULL);
- }
-+#endif /* CONFIG_RFKILL */
- 
- 
- static int wpa_driver_wext_finish_drv_init(struct wpa_driver_wext_data *drv)
-@@ -849,13 +857,16 @@ static int wpa_driver_wext_finish_drv_in
- 	int send_rfkill_event = 0;
- 
- 	if (linux_set_iface_flags(drv->ioctl_sock, drv->ifname, 1) < 0) {
-+#ifdef CONFIG_RFKILL
- 		if (rfkill_is_blocked(drv->rfkill)) {
- 			wpa_printf(MSG_DEBUG, "WEXT: Could not yet enable "
- 				   "interface '%s' due to rfkill",
- 				   drv->ifname);
- 			drv->if_disabled = 1;
- 			send_rfkill_event = 1;
--		} else {
-+		} else
-+#endif
-+		{
- 			wpa_printf(MSG_ERROR, "WEXT: Could not set "
- 				   "interface '%s' UP", drv->ifname);
- 			return -1;
-@@ -903,8 +914,10 @@ static int wpa_driver_wext_finish_drv_in
- 			       1, IF_OPER_DORMANT);
- 
- 	if (send_rfkill_event) {
-+#ifdef CONFIG_RFKILL
- 		eloop_register_timeout(0, 0, wpa_driver_wext_send_rfkill,
- 				       drv, drv->ctx);
-+#endif
- 	}
- 
- 	return 0;
-@@ -934,7 +947,9 @@ void wpa_driver_wext_deinit(void *priv)
- 
- 	netlink_send_oper_ifla(drv->netlink, drv->ifindex, 0, IF_OPER_UP);
- 	netlink_deinit(drv->netlink);
-+#ifdef CONFIG_RFKILL
- 	rfkill_deinit(drv->rfkill);
-+#endif
- 
- 	if (drv->mlme_sock >= 0)
- 		eloop_unregister_read_sock(drv->mlme_sock);
---- a/src/drivers/drivers.mak
-+++ b/src/drivers/drivers.mak
-@@ -43,7 +43,6 @@ NEED_SME=y
- NEED_AP_MLME=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- ifdef CONFIG_LIBNL_TINY
- DRV_LIBS += -lnl-tiny
- else
-@@ -94,7 +93,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
- CONFIG_WIRELESS_EXTENSION=y
- NEED_NETLINK=y
- NEED_LINUX_IOCTL=y
--NEED_RFKILL=y
- endif
- 
- ifdef CONFIG_DRIVER_RALINK
-@@ -146,7 +144,6 @@ endif
- ifdef CONFIG_WIRELESS_EXTENSION
- DRV_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
- DRV_OBJS += ../src/drivers/driver_wext.o
--NEED_RFKILL=y
- endif
- 
- ifdef NEED_NETLINK
-@@ -159,6 +156,7 @@ endif
- 
- ifdef NEED_RFKILL
- DRV_OBJS += ../src/drivers/rfkill.o
-+DRV_WPA_CFLAGS += -DCONFIG_RFKILL
- endif
- 
- 
---- a/src/drivers/driver_wext.h
-+++ b/src/drivers/driver_wext.h
-@@ -28,7 +28,9 @@ struct wpa_driver_wext_data {
- 	int ifindex2;
- 	int if_removed;
- 	int if_disabled;
-+#ifdef CONFIG_RFKILL
- 	struct rfkill_data *rfkill;
-+#endif
- 	u8 *assoc_req_ies;
- 	size_t assoc_req_ies_len;
- 	u8 *assoc_resp_ies;
diff --exclude .svn -Nru package/hostapd/patches/550-limit_debug_messages.patch package/hostapd/patches/550-limit_debug_messages.patch
--- package/hostapd/patches/550-limit_debug_messages.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/550-limit_debug_messages.patch	2012-08-18 14:47:30.615458002 +0200
@@ -0,0 +1,213 @@
+--- a/src/utils/wpa_debug.c
++++ b/src/utils/wpa_debug.c
+@@ -201,7 +201,7 @@ void wpa_debug_close_linux_tracing(void)
+  *
+  * Note: New line '\n' is added to the end of the text when printing to stdout.
+  */
+-void wpa_printf(int level, const char *fmt, ...)
++void _wpa_printf(int level, const char *fmt, ...)
+ {
+ 	va_list ap;
+ 
+@@ -248,8 +248,8 @@ void wpa_printf(int level, const char *f
+ }
+ 
+ 
+-static void _wpa_hexdump(int level, const char *title, const u8 *buf,
+-			 size_t len, int show)
++void _wpa_hexdump(int level, const char *title, const u8 *buf,
++		  size_t len, int show)
+ {
+ 	size_t i;
+ 
+@@ -375,20 +375,9 @@ static void _wpa_hexdump(int level, cons
+ #endif /* CONFIG_ANDROID_LOG */
+ }
+ 
+-void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
+-{
+-	_wpa_hexdump(level, title, buf, len, 1);
+-}
+-
+-
+-void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
+-{
+-	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
+-}
+ 
+-
+-static void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
+-			       size_t len, int show)
++void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
++			size_t len, int show)
+ {
+ 	size_t i, llen;
+ 	const u8 *pos = buf;
+@@ -495,19 +484,6 @@ static void _wpa_hexdump_ascii(int level
+ }
+ 
+ 
+-void wpa_hexdump_ascii(int level, const char *title, const u8 *buf, size_t len)
+-{
+-	_wpa_hexdump_ascii(level, title, buf, len, 1);
+-}
+-
+-
+-void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
+-			   size_t len)
+-{
+-	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
+-}
+-
+-
+ #ifdef CONFIG_DEBUG_FILE
+ static char *last_path = NULL;
+ #endif /* CONFIG_DEBUG_FILE */
+@@ -591,7 +567,7 @@ void wpa_msg_register_ifname_cb(wpa_msg_
+ }
+ 
+ 
+-void wpa_msg(void *ctx, int level, const char *fmt, ...)
++void _wpa_msg(void *ctx, int level, const char *fmt, ...)
+ {
+ 	va_list ap;
+ 	char *buf;
+@@ -625,7 +601,7 @@ void wpa_msg(void *ctx, int level, const
+ }
+ 
+ 
+-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
++void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
+ {
+ 	va_list ap;
+ 	char *buf;
+--- a/src/utils/wpa_debug.h
++++ b/src/utils/wpa_debug.h
+@@ -43,6 +43,17 @@ int wpa_debug_open_file(const char *path
+ int wpa_debug_reopen_file(void);
+ void wpa_debug_close_file(void);
+ 
++/* internal */
++void _wpa_hexdump(int level, const char *title, const u8 *buf,
++		  size_t len, int show);
++void _wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
++			size_t len, int show);
++extern int wpa_debug_show_keys;
++
++#ifndef CONFIG_MSG_MIN_PRIORITY
++#define CONFIG_MSG_MIN_PRIORITY 0
++#endif
++
+ /**
+  * wpa_debug_printf_timestamp - Print timestamp for debug output
+  *
+@@ -63,9 +74,15 @@ void wpa_debug_print_timestamp(void);
+  *
+  * Note: New line '\n' is added to the end of the text when printing to stdout.
+  */
+-void wpa_printf(int level, const char *fmt, ...)
++void _wpa_printf(int level, const char *fmt, ...)
+ PRINTF_FORMAT(2, 3);
+ 
++#define wpa_printf(level, ...)						\
++	do {								\
++		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
++			_wpa_printf(level, __VA_ARGS__);		\
++	} while(0)
++
+ /**
+  * wpa_hexdump - conditional hex dump
+  * @level: priority level (MSG_*) of the message
+@@ -77,7 +94,13 @@ PRINTF_FORMAT(2, 3);
+  * output may be directed to stdout, stderr, and/or syslog based on
+  * configuration. The contents of buf is printed out has hex dump.
+  */
+-void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len);
++static inline void wpa_hexdump(int level, const char *title, const u8 *buf, size_t len)
++{
++	if (level < CONFIG_MSG_MIN_PRIORITY)
++		return;
++
++	_wpa_hexdump(level, title, buf, len, 1);
++}
+ 
+ static inline void wpa_hexdump_buf(int level, const char *title,
+ 				   const struct wpabuf *buf)
+@@ -99,7 +122,13 @@ static inline void wpa_hexdump_buf(int l
+  * like wpa_hexdump(), but by default, does not include secret keys (passwords,
+  * etc.) in debug output.
+  */
+-void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len);
++static inline void wpa_hexdump_key(int level, const char *title, const u8 *buf, size_t len)
++{
++	if (level < CONFIG_MSG_MIN_PRIORITY)
++		return;
++
++	_wpa_hexdump(level, title, buf, len, wpa_debug_show_keys);
++}
+ 
+ static inline void wpa_hexdump_buf_key(int level, const char *title,
+ 				       const struct wpabuf *buf)
+@@ -121,8 +150,14 @@ static inline void wpa_hexdump_buf_key(i
+  * the hex numbers and ASCII characters (for printable range) are shown. 16
+  * bytes per line will be shown.
+  */
+-void wpa_hexdump_ascii(int level, const char *title, const u8 *buf,
+-		       size_t len);
++static inline void wpa_hexdump_ascii(int level, const char *title,
++				     const u8 *buf, size_t len)
++{
++	if (level < CONFIG_MSG_MIN_PRIORITY)
++		return;
++
++	_wpa_hexdump_ascii(level, title, buf, len, 1);
++}
+ 
+ /**
+  * wpa_hexdump_ascii_key - conditional hex dump, hide keys
+@@ -138,8 +173,14 @@ void wpa_hexdump_ascii(int level, const 
+  * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
+  * default, does not include secret keys (passwords, etc.) in debug output.
+  */
+-void wpa_hexdump_ascii_key(int level, const char *title, const u8 *buf,
+-			   size_t len);
++static inline void wpa_hexdump_ascii_key(int level, const char *title,
++					 const u8 *buf, size_t len)
++{
++	if (level < CONFIG_MSG_MIN_PRIORITY)
++		return;
++
++	_wpa_hexdump_ascii(level, title, buf, len, wpa_debug_show_keys);
++}
+ 
+ /*
+  * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
+@@ -172,7 +213,12 @@ void wpa_hexdump_ascii_key(int level, co
+  *
+  * Note: New line '\n' is added to the end of the text when printing to stdout.
+  */
+-void wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
++void _wpa_msg(void *ctx, int level, const char *fmt, ...) PRINTF_FORMAT(3, 4);
++#define wpa_msg(ctx, level, ...)					\
++	do {								\
++		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
++			_wpa_msg(ctx, level, __VA_ARGS__);		\
++	} while(0)
+ 
+ /**
+  * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
+@@ -186,8 +232,13 @@ void wpa_msg(void *ctx, int level, const
+  * attached ctrl_iface monitors. In other words, it can be used for frequent
+  * events that do not need to be sent to syslog.
+  */
+-void wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
++void _wpa_msg_ctrl(void *ctx, int level, const char *fmt, ...)
+ PRINTF_FORMAT(3, 4);
++#define wpa_msg_ctrl(ctx, level, ...)					\
++	do {								\
++		if (level >= CONFIG_MSG_MIN_PRIORITY)			\
++			_wpa_msg_ctrl(ctx, level, __VA_ARGS__);		\
++	} while(0)
+ 
+ typedef void (*wpa_msg_cb_func)(void *ctx, int level, const char *txt,
+ 				size_t len);
diff --exclude .svn -Nru package/hostapd/patches/550-reload_freq_change.patch package/hostapd/patches/550-reload_freq_change.patch
--- package/hostapd/patches/550-reload_freq_change.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/550-reload_freq_change.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -124,6 +124,10 @@ int hostapd_reload_config(struct hostapd
- 	oldconf = hapd->iconf;
- 	iface->conf = newconf;
- 
-+	iface->freq = hostapd_hw_get_freq(hapd, hapd->iconf->channel);
-+	if (iface->current_mode)
-+		hostapd_prepare_rates(hapd, iface->current_mode);
-+
- 	for (j = 0; j < iface->num_bss; j++) {
- 		hapd = iface->bss[j];
- 		hapd->iconf = newconf;
diff --exclude .svn -Nru package/hostapd/patches/551-nl80211_del_beacon_bss.patch package/hostapd/patches/551-nl80211_del_beacon_bss.patch
--- package/hostapd/patches/551-nl80211_del_beacon_bss.patch	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/patches/551-nl80211_del_beacon_bss.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,63 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -2532,22 +2532,41 @@ wpa_driver_nl80211_finish_drv_init(struc
- }
- 
- 
--static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+static int wpa_driver_nl80211_del_bss_beacon(struct i802_bss *bss)
- {
-+	struct wpa_driver_nl80211_data *drv = bss->drv;
- 	struct nl_msg *msg;
- 
-+	bss->beacon_set = 0;
- 	msg = nlmsg_alloc();
- 	if (!msg)
- 		return -ENOMEM;
- 
- 	nl80211_cmd(drv, msg, 0, NL80211_CMD_DEL_BEACON);
--	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, drv->ifindex);
-+	NLA_PUT_U32(msg, NL80211_ATTR_IFINDEX, bss->ifindex);
- 
- 	return send_and_recv_msgs(drv, msg, NULL, NULL);
-  nla_put_failure:
-+	nlmsg_free(msg);
- 	return -ENOBUFS;
- }
- 
-+static int wpa_driver_nl80211_del_beacon(struct wpa_driver_nl80211_data *drv)
-+{
-+	struct i802_bss *bss;
-+
-+	for (bss = &drv->first_bss; bss; bss = bss->next)
-+		wpa_driver_nl80211_del_bss_beacon(bss);
-+
-+	return 0;
-+}
-+
-+static int wpa_driver_nl80211_stop_ap(void *priv)
-+{
-+	struct i802_bss *bss = priv;
-+
-+	return wpa_driver_nl80211_del_beacon(bss->drv);
-+}
- 
- /**
-  * wpa_driver_nl80211_deinit - Deinitialize nl80211 driver interface
-@@ -7654,4 +7673,5 @@ const struct wpa_driver_ops wpa_driver_n
- 	.send_tdls_mgmt = nl80211_send_tdls_mgmt,
- 	.tdls_oper = nl80211_tdls_oper,
- #endif /* CONFIG_TDLS */
-+	.stop_ap = wpa_driver_nl80211_stop_ap,
- };
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -2452,6 +2452,8 @@ struct wpa_driver_ops {
- 	 */
- 	void (*poll_client)(void *priv, const u8 *own_addr,
- 			    const u8 *addr, int qos);
-+
-+	int (*stop_ap)(void *priv);
- };
- 
- 
diff --exclude .svn -Nru package/hostapd/patches/552-ctrl_iface_reload.patch package/hostapd/patches/552-ctrl_iface_reload.patch
--- package/hostapd/patches/552-ctrl_iface_reload.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/552-ctrl_iface_reload.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,96 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -39,6 +39,7 @@
- #include "wps/wps_defs.h"
- #include "wps/wps.h"
- #include "ctrl_iface.h"
-+#include "config_file.h"
- 
- 
- struct wpa_ctrl_dst {
-@@ -49,6 +50,7 @@ struct wpa_ctrl_dst {
- 	int errors;
- };
- 
-+static char *reload_opts = NULL;
- 
- static void hostapd_ctrl_iface_send(struct hostapd_data *hapd, int level,
- 				    const char *buf, size_t len);
-@@ -323,6 +325,66 @@ static int hostapd_ctrl_iface_disassocia
- 	return 0;
- }
- 
-+static int hostapd_ctrl_iface_set_down(struct hostapd_data *hapd)
-+{
-+	if (hapd->driver->stop_ap)
-+		hapd->driver->stop_ap(hapd->drv_priv);
-+	return 0;
-+}
-+
-+static char *get_option(char *opt, char *str)
-+{
-+	int len = strlen(str);
-+
-+	if (!strncmp(opt, str, len))
-+		return opt + len;
-+	else
-+		return NULL;
-+}
-+
-+static struct hostapd_config *hostapd_ctrl_iface_config_read(const char *fname)
-+{
-+	struct hostapd_config *conf;
-+	char *opt, *val;
-+
-+	conf = hostapd_config_read(fname);
-+	if (!conf)
-+		return NULL;
-+
-+	for (opt = strtok(reload_opts, " ");
-+	     opt;
-+		 opt = strtok(NULL, " ")) {
-+
-+		if ((val = get_option(opt, "channel=")))
-+			conf->channel = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab=")))
-+			conf->ht_capab = atoi(val);
-+		else if ((val = get_option(opt, "ht_capab_mask=")))
-+			conf->ht_capab &= atoi(val);
-+		else if ((val = get_option(opt, "sec_chan=")))
-+			conf->secondary_channel = atoi(val);
-+		else if ((val = get_option(opt, "hwmode=")))
-+			conf->hw_mode = atoi(val);
-+		else if ((val = get_option(opt, "ieee80211n=")))
-+			conf->ieee80211n = atoi(val);
-+		else
-+			break;
-+	}
-+
-+	return conf;
-+}
-+
-+static int hostapd_ctrl_iface_reload(struct hostapd_data *hapd, char *txt)
-+{
-+	struct hostapd_iface *iface = hapd->iface;
-+
-+	iface->config_read_cb = hostapd_ctrl_iface_config_read;
-+	reload_opts = txt;
-+
-+	hostapd_reload_config(iface);
-+
-+	iface->config_read_cb = hostapd_config_read;
-+}
- 
- #ifdef CONFIG_IEEE80211W
- #ifdef NEED_AP_MLME
-@@ -873,6 +935,10 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+	} else if (os_strcmp(buf, "DOWN") == 0) {
-+		hostapd_ctrl_iface_set_down(hapd);
-+	} else if (os_strncmp(buf, "RELOAD ", 7) == 0) {
-+		hostapd_ctrl_iface_reload(hapd, buf + 7);
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
diff --exclude .svn -Nru package/hostapd/patches/553-ap_sta_support.patch package/hostapd/patches/553-ap_sta_support.patch
--- package/hostapd/patches/553-ap_sta_support.patch	2012-08-17 15:40:41.391971000 +0200
+++ package/hostapd/patches/553-ap_sta_support.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,221 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant_i.h
-+++ b/wpa_supplicant/wpa_supplicant_i.h
-@@ -100,6 +100,8 @@ struct wpa_interface {
- 	 * receiving of EAPOL frames from an additional interface.
- 	 */
- 	const char *bridge_ifname;
-+
-+	const char *hostapd_ctrl;
- };
- 
- /**
-@@ -260,6 +262,8 @@ struct wpa_supplicant {
- #endif /* CONFIG_CTRL_IFACE_DBUS_NEW */
- 	char bridge_ifname[16];
- 
-+	struct wpa_ctrl *hostapd;
-+
- 	char *confname;
- 	struct wpa_config *conf;
- 	int countermeasures;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -13,6 +13,10 @@ PKG_CONFIG ?= pkg-config
- CFLAGS += -I../src
- CFLAGS += -I../src/utils
- 
-+ifdef MULTICALL
-+CFLAGS += -DMULTICALL
-+endif
-+
- -include .config
- -include $(if $(MULTICALL),../hostapd/.config)
- 
-@@ -69,6 +73,10 @@ OBJS_c = wpa_cli.o ../src/common/wpa_ctr
- OBJS_c += ../src/utils/wpa_debug.o
- OBJS_c += ../src/utils/common.o
- 
-+ifdef MULTICALL
-+OBJS += ../src/common/wpa_ctrl.o
-+endif
-+
- ifndef CONFIG_OS
- ifdef CONFIG_NATIVE_WINDOWS
- CONFIG_OS=win32
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -125,6 +125,55 @@ extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
- extern struct wpa_driver_ops *wpa_drivers[];
- 
-+#ifdef MULTICALL
-+static int hostapd_stop(struct wpa_supplicant *wpa_s)
-+{
-+	const char *cmd = "DOWN";
-+	char buf[256];
-+	int len = sizeof(buf);
-+
-+	if (wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL) < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to stop hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+
-+static int hostapd_reload(struct wpa_supplicant *wpa_s, struct wpa_bss *bss)
-+{
-+	char *cmd = NULL;
-+	char buf[256];
-+	int len = sizeof(buf);
-+	int channel, hw_mode;
-+	int ret;
-+
-+	if (!bss)
-+		return;
-+
-+	if (bss->freq < 4000) {
-+		hw_mode = HOSTAPD_MODE_IEEE80211G;
-+		channel = (bss->freq - 2407) / 5;
-+	} else {
-+		hw_mode = HOSTAPD_MODE_IEEE80211A;
-+		channel = (bss->freq - 5000) / 5;
-+	}
-+
-+	if (asprintf(&cmd, "RELOAD channel=%d sec_chan=0 hw_mode=%d ieee80211n=%d",
-+		     channel, hw_mode, !!bss->ht_capab) < 0) {
-+		return -1;
-+	}
-+
-+	ret = wpa_ctrl_request(wpa_s->hostapd, cmd, os_strlen(cmd), buf, &len, NULL);
-+	free(cmd);
-+
-+	if (ret < 0) {
-+		wpa_printf(MSG_ERROR, "\nFailed to reload hostapd AP interfaces\n");
-+		return -1;
-+	}
-+	return 0;
-+}
-+#endif
-+
- /* Configure default/group WEP keys for static WEP */
- int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
- {
-@@ -632,8 +681,16 @@ void wpa_supplicant_set_state(struct wpa
- #ifdef CONFIG_P2P
- 		wpas_p2p_completed(wpa_s);
- #endif /* CONFIG_P2P */
-+#ifdef MULTICALL
-+		if (wpa_s->hostapd)
-+			hostapd_reload(wpa_s, wpa_s->current_bss);
-+#endif
- 	} else if (state == WPA_DISCONNECTED || state == WPA_ASSOCIATING ||
- 		   state == WPA_ASSOCIATED) {
-+#ifdef MULTICALL
-+		if (wpa_s->hostapd)
-+			hostapd_stop(wpa_s);
-+#endif
- 		wpa_s->new_connection = 1;
- 		wpa_drv_set_operstate(wpa_s, 0);
- #ifndef IEEE8021X_EAPOL
-@@ -2245,6 +2302,21 @@ static int wpa_supplicant_init_iface(str
- 		os_strlcpy(wpa_s->bridge_ifname, iface->bridge_ifname,
- 			   sizeof(wpa_s->bridge_ifname));
- 	}
-+#ifdef MULTICALL
-+	if (iface->hostapd_ctrl) {
-+		char *cmd = "DOWN";
-+		char buf[256];
-+		int len = sizeof(buf);
-+
-+		wpa_s->hostapd = wpa_ctrl_open(iface->hostapd_ctrl);
-+		if (!wpa_s->hostapd) {
-+			wpa_printf(MSG_ERROR, "\nFailed to connect to hostapd\n");
-+			return -1;
-+		}
-+		if (hostapd_stop(wpa_s) < 0)
-+			return -1;
-+	}
-+#endif
- 
- 	/* RSNA Supplicant Key Management - INITIALIZE */
- 	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
---- a/wpa_supplicant/bss.c
-+++ b/wpa_supplicant/bss.c
-@@ -17,6 +17,7 @@
- #include "utils/common.h"
- #include "utils/eloop.h"
- #include "common/ieee802_11_defs.h"
-+#include "common/ieee802_11_common.h"
- #include "drivers/driver.h"
- #include "wpa_supplicant_i.h"
- #include "config.h"
-@@ -79,6 +80,8 @@ struct wpa_bss * wpa_bss_get(struct wpa_
- 
- static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src)
- {
-+	struct ieee80211_ht_capabilities *capab;
-+	struct ieee802_11_elems elems;
- 	os_time_t usec;
- 
- 	dst->flags = src->flags;
-@@ -91,6 +94,12 @@ static void wpa_bss_copy_res(struct wpa_
- 	dst->level = src->level;
- 	dst->tsf = src->tsf;
- 
-+	memset(&elems, 0, sizeof(elems));
-+	ieee802_11_parse_elems((u8 *) (src + 1), src->ie_len, &elems, 0);
-+	capab = (struct ieee80211_ht_capabilities *) elems.ht_capabilities;
-+	if (capab)
-+		dst->ht_capab = le_to_host16(capab->ht_capabilities_info);
-+
- 	os_get_time(&dst->last_update);
- 	dst->last_update.sec -= src->age / 1000;
- 	usec = (src->age % 1000) * 1000;
---- a/wpa_supplicant/bss.h
-+++ b/wpa_supplicant/bss.h
-@@ -57,6 +57,7 @@ struct wpa_bss {
- 	unsigned int flags;
- 	u8 bssid[ETH_ALEN];
- 	u8 ssid[32];
-+	u16 ht_capab;
- 	size_t ssid_len;
- 	int freq;
- 	u16 beacon_int;
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -31,7 +31,7 @@ static void usage(void)
- 	       "usage:\n"
- 	       "  wpa_supplicant [-BddhKLqqstuvW] [-P<pid file>] "
- 	       "[-g<global ctrl>] \\\n"
--	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] "
-+	       "        -i<ifname> -c<config file> [-C<ctrl>] [-D<driver>] [-H<hostapd path>]"
- 	       "[-p<driver_param>] \\\n"
- 	       "        [-b<br_ifname>] [-f<debug file>] [-e<entropy file>] "
- 	       "\\\n"
-@@ -69,6 +69,7 @@ static void usage(void)
- #endif /* CONFIG_DEBUG_SYSLOG */
- 	printf("  -t = include timestamp in debug messages\n"
- 	       "  -h = show this help text\n"
-+		   "  -H = connect to a hostapd instance to manage state changes\n"
- 	       "  -L = show license (GPL and BSD)\n"
- 	       "  -o = override driver parameter for new interfaces\n"
- 	       "  -O = override ctrl_interface parameter for new interfaces\n"
-@@ -145,7 +146,7 @@ int main(int argc, char *argv[])
- 	wpa_supplicant_fd_workaround();
- 
- 	for (;;) {
--		c = getopt(argc, argv, "b:Bc:C:D:de:f:g:hi:KLNo:O:p:P:qstuvW");
-+		c = getopt(argc, argv, "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qstuvW");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -189,6 +190,9 @@ int main(int argc, char *argv[])
- 			usage();
- 			exitcode = 0;
- 			goto out;
-+		case 'H':
-+			iface->hostapd_ctrl = optarg;
-+			break;
- 		case 'i':
- 			iface->ifname = optarg;
- 			break;
diff --exclude .svn -Nru package/hostapd/patches/560-disable_ctrl_iface_mib.patch package/hostapd/patches/560-disable_ctrl_iface_mib.patch
--- package/hostapd/patches/560-disable_ctrl_iface_mib.patch	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/patches/560-disable_ctrl_iface_mib.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,161 +0,0 @@
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -128,6 +128,9 @@ endif
- ifdef CONFIG_NO_CTRL_IFACE
- CFLAGS += -DCONFIG_NO_CTRL_IFACE
- else
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ctrl_iface.o
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -906,6 +906,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "RELOG", 5) == 0) {
- 		if (wpa_debug_reopen_file() < 0)
- 			reply_len = -1;
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -935,10 +936,12 @@ static void hostapd_ctrl_iface_receive(i
- 				reply_len += res;
- 		}
- #endif /* CONFIG_NO_RADIUS */
-+#endif
- 	} else if (os_strcmp(buf, "DOWN") == 0) {
- 		hostapd_ctrl_iface_set_down(hapd);
- 	} else if (os_strncmp(buf, "RELOAD ", 7) == 0) {
- 		hostapd_ctrl_iface_reload(hapd, buf + 7);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_first(hapd, reply,
- 							 reply_size);
-@@ -948,6 +951,7 @@ static void hostapd_ctrl_iface_receive(i
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
- 							reply_size);
-+#endif
- 	} else if (os_strcmp(buf, "ATTACH") == 0) {
- 		if (hostapd_ctrl_iface_attach(hapd, &from, fromlen))
- 			reply_len = -1;
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -709,6 +709,9 @@ ifdef CONFIG_IEEE80211N
- OBJS += ../src/ap/ieee802_11_ht.o
- endif
- ifdef CONFIG_CTRL_IFACE
-+ifdef CONFIG_CTRL_IFACE_MIB
-+CFLAGS += -DCONFIG_CTRL_IFACE_MIB
-+endif
- OBJS += ../src/ap/ctrl_iface_ap.o
- endif
- 
---- a/wpa_supplicant/ctrl_iface.c
-+++ b/wpa_supplicant/ctrl_iface.c
-@@ -3231,6 +3231,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			reply_len = -1;
- 	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
- 		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "MIB") == 0) {
- 		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
- 		if (reply_len >= 0) {
-@@ -3242,6 +3243,7 @@ char * wpa_supplicant_ctrl_iface_process
- 			else
- 				reply_len += res;
- 		}
-+#endif
- 	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
- 		reply_len = wpa_supplicant_ctrl_iface_status(
- 			wpa_s, buf + 6, reply, reply_size);
-@@ -3570,6 +3572,7 @@ char * wpa_supplicant_ctrl_iface_process
- 		reply_len = wpa_supplicant_ctrl_iface_bss(
- 			wpa_s, buf + 4, reply, reply_size);
- #ifdef CONFIG_AP
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
- 		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
- 	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -3578,6 +3581,7 @@ char * wpa_supplicant_ctrl_iface_process
- 	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
- 		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
- 						   reply_size);
-+#endif
- #endif /* CONFIG_AP */
- 	} else if (os_strcmp(buf, "SUSPEND") == 0) {
- 		wpas_notify_suspend(wpa_s->global);
---- a/src/ap/ctrl_iface_ap.c
-+++ b/src/ap/ctrl_iface_ap.c
-@@ -24,6 +24,7 @@
- #include "p2p_hostapd.h"
- #include "ctrl_iface_ap.h"
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- static int hostapd_ctrl_iface_sta_mib(struct hostapd_data *hapd,
- 				      struct sta_info *sta,
-@@ -106,3 +107,5 @@ int hostapd_ctrl_iface_sta_next(struct h
- 	}		
- 	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
- }
-+
-+#endif
---- a/src/ap/ieee802_1x.c
-+++ b/src/ap/ieee802_1x.c
-@@ -1926,6 +1926,7 @@ static const char * bool_txt(Boolean boo
- 	return bool ? "TRUE" : "FALSE";
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
- {
-@@ -2078,6 +2079,7 @@ int ieee802_1x_get_mib_sta(struct hostap
- 	return len;
- }
- 
-+#endif
- 
- static void ieee802_1x_finished(struct hostapd_data *hapd,
- 				struct sta_info *sta, int success)
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -2534,6 +2534,7 @@ static int wpa_cipher_bits(int cipher)
- 	}
- }
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
- 
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
-@@ -2697,7 +2698,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
- 
- 	return len;
- }
--
-+#endif
- 
- void wpa_auth_countermeasures_start(struct wpa_authenticator *wpa_auth)
- {
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -1919,6 +1919,8 @@ static u32 wpa_cipher_suite(struct wpa_s
- }
- 
- 
-+#ifdef CONFIG_CTRL_IFACE_MIB
-+
- #define RSN_SUITE "%02x-%02x-%02x-%d"
- #define RSN_SUITE_ARG(s) \
- ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -1998,6 +2000,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
- 
- 	return (int) len;
- }
-+#endif
- #endif /* CONFIG_CTRL_IFACE */
- 
- 
diff --exclude .svn -Nru package/hostapd/patches/560-indicate-features.patch package/hostapd/patches/560-indicate-features.patch
--- package/hostapd/patches/560-indicate-features.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/560-indicate-features.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,82 @@
+--- a/hostapd/main.c
++++ b/hostapd/main.c
+@@ -13,6 +13,7 @@
+ 
+ #include "utils/common.h"
+ #include "utils/eloop.h"
++#include "utils/build_features.h"
+ #include "crypto/random.h"
+ #include "crypto/tls.h"
+ #include "common/version.h"
+@@ -560,7 +561,7 @@ int main(int argc, char *argv[])
+ 
+ 	wpa_supplicant_event = hostapd_wpa_event;
+ 	for (;;) {
+-		c = getopt(argc, argv, "Bde:f:hKP:tvg:");
++		c = getopt(argc, argv, "Bde:f:hKP:tg:v::");
+ 		if (c < 0)
+ 			break;
+ 		switch (c) {
+@@ -592,6 +593,8 @@ int main(int argc, char *argv[])
+ 			wpa_debug_timestamp++;
+ 			break;
+ 		case 'v':
++			if (optarg)
++				exit(!has_feature(optarg));
+ 			show_version();
+ 			exit(1);
+ 			break;
+--- a/wpa_supplicant/main.c
++++ b/wpa_supplicant/main.c
+@@ -12,6 +12,7 @@
+ #endif /* __linux__ */
+ 
+ #include "common.h"
++#include "build_features.h"
+ #include "wpa_supplicant_i.h"
+ #include "driver_i.h"
+ 
+@@ -156,7 +157,7 @@ int main(int argc, char *argv[])
+ 
+ 	for (;;) {
+ 		c = getopt(argc, argv,
+-			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuvW");
++			   "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qsTtuv::W");
+ 		if (c < 0)
+ 			break;
+ 		switch (c) {
+@@ -248,8 +249,12 @@ int main(int argc, char *argv[])
+ 			break;
+ #endif /* CONFIG_DBUS */
+ 		case 'v':
+-			printf("%s\n", wpa_supplicant_version);
+-			exitcode = 0;
++			if (optarg) {
++				exitcode = !has_feature(optarg);
++			} else {
++				printf("%s\n", wpa_supplicant_version);
++				exitcode = 0;
++			}
+ 			goto out;
+ 		case 'W':
+ 			params.wait_for_monitor++;
+--- /dev/null
++++ b/src/utils/build_features.h
+@@ -0,0 +1,17 @@
++#ifndef BUILD_FEATURES_H
++#define BUILD_FEATURES_H
++
++static inline int has_feature(const char *feat)
++{
++#ifdef IEEE8021X_EAPOL
++	if (!strcmp(feat, "eap"))
++		return 1;
++#endif
++#ifdef IEEE80211N
++	if (!strcmp(feat, "11n"))
++		return 1;
++#endif
++	return 0;
++}
++
++#endif /* BUILD_FEATURES_H */
diff --exclude .svn -Nru package/hostapd/patches/570-genl_connect_debug.patch package/hostapd/patches/570-genl_connect_debug.patch
--- package/hostapd/patches/570-genl_connect_debug.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/570-genl_connect_debug.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,11 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -127,7 +127,7 @@ static struct nl_handle * nl_create_hand
+ 	}
+ 
+ 	if (genl_connect(handle)) {
+-		wpa_printf(MSG_ERROR, "nl80211: Failed to connect to generic "
++		wpa_printf(MSG_DEBUG, "nl80211: Failed to connect to generic "
+ 			   "netlink (%s)", dbg);
+ 		nl80211_handle_destroy(handle);
+ 		return NULL;
diff --exclude .svn -Nru package/hostapd/patches/570-wpa_ie_cap_workaround.patch package/hostapd/patches/570-wpa_ie_cap_workaround.patch
--- package/hostapd/patches/570-wpa_ie_cap_workaround.patch	2012-08-17 15:40:41.391971000 +0200
+++ package/hostapd/patches/570-wpa_ie_cap_workaround.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,56 +0,0 @@
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -959,6 +959,31 @@ const char * wpa_key_mgmt_txt(int key_mg
- }
- 
- 
-+static void wpa_fixup_wpa_ie_rsn(u8 *assoc_ie, const u8 *wpa_msg_ie,
-+				 size_t rsn_ie_len)
-+{
-+	int pos, count;
-+
-+	pos = sizeof(struct rsn_ie_hdr) + RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	count = WPA_GET_LE16(wpa_msg_ie + pos);
-+	pos += 2 + count * RSN_SELECTOR_LEN;
-+	if (rsn_ie_len < pos + 2)
-+		return;
-+
-+	if (!assoc_ie[pos] && !assoc_ie[pos + 1] &&
-+	    (wpa_msg_ie[pos] || wpa_msg_ie[pos + 1]))
-+		memcpy(&assoc_ie[pos], &wpa_msg_ie[pos], 2);
-+}
-+
-+
- int wpa_compare_rsn_ie(int ft_initial_assoc,
- 		       const u8 *ie1, size_t ie1len,
- 		       const u8 *ie2, size_t ie2len)
-@@ -966,8 +991,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
- 	if (ie1 == NULL || ie2 == NULL)
- 		return -1;
- 
--	if (ie1len == ie2len && os_memcmp(ie1, ie2, ie1len) == 0)
--		return 0; /* identical IEs */
-+	if (ie1len == ie2len) {
-+		u8 *ie_tmp;
-+
-+		if (os_memcmp(ie1, ie2, ie1len) == 0)
-+			return 0; /* identical IEs */
-+
-+		ie_tmp = alloca(ie1len);
-+		memcpy(ie_tmp, ie1, ie1len);
-+		wpa_fixup_wpa_ie_rsn(ie_tmp, ie2, ie1len);
-+
-+		if (os_memcmp(ie_tmp, ie2, ie1len) == 0)
-+			return 0; /* only mismatch in RSN capabilties */
-+	}
- 
- #ifdef CONFIG_IEEE80211R
- 	if (ft_initial_assoc) {
diff --exclude .svn -Nru package/hostapd/patches/580-fix_bss_addr.patch package/hostapd/patches/580-fix_bss_addr.patch
--- package/hostapd/patches/580-fix_bss_addr.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/580-fix_bss_addr.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,11 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -7738,7 +7738,7 @@ static int i802_set_wds_sta(void *priv, 
+ 		if (!if_nametoindex(name)) {
+ 			if (nl80211_create_iface(drv, name,
+ 						 NL80211_IFTYPE_AP_VLAN,
+-						 NULL, 1) < 0)
++						 bss->addr, 1) < 0)
+ 				return -1;
+ 			if (bridge_ifname &&
+ 			    linux_br_add_if(drv->global->ioctl_sock,
diff --exclude .svn -Nru package/hostapd/patches/590-hostapd_cli_ifdef.patch package/hostapd/patches/590-hostapd_cli_ifdef.patch
--- package/hostapd/patches/590-hostapd_cli_ifdef.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/590-hostapd_cli_ifdef.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,50 @@
+--- a/hostapd/hostapd_cli.c
++++ b/hostapd/hostapd_cli.c
+@@ -67,7 +67,6 @@ static const char *commands_help =
+ #ifdef CONFIG_IEEE80211W
+ "   sa_query <addr>      send SA Query to a station\n"
+ #endif /* CONFIG_IEEE80211W */
+-#ifdef CONFIG_WPS
+ "   wps_pin <uuid> <pin> [timeout] [addr]  add WPS Enrollee PIN\n"
+ "   wps_check_pin <PIN>  verify PIN checksum\n"
+ "   wps_pbc              indicate button pushed to initiate PBC\n"
+@@ -82,7 +81,6 @@ static const char *commands_help =
+ #endif /* CONFIG_WPS_NFC */
+ "   wps_ap_pin <cmd> [params..]  enable/disable AP PIN\n"
+ "   wps_config <SSID> <auth> <encr> <key>  configure AP\n"
+-#endif /* CONFIG_WPS */
+ "   get_config           show current configuration\n"
+ "   help                 show this usage help\n"
+ "   interface [ifname]   show interfaces/select interface\n"
+@@ -343,7 +341,6 @@ static int hostapd_cli_cmd_sa_query(stru
+ #endif /* CONFIG_IEEE80211W */
+ 
+ 
+-#ifdef CONFIG_WPS
+ static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
+ 				   char *argv[])
+ {
+@@ -573,7 +570,6 @@ static int hostapd_cli_cmd_wps_config(st
+ 			 ssid_hex, argv[1]);
+ 	return wpa_ctrl_command(ctrl, buf);
+ }
+-#endif /* CONFIG_WPS */
+ 
+ 
+ static int hostapd_cli_cmd_ess_disassoc(struct wpa_ctrl *ctrl, int argc,
+@@ -799,7 +795,6 @@ static struct hostapd_cli_cmd hostapd_cl
+ #ifdef CONFIG_IEEE80211W
+ 	{ "sa_query", hostapd_cli_cmd_sa_query },
+ #endif /* CONFIG_IEEE80211W */
+-#ifdef CONFIG_WPS
+ 	{ "wps_pin", hostapd_cli_cmd_wps_pin },
+ 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin },
+ 	{ "wps_pbc", hostapd_cli_cmd_wps_pbc },
+@@ -814,7 +809,6 @@ static struct hostapd_cli_cmd hostapd_cl
+ #endif /* CONFIG_WPS_NFC */
+ 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
+ 	{ "wps_config", hostapd_cli_cmd_wps_config },
+-#endif /* CONFIG_WPS */
+ 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
+ 	{ "get_config", hostapd_cli_cmd_get_config },
+ 	{ "help", hostapd_cli_cmd_help },
diff --exclude .svn -Nru package/hostapd/patches/600-terminate_on_setup_failure.patch package/hostapd/patches/600-terminate_on_setup_failure.patch
--- package/hostapd/patches/600-terminate_on_setup_failure.patch	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/patches/600-terminate_on_setup_failure.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,81 +0,0 @@
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -720,11 +720,8 @@ int hostapd_setup_interface_complete(str
- 	size_t j;
- 	u8 *prev_addr;
- 
--	if (err) {
--		wpa_printf(MSG_ERROR, "Interface initialization failed");
--		eloop_terminate();
--		return -1;
--	}
-+	if (err)
-+		goto error;
- 
- 	wpa_printf(MSG_DEBUG, "Completing interface initialization");
- 	if (hapd->iconf->channel) {
-@@ -740,7 +737,7 @@ int hostapd_setup_interface_complete(str
- 				     hapd->iconf->secondary_channel)) {
- 			wpa_printf(MSG_ERROR, "Could not set channel for "
- 				   "kernel driver");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -751,7 +748,7 @@ int hostapd_setup_interface_complete(str
- 			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
- 				       HOSTAPD_LEVEL_WARNING,
- 				       "Failed to prepare rates table.");
--			return -1;
-+			goto error;
- 		}
- 	}
- 
-@@ -759,14 +756,14 @@ int hostapd_setup_interface_complete(str
- 	    hostapd_set_rts(hapd, hapd->iconf->rts_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set RTS threshold for "
- 			   "kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	if (hapd->iconf->fragm_threshold > -1 &&
- 	    hostapd_set_frag(hapd, hapd->iconf->fragm_threshold)) {
- 		wpa_printf(MSG_ERROR, "Could not set fragmentation threshold "
- 			   "for kernel driver");
--		return -1;
-+		goto error;
- 	}
- 
- 	prev_addr = hapd->own_addr;
-@@ -776,7 +773,7 @@ int hostapd_setup_interface_complete(str
- 		if (j)
- 			os_memcpy(hapd->own_addr, prev_addr, ETH_ALEN);
- 		if (hostapd_setup_bss(hapd, j == 0))
--			return -1;
-+			goto error;
- 		if (hostapd_mac_comp_empty(hapd->conf->bssid) == 0)
- 			prev_addr = hapd->own_addr;
- 	}
-@@ -788,7 +785,7 @@ int hostapd_setup_interface_complete(str
- 	if (hostapd_driver_commit(hapd) < 0) {
- 		wpa_printf(MSG_ERROR, "%s: Failed to commit driver "
- 			   "configuration", __func__);
--		return -1;
-+		goto error;
- 	}
- 
- 	/*
-@@ -812,6 +809,11 @@ int hostapd_setup_interface_complete(str
- 		iface->init_complete(iface);
- 
- 	return 0;
-+
-+error:
-+	wpa_printf(MSG_ERROR, "Interface initialization failed");
-+	eloop_terminate();
-+	return -1;
- }
- 
- 
diff --exclude .svn -Nru package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch
--- package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/601-wpa_supplicant-add-new-config-params-to-be-used-with.patch	2012-09-30 10:13:29.650734001 +0200
@@ -0,0 +1,211 @@
+From 4bb69d15477e0f2b00e166845341dc933de47c58 Mon Sep 17 00:00:00 2001
+From: Antonio Quartulli <ordex@autistici.org>
+Date: Sun, 3 Jun 2012 18:22:56 +0200
+Subject: [PATCHv2 601/602] wpa_supplicant: add new config params to be used
+ with the ibss join command
+
+Signed-hostap: Antonio Quartulli <ordex@autistici.org>
+---
+ src/drivers/driver.h            |    6 +++
+ wpa_supplicant/config.c         |   96 +++++++++++++++++++++++++++++++++++++++
+ wpa_supplicant/config_ssid.h    |    6 +++
+ wpa_supplicant/wpa_supplicant.c |   23 +++++++---
+ 4 files changed, 124 insertions(+), 7 deletions(-)
+
+--- a/src/drivers/driver.h
++++ b/src/drivers/driver.h
+@@ -19,6 +19,7 @@
+ 
+ #define WPA_SUPPLICANT_DRIVER_VERSION 4
+ 
++#include "drivers/nl80211_copy.h"
+ #include "common/defs.h"
+ 
+ #define HOSTAPD_CHAN_DISABLED 0x00000001
+@@ -351,6 +352,11 @@ struct wpa_driver_associate_params {
+ 	 */
+ 	int freq;
+ 
++	int beacon_interval;
++	int fixed_freq;
++	unsigned char rates[NL80211_MAX_SUPP_RATES];
++	int mcast_rate;
++
+ 	/**
+ 	 * bg_scan_period - Background scan period in seconds, 0 to disable
+ 	 * background scan, or -1 to indicate no change to default driver
+--- a/wpa_supplicant/config.c
++++ b/wpa_supplicant/config.c
+@@ -14,6 +14,7 @@
+ #include "rsn_supp/wpa.h"
+ #include "eap_peer/eap.h"
+ #include "p2p/p2p.h"
++#include "drivers/nl80211_copy.h"
+ #include "config.h"
+ 
+ 
+@@ -1463,6 +1464,97 @@ static char * wpa_config_write_p2p_clien
+ 
+ #endif /* CONFIG_P2P */
+ 
++static int wpa_config_parse_mcast_rate(const struct parse_data *data,
++				       struct wpa_ssid *ssid, int line,
++				       const char *value)
++{
++	ssid->mcast_rate = (int)(strtod(value, NULL) * 10);
++
++	return 0;
++}
++
++#ifndef NO_CONFIG_WRITE
++static char * wpa_config_write_mcast_rate(const struct parse_data *data,
++					  struct wpa_ssid *ssid)
++{
++	char *value;
++	int res;
++
++	if (!ssid->mcast_rate == 0)
++		return NULL;
++
++	value = os_malloc(6); /* longest: 300.0 */
++	if (value == NULL)
++		return NULL;
++	res = os_snprintf(value, 5, "%.1f", (double)ssid->mcast_rate / 10);
++	if (res < 0) {
++		os_free(value);
++		return NULL;
++	}
++	return value;
++}
++#endif /* NO_CONFIG_WRITE */
++
++static int wpa_config_parse_rates(const struct parse_data *data,
++				  struct wpa_ssid *ssid, int line,
++				  const char *value)
++{
++	int i;
++	char *pos, *r, *sptr, *end;
++	double rate;
++
++	pos = (char *)value;
++	r = strtok_r(pos, ",", &sptr);
++	i = 0;
++	while (pos && i < NL80211_MAX_SUPP_RATES) {
++		rate = 0.0;
++		if (r)
++			rate = strtod(r, &end);
++		ssid->rates[i] = rate * 2;
++		if (*end != '\0' || rate * 2 != ssid->rates[i])
++			return 1;
++
++		i++;
++		r = strtok_r(NULL, ",", &sptr);
++	}
++
++	return 0;
++}
++
++#ifndef NO_CONFIG_WRITE
++static char * wpa_config_write_rates(const struct parse_data *data,
++				     struct wpa_ssid *ssid)
++{
++	char *value, *pos;
++	int res, i;
++
++	if (ssid->rates[0] <= 0)
++		return NULL;
++
++	value = os_malloc(6 * NL80211_MAX_SUPP_RATES + 1);
++	if (value == NULL)
++		return NULL;
++	pos = value;
++	for (i = 0; i < NL80211_MAX_SUPP_RATES - 1; i++) {
++		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
++		if (res < 0) {
++			os_free(value);
++			return NULL;
++		}
++		pos += res;
++	}
++	res = os_snprintf(pos, 6, "%.1f",
++			  (double)ssid->rates[NL80211_MAX_SUPP_RATES - 1] / 2);
++	if (res < 0) {
++		os_free(value);
++		return NULL;
++	}
++
++	value[6 * NL80211_MAX_SUPP_RATES] = '\0';
++	return value;
++}
++#endif /* NO_CONFIG_WRITE */
++
+ /* Helper macros for network block parser */
+ 
+ #ifdef OFFSET
+@@ -1638,6 +1730,10 @@ static const struct parse_data ssid_fiel
+ #endif /* CONFIG_HT_OVERRIDES */
+ 	{ INT(ap_max_inactivity) },
+ 	{ INT(dtim_period) },
++	{ INT_RANGE(fixed_freq, 0, 1) },
++	{ INT_RANGE(beacon_interval, 0, 1000) },
++	{ FUNC(rates) },
++	{ FUNC(mcast_rate) },
+ };
+ 
+ #undef OFFSET
+--- a/wpa_supplicant/config_ssid.h
++++ b/wpa_supplicant/config_ssid.h
+@@ -11,6 +11,7 @@
+ 
+ #include "common/defs.h"
+ #include "eap_peer/eap_config.h"
++#include "drivers/nl80211_copy.h"
+ 
+ #define MAX_SSID_LEN 32
+ 
+@@ -529,6 +530,11 @@ struct wpa_ssid {
+ 	 * disabled_until - Network block disabled until this time if non-zero
+ 	 */
+ 	struct os_time disabled_until;
++
++	int fixed_freq;
++	int beacon_interval;
++	unsigned char rates[NL80211_MAX_SUPP_RATES];
++	double mcast_rate;
+ };
+ 
+ #endif /* CONFIG_SSID_H */
+--- a/wpa_supplicant/wpa_supplicant.c
++++ b/wpa_supplicant/wpa_supplicant.c
+@@ -1561,15 +1561,24 @@ void wpa_supplicant_associate(struct wpa
+ 		params.ssid_len = ssid->ssid_len;
+ 	}
+ 
+-	if (ssid->mode == WPAS_MODE_IBSS && ssid->bssid_set &&
+-	    wpa_s->conf->ap_scan == 2) {
+-		params.bssid = ssid->bssid;
+-		params.fixed_bssid = 1;
++	if (ssid->mode == WPAS_MODE_IBSS) {
++		if (ssid->bssid_set && wpa_s->conf->ap_scan == 2) {
++			params.bssid = ssid->bssid;
++			params.fixed_bssid = 1;
++		}
++		if (ssid->frequency > 0 && params.freq == 0)
++			/* Initial channel for IBSS */
++			params.freq = ssid->frequency;
++		params.fixed_freq = ssid->fixed_freq;
++		params.beacon_interval = ssid->beacon_interval;
++		i = 0;
++		while (i < NL80211_MAX_SUPP_RATES) {
++			params.rates[i] = ssid->rates[i];
++			i++;
++		}
++		params.mcast_rate = ssid->mcast_rate;
+ 	}
+ 
+-	if (ssid->mode == WPAS_MODE_IBSS && ssid->frequency > 0 &&
+-	    params.freq == 0)
+-		params.freq = ssid->frequency; /* Initial channel for IBSS */
+ 	params.wpa_ie = wpa_ie;
+ 	params.wpa_ie_len = wpa_ie_len;
+ 	params.pairwise_suite = cipher_pairwise;
diff --exclude .svn -Nru package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch
--- package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/602-driver_nl80211-use-new-parameters-during-ibss-join.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,59 @@
+From ffc4445958a3ed4064f2e1bf73fa478a61c5cf7b Mon Sep 17 00:00:00 2001
+From: Antonio Quartulli <ordex@autistici.org>
+Date: Sun, 3 Jun 2012 18:42:25 +0200
+Subject: [PATCHv2 602/602] driver_nl80211: use new parameters during ibss join
+
+Signed-hostap: Antonio Quartulli <ordex@autistici.org>
+---
+ src/drivers/driver_nl80211.c |   33 ++++++++++++++++++++++++++++++++-
+ 1 file changed, 32 insertions(+), 1 deletion(-)
+
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -6587,7 +6587,7 @@ static int wpa_driver_nl80211_ibss(struc
+ 				   struct wpa_driver_associate_params *params)
+ {
+ 	struct nl_msg *msg;
+-	int ret = -1;
++	int ret = -1, i;
+ 	int count = 0;
+ 
+ 	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
+@@ -6620,6 +6620,37 @@ retry:
+ 	wpa_printf(MSG_DEBUG, "  * freq=%d", params->freq);
+ 	NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_FREQ, params->freq);
+ 
++	if (params->fixed_freq) {
++		wpa_printf(MSG_DEBUG, "  * fixed_freq");
++		NLA_PUT_FLAG(msg, NL80211_ATTR_FREQ_FIXED);
++	}
++
++	if (params->beacon_interval > 0) {
++		wpa_printf(MSG_DEBUG, "  * beacon_interval=%d",
++			   params->beacon_interval);
++		NLA_PUT_U32(msg, NL80211_ATTR_BEACON_INTERVAL,
++			    params->beacon_interval);
++	}
++
++	if (params->rates[0] > 0) {
++		wpa_printf(MSG_DEBUG, "  * basic_rates:");
++		i = 0;
++		while (i < NL80211_MAX_SUPP_RATES &&
++		       params->rates[i] > 0) {
++			wpa_printf(MSG_DEBUG, "    %.1f",
++				   (double)params->rates[i] / 2);
++			i++;
++		}
++		NLA_PUT(msg, NL80211_ATTR_BSS_BASIC_RATES, i,
++			params->rates);
++	}
++
++	if (params->mcast_rate > 0) {
++		wpa_printf(MSG_DEBUG, "  * mcast_rates=%.1f",
++			   (double)params->mcast_rate / 10);
++		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
++	}
++
+ 	ret = nl80211_set_conn_keys(params, msg);
+ 	if (ret)
+ 		goto nla_put_failure;
diff --exclude .svn -Nru package/hostapd/patches/604-wpa_s-support-htmode-param.patch package/hostapd/patches/604-wpa_s-support-htmode-param.patch
--- package/hostapd/patches/604-wpa_s-support-htmode-param.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/604-wpa_s-support-htmode-param.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,156 @@
+From b9329c5dfeed7d5c55d2117d8dfe326fc40c8fb1 Mon Sep 17 00:00:00 2001
+From: Antonio Quartulli <ordex@autistici.org>
+Date: Tue, 3 Jul 2012 00:36:24 +0200
+Subject: [PATCH] wpa_s: support htmode param
+
+possible values are HT20, HT40-, HT40+ and NOHT
+
+Signed-off-by: Antonio Quartulli <ordex@autistici.org>
+---
+ src/drivers/driver.h            |    2 ++
+ src/drivers/driver_nl80211.c    |   16 ++++++++++
+ wpa_supplicant/config.c         |   66 +++++++++++++++++++++++++++++++++++++++
+ wpa_supplicant/config_ssid.h    |    2 ++
+ wpa_supplicant/wpa_supplicant.c |    2 ++
+ 5 files changed, 88 insertions(+)
+
+--- a/src/drivers/driver.h
++++ b/src/drivers/driver.h
+@@ -356,6 +356,8 @@ struct wpa_driver_associate_params {
+ 	int fixed_freq;
+ 	unsigned char rates[NL80211_MAX_SUPP_RATES];
+ 	int mcast_rate;
++	int ht_set;
++	unsigned int htmode;
+ 
+ 	/**
+ 	 * bg_scan_period - Background scan period in seconds, 0 to disable
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -6651,6 +6651,22 @@ retry:
+ 		NLA_PUT_U32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
+ 	}
+ 
++	if (params->ht_set) {
++		switch(params->htmode) {
++			case NL80211_CHAN_HT20:
++				wpa_printf(MSG_DEBUG, "  * ht=HT20");
++				break;
++			case NL80211_CHAN_HT40PLUS:
++				wpa_printf(MSG_DEBUG, "  * ht=HT40+");
++				break;
++			case NL80211_CHAN_HT40MINUS:
++				wpa_printf(MSG_DEBUG, "  * ht=HT40-");
++				break;
++		}
++		NLA_PUT_U32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
++			    params->htmode);
++	}
++
+ 	ret = nl80211_set_conn_keys(params, msg);
+ 	if (ret)
+ 		goto nla_put_failure;
+--- a/wpa_supplicant/config.c
++++ b/wpa_supplicant/config.c
+@@ -1495,6 +1495,71 @@ static char * wpa_config_write_mcast_rat
+ }
+ #endif /* NO_CONFIG_WRITE */
+ 
++static int wpa_config_parse_htmode(const struct parse_data *data,
++				   struct wpa_ssid *ssid, int line,
++				   const char *value)
++{
++	int i;
++	static const struct {
++		const char *name;
++		unsigned int val;
++	} htmap[] = {
++		{ .name = "HT20", .val = NL80211_CHAN_HT20, },
++		{ .name = "HT40+", .val = NL80211_CHAN_HT40PLUS, },
++		{ .name = "HT40-", .val = NL80211_CHAN_HT40MINUS, },
++		{ .name = "NOHT", .val = NL80211_CHAN_NO_HT, },
++	};
++	ssid->ht_set = 0;;
++	for (i = 0; i < 4; i++) {
++		if (strcasecmp(htmap[i].name, value) == 0) {
++			ssid->htmode = htmap[i].val;
++			ssid->ht_set = 1;
++			break;
++		}
++	}
++
++	return 0;
++}
++
++#ifndef NO_CONFIG_WRITE
++static char * wpa_config_write_htmode(const struct parse_data *data,
++				      struct wpa_ssid *ssid)
++{
++	char *value;
++	int res;
++
++	value = os_malloc(6); /* longest: HT40+ */
++	if (value == NULL)
++		return NULL;
++
++	switch(ssid->htmode) {
++		case NL80211_CHAN_HT20:
++			res = os_snprintf(value, 4, "HT20");
++			break;
++		case NL80211_CHAN_HT40PLUS:
++			res = os_snprintf(value, 5, "HT40+");
++			break;
++		case NL80211_CHAN_HT40MINUS:
++			res = os_snprintf(value, 5, "HT40-");
++			break;
++		case NL80211_CHAN_NO_HT:
++			res = os_snprintf(value, 4, "NOHT");
++			break;
++		default:
++			os_free(value);
++			return NULL;
++	}
++
++	if (res < 0) {
++		os_free(value);
++		return NULL;
++	}
++
++	return value;
++}
++#endif /* NO_CONFIG_WRITE */
++
++
+ static int wpa_config_parse_rates(const struct parse_data *data,
+ 				  struct wpa_ssid *ssid, int line,
+ 				  const char *value)
+@@ -1734,6 +1799,7 @@ static const struct parse_data ssid_fiel
+ 	{ INT_RANGE(beacon_interval, 0, 1000) },
+ 	{ FUNC(rates) },
+ 	{ FUNC(mcast_rate) },
++	{ FUNC(htmode) },
+ };
+ 
+ #undef OFFSET
+--- a/wpa_supplicant/config_ssid.h
++++ b/wpa_supplicant/config_ssid.h
+@@ -535,6 +535,8 @@ struct wpa_ssid {
+ 	int beacon_interval;
+ 	unsigned char rates[NL80211_MAX_SUPP_RATES];
+ 	double mcast_rate;
++	int ht_set;
++	unsigned int htmode;
+ };
+ 
+ #endif /* CONFIG_SSID_H */
+--- a/wpa_supplicant/wpa_supplicant.c
++++ b/wpa_supplicant/wpa_supplicant.c
+@@ -1577,6 +1577,8 @@ void wpa_supplicant_associate(struct wpa
+ 			i++;
+ 		}
+ 		params.mcast_rate = ssid->mcast_rate;
++		params.ht_set = ssid->ht_set;
++		params.htmode = ssid->htmode;
+ 	}
+ 
+ 	params.wpa_ie = wpa_ie;
diff --exclude .svn -Nru package/hostapd/patches/610-max_num_sta_probe.patch package/hostapd/patches/610-max_num_sta_probe.patch
--- package/hostapd/patches/610-max_num_sta_probe.patch	1970-01-01 01:00:00.000000000 +0100
+++ package/hostapd/patches/610-max_num_sta_probe.patch	2012-09-30 10:13:29.630734001 +0200
@@ -0,0 +1,13 @@
+--- a/src/ap/beacon.c
++++ b/src/ap/beacon.c
+@@ -413,6 +413,10 @@ void handle_probe_req(struct hostapd_dat
+ 		return;
+ 	}
+ 
++	if (!sta && hapd->num_sta >= hapd->conf->max_num_sta)
++		wpa_printf(MSG_MSGDUMP, "Probe Request from " MACSTR " ignored,"
++			   " too many connected stations.", MAC2STR(mgmt->sa));
++
+ #ifdef CONFIG_INTERWORKING
+ 	if (elems.interworking && elems.interworking_len >= 1) {
+ 		u8 ant = elems.interworking[0] & 0x0f;
diff --exclude .svn -Nru package/hostapd/patches/700-random_pool_add_kernel.patch package/hostapd/patches/700-random_pool_add_kernel.patch
--- package/hostapd/patches/700-random_pool_add_kernel.patch	2012-08-17 15:40:41.351971000 +0200
+++ package/hostapd/patches/700-random_pool_add_kernel.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,168 +0,0 @@
---- a/src/crypto/random.c
-+++ b/src/crypto/random.c
-@@ -38,6 +38,8 @@
- #include "sha1.h"
- #include "random.h"
- 
-+#define RANDOM_STAMPFILE "/var/run/.random_available"
-+
- #define POOL_WORDS 32
- #define POOL_WORDS_MASK (POOL_WORDS - 1)
- #define POOL_TAP1 26
-@@ -48,6 +50,8 @@
- #define EXTRACT_LEN 16
- #define MIN_READY_MARK 2
- 
-+#ifndef CONFIG_NO_RANDOM_POOL
-+
- static u32 pool[POOL_WORDS];
- static unsigned int input_rotate = 0;
- static unsigned int pool_pos = 0;
-@@ -128,7 +132,7 @@ static void random_extract(u8 *out)
- }
- 
- 
--void random_add_randomness(const void *buf, size_t len)
-+static void random_pool_add_randomness(const void *buf, size_t len)
- {
- 	struct os_time t;
- 	static unsigned int count = 0;
-@@ -197,16 +201,22 @@ int random_get_bytes(void *buf, size_t l
- int random_pool_ready(void)
- {
- #ifdef __linux__
-+	struct stat st;
- 	int fd;
- 	ssize_t res;
- 
-+	if (stat(RANDOM_STAMPFILE, &st) == 0)
-+		return 1;
-+
- 	/*
- 	 * Make sure that there is reasonable entropy available before allowing
- 	 * some key derivation operations to proceed.
- 	 */
- 
--	if (dummy_key_avail == sizeof(dummy_key))
-+	if (dummy_key_avail == sizeof(dummy_key)) {
-+		random_mark_pool_ready();
- 		return 1; /* Already initialized - good to continue */
-+	}
- 
- 	/*
- 	 * Try to fetch some more data from the kernel high quality
-@@ -241,6 +251,7 @@ int random_pool_ready(void)
- 	if (dummy_key_avail == sizeof(dummy_key)) {
- 		if (own_pool_ready < MIN_READY_MARK)
- 			own_pool_ready = MIN_READY_MARK;
-+		random_mark_pool_ready();
- 		random_write_entropy();
- 		return 1;
- 	}
-@@ -253,6 +264,7 @@ int random_pool_ready(void)
- 	    total_collected + 10 * own_pool_ready > MIN_COLLECT_ENTROPY) {
- 		wpa_printf(MSG_INFO, "random: Allow operation to proceed "
- 			   "based on internal entropy");
-+		random_mark_pool_ready();
- 		return 1;
- 	}
- 
-@@ -268,10 +280,16 @@ int random_pool_ready(void)
- 
- void random_mark_pool_ready(void)
- {
-+	int fd;
-+
- 	own_pool_ready++;
- 	wpa_printf(MSG_DEBUG, "random: Mark internal entropy pool to be "
- 		   "ready (count=%u/%u)", own_pool_ready, MIN_READY_MARK);
- 	random_write_entropy();
-+
-+	fd = open(RANDOM_STAMPFILE, O_CREAT | O_WRONLY | O_EXCL | O_NOFOLLOW, 0600);
-+	if (fd >= 0)
-+		close(fd);
- }
- 
- 
-@@ -428,3 +446,22 @@ void random_deinit(void)
- 	os_free(random_entropy_file);
- 	random_entropy_file = NULL;
- }
-+
-+#endif /* CONFIG_NO_RANDOM_POOL */
-+
-+
-+void random_add_randomness(const void *buf, size_t len)
-+{
-+#ifdef __linux__
-+	int fd;
-+
-+	fd = open("/dev/random", O_RDWR);
-+	if (fd >= 0) {
-+		write(fd, buf, len);
-+		close(fd);
-+	}
-+#endif
-+#ifndef CONFIG_NO_RANDOM_POOL
-+	random_pool_add_randomness(buf, len);
-+#endif
-+}
---- a/wpa_supplicant/Makefile
-+++ b/wpa_supplicant/Makefile
-@@ -1137,9 +1137,8 @@ endif
- 
- ifdef CONFIG_NO_RANDOM_POOL
- CFLAGS += -DCONFIG_NO_RANDOM_POOL
--else
--OBJS += ../src/crypto/random.o
- endif
-+OBJS += ../src/crypto/random.o
- 
- ifdef CONFIG_CTRL_IFACE
- ifeq ($(CONFIG_CTRL_IFACE), y)
---- a/wpa_supplicant/Android.mk
-+++ b/wpa_supplicant/Android.mk
-@@ -1132,9 +1132,8 @@ endif
- 
- ifdef CONFIG_NO_RANDOM_POOL
- L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
--else
--OBJS += src/crypto/random.c
- endif
-+OBJS += src/crypto/random.c
- 
- ifdef CONFIG_CTRL_IFACE
- ifeq ($(CONFIG_CTRL_IFACE), y)
---- a/hostapd/Android.mk
-+++ b/hostapd/Android.mk
-@@ -720,11 +720,11 @@ endif
- ifdef CONFIG_NO_RANDOM_POOL
- L_CFLAGS += -DCONFIG_NO_RANDOM_POOL
- else
--OBJS += src/crypto/random.c
--HOBJS += src/crypto/random.c
- HOBJS += $(SHA1OBJS)
- HOBJS += src/crypto/md5.c
- endif
-+OBJS += src/crypto/random.c
-+HOBJS += src/crypto/random.c
- 
- ifdef CONFIG_RADIUS_SERVER
- L_CFLAGS += -DRADIUS_SERVER
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -707,12 +707,12 @@ endif
- ifdef CONFIG_NO_RANDOM_POOL
- CFLAGS += -DCONFIG_NO_RANDOM_POOL
- else
--OBJS += ../src/crypto/random.o
--HOBJS += ../src/crypto/random.o
- HOBJS += ../src/utils/eloop.o
- HOBJS += $(SHA1OBJS)
- HOBJS += ../src/crypto/md5.o
- endif
-+OBJS += ../src/crypto/random.o
-+HOBJS += ../src/crypto/random.o
- 
- ifdef CONFIG_RADIUS_SERVER
- CFLAGS += -DRADIUS_SERVER
diff --exclude .svn -Nru package/hostapd/patches/710-bring_down_interface.patch package/hostapd/patches/710-bring_down_interface.patch
--- package/hostapd/patches/710-bring_down_interface.patch	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/patches/710-bring_down_interface.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -5867,8 +5867,6 @@ static int wpa_driver_nl80211_set_mode(s
- 			ret = nl80211_set_mode(drv, drv->ifindex, nlmode);
- 			if (ret == -EACCES)
- 				break;
--			res = linux_set_iface_flags(drv->global->ioctl_sock,
--						    bss->ifname, 1);
- 			if (res && !ret)
- 				ret = -1;
- 			else if (ret != -EBUSY)
-@@ -5884,6 +5882,7 @@ static int wpa_driver_nl80211_set_mode(s
- 			   "interface is down");
- 		drv->nlmode = nlmode;
- 		drv->ignore_if_down_event = 1;
-+		linux_set_iface_flags(drv->global->ioctl_sock, bss->ifname, 1);
- 	}
- 
- done:
diff --exclude .svn -Nru package/hostapd/patches/720-fix_wps_pin_crash.patch package/hostapd/patches/720-fix_wps_pin_crash.patch
--- package/hostapd/patches/720-fix_wps_pin_crash.patch	2012-08-17 15:40:41.391971000 +0200
+++ package/hostapd/patches/720-fix_wps_pin_crash.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
---- a/hostapd/ctrl_iface.c
-+++ b/hostapd/ctrl_iface.c
-@@ -514,6 +514,9 @@ static int hostapd_ctrl_iface_wps_ap_pin
- 	char *pos;
- 	const char *pin_txt;
- 
-+	if (!hapd->wps)
-+		return -1;
-+
- 	pos = os_strchr(txt, ' ');
- 	if (pos)
- 		*pos++ = '\0';
diff --exclude .svn -Nru package/hostapd/patches/730-wps_single_auth_enc_type.patch package/hostapd/patches/730-wps_single_auth_enc_type.patch
--- package/hostapd/patches/730-wps_single_auth_enc_type.patch	2012-08-17 15:40:41.351971000 +0200
+++ package/hostapd/patches/730-wps_single_auth_enc_type.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,25 +0,0 @@
---- a/src/ap/wps_hostapd.c
-+++ b/src/ap/wps_hostapd.c
-@@ -799,11 +799,9 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->rsn_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->rsn_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
--	}
--
--	if (conf->wpa & WPA_PROTO_WPA) {
-+	} else if (conf->wpa & WPA_PROTO_WPA) {
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_PSK)
- 			wps->auth_types |= WPS_AUTH_WPAPSK;
- 		if (conf->wpa_key_mgmt & WPA_KEY_MGMT_IEEE8021X)
-@@ -811,7 +809,7 @@ int hostapd_init_wps(struct hostapd_data
- 
- 		if (conf->wpa_pairwise & WPA_CIPHER_CCMP)
- 			wps->encr_types |= WPS_ENCR_AES;
--		if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
-+		else if (conf->wpa_pairwise & WPA_CIPHER_TKIP)
- 			wps->encr_types |= WPS_ENCR_TKIP;
- 	}
- 
diff --exclude .svn -Nru package/hostapd/patches/740-group_key_timeout.patch package/hostapd/patches/740-group_key_timeout.patch
--- package/hostapd/patches/740-group_key_timeout.patch	2012-08-17 15:40:41.351971000 +0200
+++ package/hostapd/patches/740-group_key_timeout.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -1330,7 +1330,7 @@ static void wpa_send_eapol(struct wpa_au
- 			 keyidx, encr, 0);
- 
- 	ctr = pairwise ? sm->TimeoutCtr : sm->GTimeoutCtr;
--	if (ctr == 1 && wpa_auth->conf.tx_status)
-+	if (ctr == 1 && wpa_auth->conf.tx_status && pairwise)
- 		timeout_ms = eapol_key_timeout_first;
- 	else
- 		timeout_ms = eapol_key_timeout_subseq;
diff --exclude .svn -Nru package/hostapd/patches/750-dynamic_20_40_mhz.patch package/hostapd/patches/750-dynamic_20_40_mhz.patch
--- package/hostapd/patches/750-dynamic_20_40_mhz.patch	2012-08-17 15:40:41.401971000 +0200
+++ package/hostapd/patches/750-dynamic_20_40_mhz.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,202 +0,0 @@
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -1935,6 +1935,10 @@ struct hostapd_config * hostapd_config_r
- 					   "ht_capab", line);
- 				errors++;
- 			}
-+		} else if (os_strcmp(buf, "dynamic_ht40") == 0) {
-+			conf->dynamic_ht40 = atoi(pos);
-+			if (conf->dynamic_ht40 == 1)
-+				conf->dynamic_ht40 = 1500;
- 		} else if (os_strcmp(buf, "require_ht") == 0) {
- 			conf->require_ht = atoi(pos);
- #endif /* CONFIG_IEEE80211N */
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -416,6 +416,7 @@ struct hostapd_config {
- 	int ieee80211n;
- 	int secondary_channel;
- 	int require_ht;
-+	int dynamic_ht40;
- };
- 
- 
---- a/src/ap/hostapd.c
-+++ b/src/ap/hostapd.c
-@@ -27,6 +27,7 @@
- #include "beacon.h"
- #include "iapp.h"
- #include "ieee802_1x.h"
-+#include "ieee802_11.h"
- #include "ieee802_11_auth.h"
- #include "vlan_init.h"
- #include "wpa_auth.h"
-@@ -291,6 +292,7 @@ static void hostapd_cleanup_iface_pre(st
-  */
- static void hostapd_cleanup_iface(struct hostapd_iface *iface)
- {
-+	hostapd_deinit_ht(iface);
- 	hostapd_free_hw_features(iface->hw_features, iface->num_hw_features);
- 	iface->hw_features = NULL;
- 	os_free(iface->current_rates);
---- a/src/ap/hostapd.h
-+++ b/src/ap/hostapd.h
-@@ -226,6 +226,9 @@ struct hostapd_iface {
- 	/* Overlapping BSS information */
- 	int olbc_ht;
- 
-+	int force_20mhz;
-+	struct os_time last_20mhz_trigger;
-+
- 	u16 ht_op_mode;
- 	void (*scan_cb)(struct hostapd_iface *iface);
- 
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -1193,6 +1193,9 @@ static void handle_beacon(struct hostapd
- 					     sizeof(mgmt->u.beacon)), &elems,
- 				      0);
- 
-+	if (!elems.ht_capabilities)
-+		hostapd_trigger_20mhz(hapd->iface);
-+
- 	ap_list_process_beacon(hapd->iface, mgmt, &elems, fi);
- }
- 
---- a/src/ap/ieee802_11.h
-+++ b/src/ap/ieee802_11.h
-@@ -77,4 +77,17 @@ u8 * hostapd_eid_time_zone(struct hostap
- int hostapd_update_time_adv(struct hostapd_data *hapd);
- void hostapd_client_poll_ok(struct hostapd_data *hapd, const u8 *addr);
- 
-+#ifdef CONFIG_IEEE80211N
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface);
-+void hostapd_deinit_ht(struct hostapd_iface *iface);
-+
-+#else
-+static inline void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+}
-+static inline void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+}
-+#endif /* CONFIG_IEEE80211N */
-+
- #endif /* IEEE802_11_H */
---- a/src/ap/ieee802_11_ht.c
-+++ b/src/ap/ieee802_11_ht.c
-@@ -20,9 +20,11 @@
- #include "drivers/driver.h"
- #include "hostapd.h"
- #include "ap_config.h"
-+#include "ap_drv_ops.h"
- #include "sta_info.h"
- #include "beacon.h"
- #include "ieee802_11.h"
-+#include "utils/eloop.h"
- 
- 
- u8 * hostapd_eid_ht_capabilities(struct hostapd_data *hapd, u8 *eid)
-@@ -70,12 +72,15 @@ u8 * hostapd_eid_ht_operation(struct hos
- 
- 	oper->control_chan = hapd->iconf->channel;
- 	oper->operation_mode = host_to_le16(hapd->iface->ht_op_mode);
--	if (hapd->iconf->secondary_channel == 1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
--	if (hapd->iconf->secondary_channel == -1)
--		oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
--			HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+
-+	if (!hapd->iface->force_20mhz) {
-+		if (hapd->iconf->secondary_channel == 1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_ABOVE |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+		if (hapd->iconf->secondary_channel == -1)
-+			oper->ht_param |= HT_INFO_HT_PARAM_SECONDARY_CHNL_BELOW |
-+				HT_INFO_HT_PARAM_REC_TRANS_CHNL_WIDTH;
-+	}
- 
- 	pos += sizeof(*oper);
- 
-@@ -271,3 +276,80 @@ void hostapd_get_ht_capab(struct hostapd
- 
- 	neg_ht_cap->ht_capabilities_info = host_to_le16(cap);
- }
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface);
-+
-+static void hostapd_restore_40mhz(void *eloop_data, void *user_ctx)
-+{
-+	struct hostapd_iface *iface = eloop_data;
-+	struct os_time time;
-+	int timeout;
-+
-+	if (!iface->last_20mhz_trigger.sec)
-+	    return;
-+
-+	os_get_time(&time);
-+	timeout = iface->last_20mhz_trigger.sec + iface->conf->dynamic_ht40 -
-+		  time.sec;
-+
-+	if (timeout > 0) {
-+		eloop_register_timeout(timeout, 0, hostapd_restore_40mhz,
-+				       iface, NULL);
-+		return;
-+	}
-+
-+	iface->last_20mhz_trigger.sec = 0;
-+	iface->last_20mhz_trigger.usec = 0;
-+
-+	iface->force_20mhz = 0;
-+	hostapd_set_force_20mhz(iface);
-+}
-+
-+static void hostapd_set_force_20mhz(struct hostapd_iface *iface)
-+{
-+	int secondary_channel;
-+	int i;
-+
-+	ieee802_11_set_beacons(iface);
-+
-+	for (i = 0; i < iface->num_bss; i++) {
-+		struct hostapd_data *hapd = iface->bss[i];
-+
-+		if (iface->force_20mhz)
-+			secondary_channel = 0;
-+		else
-+			secondary_channel = hapd->iconf->secondary_channel;
-+
-+		if (hostapd_set_freq(hapd, hapd->iconf->hw_mode, iface->freq,
-+					 hapd->iconf->channel,
-+					 hapd->iconf->ieee80211n,
-+					 secondary_channel)) {
-+			wpa_printf(MSG_ERROR, "Could not set channel for "
-+				   "kernel driver");
-+		}
-+	}
-+}
-+
-+void hostapd_deinit_ht(struct hostapd_iface *iface)
-+{
-+	eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+}
-+
-+void hostapd_trigger_20mhz(struct hostapd_iface *iface)
-+{
-+	if (!iface->conf->dynamic_ht40)
-+		return;
-+
-+	if (!iface->force_20mhz) {
-+		iface->force_20mhz = 1;
-+		hostapd_set_force_20mhz(iface);
-+	}
-+
-+	if (!iface->last_20mhz_trigger.sec) {
-+		eloop_cancel_timeout(hostapd_restore_40mhz, iface, NULL);
-+		eloop_register_timeout(iface->conf->dynamic_ht40, 0,
-+				       hostapd_restore_40mhz, iface, NULL);
-+	}
-+
-+	os_get_time(&iface->last_20mhz_trigger);
-+}
diff --exclude .svn -Nru package/hostapd/patches/900-indicate-features.patch package/hostapd/patches/900-indicate-features.patch
--- package/hostapd/patches/900-indicate-features.patch	2012-08-17 15:40:41.371971000 +0200
+++ package/hostapd/patches/900-indicate-features.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -19,6 +19,7 @@
- 
- #include "utils/common.h"
- #include "utils/eloop.h"
-+#include "utils/build_features.h"
- #include "crypto/random.h"
- #include "crypto/tls.h"
- #include "common/version.h"
-@@ -574,7 +575,7 @@ int main(int argc, char *argv[])
- 
- 	wpa_supplicant_event = hostapd_wpa_event;
- 	for (;;) {
--		c = getopt(argc, argv, "Bde:f:hKP:tv");
-+		c = getopt(argc, argv, "Bde:f:hKP:tv::");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -606,6 +607,8 @@ int main(int argc, char *argv[])
- 			wpa_debug_timestamp++;
- 			break;
- 		case 'v':
-+			if (optarg)
-+				exit(!has_feature(optarg));
- 			show_version();
- 			exit(1);
- 			break;
---- a/wpa_supplicant/main.c
-+++ b/wpa_supplicant/main.c
-@@ -18,6 +18,7 @@
- #endif /* __linux__ */
- 
- #include "common.h"
-+#include "build_features.h"
- #include "wpa_supplicant_i.h"
- #include "driver_i.h"
- 
-@@ -146,7 +147,7 @@ int main(int argc, char *argv[])
- 	wpa_supplicant_fd_workaround();
- 
- 	for (;;) {
--		c = getopt(argc, argv, "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qstuvW");
-+		c = getopt(argc, argv, "b:Bc:C:D:de:f:g:hH:i:KLNo:O:p:P:qstuv::W");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -233,8 +234,12 @@ int main(int argc, char *argv[])
- 			break;
- #endif /* CONFIG_DBUS */
- 		case 'v':
--			printf("%s\n", wpa_supplicant_version);
--			exitcode = 0;
-+			if (optarg) {
-+				exitcode = !has_feature(optarg);
-+			} else {
-+				printf("%s\n", wpa_supplicant_version);
-+				exitcode = 0;
-+			}
- 			goto out;
- 		case 'W':
- 			params.wait_for_monitor++;
---- /dev/null
-+++ b/src/utils/build_features.h
-@@ -0,0 +1,17 @@
-+#ifndef BUILD_FEATURES_H
-+#define BUILD_FEATURES_H
-+
-+static inline int has_feature(const char *feat)
-+{
-+#ifdef IEEE8021X_EAPOL
-+	if (!strcmp(feat, "eap"))
-+		return 1;
-+#endif
-+#ifdef IEEE80211N
-+	if (!strcmp(feat, "11n"))
-+		return 1;
-+#endif
-+	return 0;
-+}
-+
-+#endif /* BUILD_FEATURES_H */
