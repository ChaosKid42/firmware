diff --git a/package/hostapd/patches/0002-hostapd-Add-config-option-for-DFS-channels.patch b/package/hostapd/patches/0002-hostapd-Add-config-option-for-DFS-channels.patch
new file mode 100644
index 0000000..03b342c
--- /dev/null
+++ b/package/hostapd/patches/0002-hostapd-Add-config-option-for-DFS-channels.patch
@@ -0,0 +1,99 @@
+diff --git a/hostapd/config_file.c b/hostapd/config_file.c
+index 54e4af9..0df7edf 100644
+--- a/hostapd/config_file.c
++++ b/hostapd/config_file.c
+@@ -2235,6 +2235,12 @@  static int hostapd_config_fill(struct hostapd_config *conf,
+ 				conf->channel = 0;
+ 			} else
+ 				conf->channel = atoi(pos);
++		} else if (os_strcmp(buf, "dfs_chanlist") == 0) {
++			if (hostapd_parse_intlist(&conf->dfs_chanlist, pos)) {
++				wpa_printf(MSG_ERROR, "Line %d: invalid channel "
++					   "list", line);
++				errors++;
++			}
+ 		} else if (os_strcmp(buf, "beacon_int") == 0) {
+ 			int val = atoi(pos);
+ 			/* MIB defines range as 1..65535, but very small values
+diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
+index da7817f..7591663 100644
+--- a/hostapd/hostapd.conf
++++ b/hostapd/hostapd.conf
+@@ -140,6 +140,12 @@  channel=1
+ # Defaults:
+ #acs_num_scans=5
+ 
++# DFS Channels. This option allows hostapd to select on of the provided
++# DFS Channels when the current channels becomes unavailable due to
++# radar interference. Only useful when ieee80211h=1 is set.
++# Default: not set
++#dfs_chanlist=100 104 108 112 116
++
+ # Beacon interval in kus (1.024 ms) (default: 100; range 15..65535)
+ beacon_int=100
+ 
+diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
+index 368b202..c369cd6 100644
+--- a/src/ap/ap_config.c
++++ b/src/ap/ap_config.c
+@@ -554,6 +554,7 @@  void hostapd_config_free(struct hostapd_config *conf)
+ 	os_free(conf->bss);
+ 	os_free(conf->supported_rates);
+ 	os_free(conf->basic_rates);
++	os_free(conf->dfs_chanlist);
+ 
+ 	os_free(conf);
+ }
+diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
+index b4860a0..b29323f 100644
+--- a/src/ap/ap_config.h
++++ b/src/ap/ap_config.h
+@@ -493,6 +493,7 @@  struct hostapd_config {
+ 	int fragm_threshold;
+ 	u8 send_probe_response;
+ 	u8 channel;
++	int *dfs_chanlist;
+ 	enum hostapd_hw_mode hw_mode; /* HOSTAPD_MODE_IEEE80211A, .. */
+ 	enum {
+ 		LONG_PREAMBLE = 0,
+diff --git a/src/ap/dfs.c b/src/ap/dfs.c
+index e4c00f8..b2c6a7f 100644
+--- a/src/ap/dfs.c
++++ b/src/ap/dfs.c
+@@ -130,6 +130,24 @@  static int dfs_chan_range_available(struct hostapd_hw_modes *mode,
+ }
+ 
+ 
++static int is_in_dfs_chanlist(struct hostapd_iface *iface,
++			      struct hostapd_channel_data *chan)
++{
++	int *chan_entry;
++
++	if (!iface->conf->dfs_chanlist)
++		return 1;
++
++	for (chan_entry = iface->conf->dfs_chanlist;
++	     *chan_entry != -1;
++	     chan_entry++) {
++		if (*chan_entry == chan->chan)
++			return 1;
++	}
++	return 0;
++}
++
++
+ /*
+  * The function assumes HT40+ operation.
+  * Make sure to adjust the following variables after calling this:
+@@ -162,6 +180,9 @@  static int dfs_find_channel(struct hostapd_iface *iface,
+ 		if (!dfs_chan_range_available(mode, i, n_chans, skip_radar))
+ 			continue;
+ 
++		if (!is_in_dfs_chanlist(iface, chan))
++			continue;
++
+ 		if (ret_chan && idx == channel_idx) {
+ 			wpa_printf(MSG_DEBUG, "Selected ch. #%d", chan->chan);
+ 			*ret_chan = chan;
+
+
diff --git a/package/iwinfo/Makefile b/package/iwinfo/Makefile
index e0090e0..9bebb7a 100644
--- a/package/iwinfo/Makefile
+++ b/package/iwinfo/Makefile
@@ -7,7 +7,7 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=libiwinfo
-PKG_RELEASE:=44
+PKG_RELEASE:=47
 
 PKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)
 PKG_CONFIG_DEPENDS := \
diff --git a/package/iwinfo/src/hardware.txt b/package/iwinfo/src/hardware.txt
index 6b20518..66cbe2a 100644
--- a/package/iwinfo/src/hardware.txt
+++ b/package/iwinfo/src/hardware.txt
@@ -46,6 +46,7 @@
 0x168c 0x002a 0x0777 0xe005    5      0  "Ubiquiti" "NanoStation M5" /* ToDo: confirm offset */
 0x168c 0x002a 0x0777 0xe202   12      0  "Ubiquiti" "Bullet M2"
 0x168c 0x002a 0x0777 0xe805    5      0  "Ubiquiti" "Bullet M5"
+0x168c 0x002a 0x0777 0xe345    0      0  "Ubiquiti" "WispStation M5" /* ToDo: confirm offset */
 0x168c 0x0029 0x168c 0xa094    0      0  "Atheros"  "AR9220"
 0x168c 0x0029 0x168c 0xa095    0      0  "Atheros"  "AR9223"
 0x168c 0x002a 0x168c 0xa093    0      0  "Atheros"  "AR9280"
diff --git a/package/iwinfo/src/include/iwinfo.h b/package/iwinfo/src/include/iwinfo.h
index 0d92d8d..ebea319 100644
--- a/package/iwinfo/src/include/iwinfo.h
+++ b/package/iwinfo/src/include/iwinfo.h
@@ -167,6 +167,7 @@ struct iwinfo_ops {
 	int (*hardware_id)(const char *, char *);
 	int (*hardware_name)(const char *, char *);
 	int (*encryption)(const char *, char *);
+	int (*phyname)(const char *, char *);
 	int (*assoclist)(const char *, char *, int *);
 	int (*txpwrlist)(const char *, char *, int *);
 	int (*scanlist)(const char *, char *, int *);
diff --git a/package/iwinfo/src/include/iwinfo/api/broadcom.h b/package/iwinfo/src/include/iwinfo/api/broadcom.h
index 50eedd9..c7aa33e 100644
--- a/package/iwinfo/src/include/iwinfo/api/broadcom.h
+++ b/package/iwinfo/src/include/iwinfo/api/broadcom.h
@@ -26,7 +26,7 @@
 #define WLC_IOCTL_MAGIC				0x14e46c77
 #define	WLC_IOCTL_MAXLEN			8192
 
-#define WLC_CNTRY_BUF_SZ        	4
+#define WLC_CNTRY_BUF_SZ        		4
 
 #define WLC_GET_MAGIC				0
 #define WLC_GET_RATE				12
@@ -35,18 +35,30 @@
 #define WLC_GET_BSSID				23
 #define WLC_GET_SSID				25
 #define WLC_GET_CHANNEL				29
+#define WLC_GET_PHYTYPE             		39
 #define WLC_GET_PASSIVE 			48
 #define WLC_GET_COUNTRY				83
 #define WLC_GET_REVINFO				98
-#define WLC_GET_AP					117
+#define WLC_GET_AP				117
 #define WLC_GET_RSSI				127
 #define WLC_GET_WSEC				133
 #define WLC_GET_PHY_NOISE			135
 #define WLC_GET_BSS_INFO			136
+#define WLC_GET_BANDLIST			140
 #define WLC_GET_ASSOCLIST			159
 #define WLC_GET_WPA_AUTH			164
-#define WLC_GET_COUNTRY_LIST		261
-#define WLC_GET_VAR					262
+#define WLC_GET_COUNTRY_LIST			261
+#define WLC_GET_VAR				262
+
+#define WLC_PHY_TYPE_A				0
+#define WLC_PHY_TYPE_B				1
+#define WLC_PHY_TYPE_G				2
+#define WLC_PHY_TYPE_N				4
+#define WLC_PHY_TYPE_LP				5
+
+#define WLC_BAND_5G				1
+#define WLC_BAND_2G				2
+#define WLC_BAND_ALL				3
 
 
 struct wl_ether_addr {
@@ -117,6 +129,9 @@ typedef struct wlc_rev_info {
 	uint		ucoderev;	/* microcode version */
 	uint		bus;		/* bus type */
 	uint		chipnum;	/* chip number */
+	uint		phytype;	/* phy type */
+	uint		phyrev;		/* phy revision */
+	uint		anarev;		/* anacore rev */
 } wlc_rev_info_t;
 
 typedef struct wl_country_list {
diff --git a/package/iwinfo/src/include/iwinfo/madwifi.h b/package/iwinfo/src/include/iwinfo/madwifi.h
index 14d8135..3662d9f 100644
--- a/package/iwinfo/src/include/iwinfo/madwifi.h
+++ b/package/iwinfo/src/include/iwinfo/madwifi.h
@@ -41,6 +41,7 @@ int madwifi_get_noise(const char *ifname, int *buf);
 int madwifi_get_quality(const char *ifname, int *buf);
 int madwifi_get_quality_max(const char *ifname, int *buf);
 int madwifi_get_encryption(const char *ifname, char *buf);
+int madwifi_get_phyname(const char *ifname, char *buf);
 int madwifi_get_assoclist(const char *ifname, char *buf, int *len);
 int madwifi_get_txpwrlist(const char *ifname, char *buf, int *len);
 int madwifi_get_scanlist(const char *ifname, char *buf, int *len);
@@ -72,6 +73,7 @@ static const struct iwinfo_ops madwifi_ops = {
 	.hardware_id      = madwifi_get_hardware_id,
 	.hardware_name    = madwifi_get_hardware_name,
 	.encryption       = madwifi_get_encryption,
+	.phyname          = madwifi_get_phyname,
 	.assoclist        = madwifi_get_assoclist,
 	.txpwrlist        = madwifi_get_txpwrlist,
 	.scanlist         = madwifi_get_scanlist,
diff --git a/package/iwinfo/src/include/iwinfo/nl80211.h b/package/iwinfo/src/include/iwinfo/nl80211.h
index 2854514..0611fee 100644
--- a/package/iwinfo/src/include/iwinfo/nl80211.h
+++ b/package/iwinfo/src/include/iwinfo/nl80211.h
@@ -83,6 +83,7 @@ int nl80211_get_noise(const char *ifname, int *buf);
 int nl80211_get_quality(const char *ifname, int *buf);
 int nl80211_get_quality_max(const char *ifname, int *buf);
 int nl80211_get_encryption(const char *ifname, char *buf);
+int nl80211_get_phyname(const char *ifname, char *buf);
 int nl80211_get_assoclist(const char *ifname, char *buf, int *len);
 int nl80211_get_txpwrlist(const char *ifname, char *buf, int *len);
 int nl80211_get_scanlist(const char *ifname, char *buf, int *len);
@@ -114,6 +115,7 @@ static const struct iwinfo_ops nl80211_ops = {
 	.hardware_id      = nl80211_get_hardware_id,
 	.hardware_name    = nl80211_get_hardware_name,
 	.encryption       = nl80211_get_encryption,
+	.phyname          = nl80211_get_phyname,
 	.assoclist        = nl80211_get_assoclist,
 	.txpwrlist        = nl80211_get_txpwrlist,
 	.scanlist         = nl80211_get_scanlist,
diff --git a/package/iwinfo/src/include/iwinfo/wext.h b/package/iwinfo/src/include/iwinfo/wext.h
index 68b596e..e84f6a6 100644
--- a/package/iwinfo/src/include/iwinfo/wext.h
+++ b/package/iwinfo/src/include/iwinfo/wext.h
@@ -42,6 +42,7 @@ int wext_get_noise(const char *ifname, int *buf);
 int wext_get_quality(const char *ifname, int *buf);
 int wext_get_quality_max(const char *ifname, int *buf);
 int wext_get_encryption(const char *ifname, char *buf);
+int wext_get_phyname(const char *ifname, char *buf);
 int wext_get_assoclist(const char *ifname, char *buf, int *len);
 int wext_get_txpwrlist(const char *ifname, char *buf, int *len);
 int wext_get_scanlist(const char *ifname, char *buf, int *len);
@@ -73,6 +74,7 @@ static const struct iwinfo_ops wext_ops = {
 	.hardware_id      = wext_get_hardware_id,
 	.hardware_name    = wext_get_hardware_name,
 	.encryption       = wext_get_encryption,
+	.phyname          = wext_get_phyname,
 	.assoclist        = wext_get_assoclist,
 	.txpwrlist        = wext_get_txpwrlist,
 	.scanlist         = wext_get_scanlist,
diff --git a/package/iwinfo/src/include/iwinfo/wl.h b/package/iwinfo/src/include/iwinfo/wl.h
index db37e37..077a51b 100644
--- a/package/iwinfo/src/include/iwinfo/wl.h
+++ b/package/iwinfo/src/include/iwinfo/wl.h
@@ -42,6 +42,7 @@ int wl_get_quality(const char *ifname, int *buf);
 int wl_get_quality_max(const char *ifname, int *buf);
 int wl_get_enctype(const char *ifname, char *buf);
 int wl_get_encryption(const char *ifname, char *buf);
+int wl_get_phyname(const char *ifname, char *buf);
 int wl_get_assoclist(const char *ifname, char *buf, int *len);
 int wl_get_txpwrlist(const char *ifname, char *buf, int *len);
 int wl_get_scanlist(const char *ifname, char *buf, int *len);
@@ -73,6 +74,7 @@ static const struct iwinfo_ops wl_ops = {
 	.hardware_id      = wl_get_hardware_id,
 	.hardware_name    = wl_get_hardware_name,
 	.encryption       = wl_get_encryption,
+	.phyname          = wl_get_phyname,
 	.assoclist        = wl_get_assoclist,
 	.txpwrlist        = wl_get_txpwrlist,
 	.scanlist         = wl_get_scanlist,
diff --git a/package/iwinfo/src/iwinfo_cli.c b/package/iwinfo/src/iwinfo_cli.c
index 8da216a..87cc10f 100644
--- a/package/iwinfo/src/iwinfo_cli.c
+++ b/package/iwinfo/src/iwinfo_cli.c
@@ -512,6 +512,16 @@ static char * print_mbssid_supp(const struct iwinfo_ops *iw, const char *ifname)
 	return buf;
 }
 
+static char * print_phyname(const struct iwinfo_ops *iw, const char *ifname)
+{
+	static char buf[32];
+
+	if (!iw->phyname(ifname, buf))
+		return buf;
+
+	return "?";
+}
+
 
 static void print_info(const struct iwinfo_ops *iw, const char *ifname)
 {
@@ -545,8 +555,9 @@ static void print_info(const struct iwinfo_ops *iw, const char *ifname)
 		print_txpower_offset(iw, ifname));
 	printf("          Frequency offset: %s\n",
 		print_frequency_offset(iw, ifname));
-	printf("          Supports VAPs: %s\n",
-		print_mbssid_supp(iw, ifname));
+	printf("          Supports VAPs: %s  PHY name: %s\n",
+		print_mbssid_supp(iw, ifname),
+		print_phyname(iw, ifname));
 }
 
 
diff --git a/package/iwinfo/src/iwinfo_lua.c b/package/iwinfo/src/iwinfo_lua.c
index bd8faf9..3f1f206 100644
--- a/package/iwinfo/src/iwinfo_lua.c
+++ b/package/iwinfo/src/iwinfo_lua.c
@@ -625,6 +625,7 @@ LUA_WRAP_STRING(wl,ssid)
 LUA_WRAP_STRING(wl,bssid)
 LUA_WRAP_STRING(wl,country)
 LUA_WRAP_STRING(wl,hardware_name)
+LUA_WRAP_STRING(wl,phyname)
 LUA_WRAP_STRUCT(wl,mode)
 LUA_WRAP_STRUCT(wl,assoclist)
 LUA_WRAP_STRUCT(wl,txpwrlist)
@@ -653,6 +654,7 @@ LUA_WRAP_STRING(madwifi,ssid)
 LUA_WRAP_STRING(madwifi,bssid)
 LUA_WRAP_STRING(madwifi,country)
 LUA_WRAP_STRING(madwifi,hardware_name)
+LUA_WRAP_STRING(madwifi,phyname)
 LUA_WRAP_STRUCT(madwifi,mode)
 LUA_WRAP_STRUCT(madwifi,assoclist)
 LUA_WRAP_STRUCT(madwifi,txpwrlist)
@@ -681,6 +683,7 @@ LUA_WRAP_STRING(nl80211,ssid)
 LUA_WRAP_STRING(nl80211,bssid)
 LUA_WRAP_STRING(nl80211,country)
 LUA_WRAP_STRING(nl80211,hardware_name)
+LUA_WRAP_STRING(nl80211,phyname)
 LUA_WRAP_STRUCT(nl80211,mode)
 LUA_WRAP_STRUCT(nl80211,assoclist)
 LUA_WRAP_STRUCT(nl80211,txpwrlist)
@@ -708,6 +711,7 @@ LUA_WRAP_STRING(wext,ssid)
 LUA_WRAP_STRING(wext,bssid)
 LUA_WRAP_STRING(wext,country)
 LUA_WRAP_STRING(wext,hardware_name)
+LUA_WRAP_STRING(wext,phyname)
 LUA_WRAP_STRUCT(wext,mode)
 LUA_WRAP_STRUCT(wext,assoclist)
 LUA_WRAP_STRUCT(wext,txpwrlist)
@@ -746,6 +750,7 @@ static const luaL_reg R_wl[] = {
 	LUA_REG(wl,mbssid_support),
 	LUA_REG(wl,hardware_id),
 	LUA_REG(wl,hardware_name),
+	LUA_REG(wl,phyname),
 	{ NULL, NULL }
 };
 #endif
@@ -777,6 +782,7 @@ static const luaL_reg R_madwifi[] = {
 	LUA_REG(madwifi,mbssid_support),
 	LUA_REG(madwifi,hardware_id),
 	LUA_REG(madwifi,hardware_name),
+	LUA_REG(madwifi,phyname),
 	{ NULL, NULL }
 };
 #endif
@@ -808,6 +814,7 @@ static const luaL_reg R_nl80211[] = {
 	LUA_REG(nl80211,mbssid_support),
 	LUA_REG(nl80211,hardware_id),
 	LUA_REG(nl80211,hardware_name),
+	LUA_REG(nl80211,phyname),
 	{ NULL, NULL }
 };
 #endif
@@ -838,6 +845,7 @@ static const luaL_reg R_wext[] = {
 	LUA_REG(wext,mbssid_support),
 	LUA_REG(wext,hardware_id),
 	LUA_REG(wext,hardware_name),
+	LUA_REG(wext,phyname),
 	{ NULL, NULL }
 };
 
@@ -854,6 +862,7 @@ LUALIB_API int luaopen_iwinfo(lua_State *L) {
 
 #ifdef USE_WL
 	luaL_newmetatable(L, IWINFO_WL_META);
+	luaL_register(L, NULL, R_common);
 	luaL_register(L, NULL, R_wl);
 	lua_pushvalue(L, -1);
 	lua_setfield(L, -2, "__index");
@@ -862,6 +871,7 @@ LUALIB_API int luaopen_iwinfo(lua_State *L) {
 
 #ifdef USE_MADWIFI
 	luaL_newmetatable(L, IWINFO_MADWIFI_META);
+	luaL_register(L, NULL, R_common);
 	luaL_register(L, NULL, R_madwifi);
 	lua_pushvalue(L, -1);
 	lua_setfield(L, -2, "__index");
@@ -870,6 +880,7 @@ LUALIB_API int luaopen_iwinfo(lua_State *L) {
 
 #ifdef USE_NL80211
 	luaL_newmetatable(L, IWINFO_NL80211_META);
+	luaL_register(L, NULL, R_common);
 	luaL_register(L, NULL, R_nl80211);
 	lua_pushvalue(L, -1);
 	lua_setfield(L, -2, "__index");
@@ -877,6 +888,7 @@ LUALIB_API int luaopen_iwinfo(lua_State *L) {
 #endif
 
 	luaL_newmetatable(L, IWINFO_WEXT_META);
+	luaL_register(L, NULL, R_common);
 	luaL_register(L, NULL, R_wext);
 	lua_pushvalue(L, -1);
 	lua_setfield(L, -2, "__index");
diff --git a/package/iwinfo/src/iwinfo_madwifi.c b/package/iwinfo/src/iwinfo_madwifi.c
index 832f40b..293c28e 100644
--- a/package/iwinfo/src/iwinfo_madwifi.c
+++ b/package/iwinfo/src/iwinfo_madwifi.c
@@ -721,6 +721,26 @@ int madwifi_get_encryption(const char *ifname, char *buf)
 	return 0;
 }
 
+int madwifi_get_phyname(const char *ifname, char *buf)
+{
+	const char *wifidev;
+
+	wifidev = madwifi_isvap(ifname, NULL);
+
+	if (wifidev)
+	{
+		strcpy(buf, wifidev);
+		return 0;
+	}
+	else if (madwifi_iswifi(ifname))
+	{
+		strcpy(buf, madwifi_phyname(ifname));
+		return 0;
+	}
+
+	return -1;
+}
+
 int madwifi_get_assoclist(const char *ifname, char *buf, int *len)
 {
 	int bl, tl, noise;
diff --git a/package/iwinfo/src/iwinfo_nl80211.c b/package/iwinfo/src/iwinfo_nl80211.c
index 544e701..a258d2f 100644
--- a/package/iwinfo/src/iwinfo_nl80211.c
+++ b/package/iwinfo/src/iwinfo_nl80211.c
@@ -540,16 +540,21 @@ static char * nl80211_wpactl_info(const char *ifname, const char *cmd,
 	{
 		send(sock, "ATTACH", 6, 0);
 
-		if (nl80211_wpactl_recv(sock, buffer, sizeof(buffer)) <= 0)
+		if (nl80211_wpactl_recv(sock, buffer, sizeof(buffer)-1) <= 0)
 			goto out;
 	}
 
 
 	send(sock, cmd, strlen(cmd), 0);
 
-	while( numtry++ < 5 )
+	/* we might have to scan up to 72 channels / 256ms per channel */
+	/* this makes up to 18.5s hence 10 tries */
+	while( numtry++ < 10 )
 	{
-		if (nl80211_wpactl_recv(sock, buffer, sizeof(buffer)) <= 0)
+		char *bracket;
+
+		/* make sure there is a terminating nul byte */
+		if (nl80211_wpactl_recv(sock, buffer, sizeof(buffer)-1) <= 0)
 		{
 			if (event)
 				continue;
@@ -559,6 +564,13 @@ static char * nl80211_wpactl_info(const char *ifname, const char *cmd,
 
 		if ((!event && buffer[0] != '<') || (event && strstr(buffer, event)))
 			break;
+
+		/* there may be more than max(numtry) BSS-ADDED events */
+		/* ignore them similar to wpa_cli */
+		if (buffer[0] == '<' &&
+				(bracket=strchr(buffer,'>')) != NULL &&
+				strncmp(bracket+1,"CTRL-EVENT-BSS-ADDED",20) == 0)
+			numtry--;
 	}
 
 	rv = buffer;
@@ -918,13 +930,14 @@ static int nl80211_get_frequency_scan_cb(struct nl_msg *msg, void *arg)
 
 	static struct nla_policy bss_policy[NL80211_BSS_MAX + 1] = {
 		[NL80211_BSS_FREQUENCY] = { .type = NLA_U32 },
+		[NL80211_BSS_STATUS]    = { .type = NLA_U32 },
 	};
 
 	if (attr[NL80211_ATTR_BSS] &&
 	    !nla_parse_nested(binfo, NL80211_BSS_MAX,
 	                      attr[NL80211_ATTR_BSS], bss_policy))
 	{
-		if (binfo[NL80211_BSS_FREQUENCY])
+		if (binfo[NL80211_BSS_STATUS] && binfo[NL80211_BSS_FREQUENCY])
 			*freq = nla_get_u32(binfo[NL80211_BSS_FREQUENCY]);
 	}
 
@@ -1394,6 +1407,31 @@ int nl80211_get_encryption(const char *ifname, char *buf)
 	return -1;
 }
 
+int nl80211_get_phyname(const char *ifname, char *buf)
+{
+	const char *name;
+
+	name = nl80211_ifname2phy(ifname);
+
+	if (name)
+	{
+		strcpy(buf, name);
+		return 0;
+	}
+	else if ((name = nl80211_phy2ifname(ifname)) != NULL)
+	{
+		name = nl80211_ifname2phy(name);
+
+		if (name)
+		{
+			strcpy(buf, ifname);
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
 
 static int nl80211_get_assoclist_cb(struct nl_msg *msg, void *arg)
 {
@@ -1750,8 +1788,10 @@ static int nl80211_get_scanlist_cb(struct nl_msg *msg, void *arg)
 
 	if (caps & (1<<1))
 		sl->e->mode = IWINFO_OPMODE_ADHOC;
-	else
+	else if (caps & (1<<0))
 		sl->e->mode = IWINFO_OPMODE_MASTER;
+	else
+		sl->e->mode = IWINFO_OPMODE_MESHPOINT;
 
 	if (caps & (1<<4))
 		sl->e->crypto.enabled = 1;
@@ -1851,14 +1891,26 @@ int nl80211_get_scanlist(const char *ifname, char *buf, int *len)
 		{
 			nl80211_get_quality_max(ifname, &qmax);
 
-			/* skip header line */
-			while (*res++ != '\n');
+			count = -1;
 
-			count = 0;
-
-			while (sscanf(res, "%17s %d %d %255s%*[ \t]%127[^\n]\n",
-			              bssid, &freq, &rssi, cipher, ssid) > 0)
-			{
+			do {
+				if (res[0] == '<')
+				{
+					/* skip log lines */
+					goto nextline;
+				}
+				if (count < 0)
+				{
+					/* skip header line */
+					count++;
+					goto nextline;
+				}
+				if (sscanf(res, "%17s %d %d %255s%*[ \t]%127[^\n]\n",
+					      bssid, &freq, &rssi, cipher, ssid) < 5)
+				{
+					/* skip malformed lines */
+					goto nextline;
+				}
 				/* BSSID */
 				e->mac[0] = strtol(&bssid[0],  NULL, 16);
 				e->mac[1] = strtol(&bssid[3],  NULL, 16);
@@ -1871,7 +1923,10 @@ int nl80211_get_scanlist(const char *ifname, char *buf, int *len)
 				memcpy(e->ssid, ssid, min(strlen(ssid), sizeof(e->ssid) - 1));
 
 				/* Mode (assume master) */
-				e->mode = IWINFO_OPMODE_MASTER;
+				if (strstr(cipher,"[MESH]"))
+					e->mode = IWINFO_OPMODE_MESHPOINT;
+				else
+					e->mode = IWINFO_OPMODE_MASTER;
 
 				/* Channel */
 				e->channel = nl80211_freq2channel(freq);
@@ -1903,16 +1958,18 @@ int nl80211_get_scanlist(const char *ifname, char *buf, int *len)
 				/* Crypto */
 				nl80211_get_scancrypto(cipher, &e->crypto);
 
-				/* advance to next line */
-				while (*res && *res++ != '\n');
-
 				count++;
 				e++;
 
 				memset(ssid, 0, sizeof(ssid));
 				memset(bssid, 0, sizeof(bssid));
 				memset(cipher, 0, sizeof(cipher));
-			}
+
+			nextline:
+				/* advance to next line */
+				while( *res && *res++ != '\n' );
+ 			}
+			while( *res );
 
 			*len = count * sizeof(struct iwinfo_scanlist_entry);
 			return 0;
diff --git a/package/iwinfo/src/iwinfo_wext.c b/package/iwinfo/src/iwinfo_wext.c
index cf3dccc..890a36d 100644
--- a/package/iwinfo/src/iwinfo_wext.c
+++ b/package/iwinfo/src/iwinfo_wext.c
@@ -446,6 +446,13 @@ int wext_get_encryption(const char *ifname, char *buf)
 	return -1;
 }
 
+int wext_get_phyname(const char *ifname, char *buf)
+{
+	/* No suitable api in wext */
+	strcpy(buf, ifname);
+	return 0;
+}
+
 int wext_get_mbssid_support(const char *ifname, int *buf)
 {
 	/* No multi bssid support atm */
diff --git a/package/iwinfo/src/iwinfo_wl.c b/package/iwinfo/src/iwinfo_wl.c
index 3d15fc9..1adceb0 100644
--- a/package/iwinfo/src/iwinfo_wl.c
+++ b/package/iwinfo/src/iwinfo_wl.c
@@ -55,6 +55,9 @@ static struct wl_maclist * wl_read_assoclist(const char *ifname)
 	struct wl_maclist *macs;
 	int maclen = 4 + WL_MAX_STA_COUNT * 6;
 
+	if (strstr(ifname, "wds"))
+		return NULL;
+
 	if ((macs = (struct wl_maclist *) malloc(maclen)) != NULL)
 	{
 		memset(macs, 0, maclen);
@@ -321,6 +324,18 @@ int wl_get_encryption(const char *ifname, char *buf)
 	return 0;
 }
 
+int wl_get_phyname(const char *ifname, char *buf)
+{
+	char *p;
+
+	strcpy(buf, ifname);
+
+	if ((p = strchr(buf, '.')) != NULL)
+		*p = 0;
+
+	return 0;
+}
+
 int wl_get_enctype(const char *ifname, char *buf)
 {
 	uint32_t wsec, wpa;
@@ -571,7 +586,46 @@ int wl_get_countrylist(const char *ifname, char *buf, int *len)
 
 int wl_get_hwmodelist(const char *ifname, int *buf)
 {
-	return wext_get_hwmodelist(ifname, buf);
+	int phytype;
+	uint i, band[WLC_BAND_ALL], bands;
+
+	if (!wl_ioctl(ifname, WLC_GET_PHYTYPE, &phytype, sizeof(phytype)) &&
+		!wl_ioctl(ifname, WLC_GET_BANDLIST, band, sizeof(band)))
+	{
+		switch (phytype)
+		{
+			case WLC_PHY_TYPE_A:
+				*buf = IWINFO_80211_A;
+				break;
+			case WLC_PHY_TYPE_B:
+				*buf = IWINFO_80211_B;
+				break;
+			case WLC_PHY_TYPE_LP:
+			case WLC_PHY_TYPE_G:
+			case WLC_PHY_TYPE_N:
+				bands = 0;
+				for (i = 1; i <= band[0]; i++)
+				{
+					bands |= band[i];
+				}
+				*buf = 0;
+				if (bands & WLC_BAND_5G)
+					*buf |= IWINFO_80211_A;
+				if (bands & WLC_BAND_2G)
+				{
+					*buf |= IWINFO_80211_B;
+					*buf |= IWINFO_80211_G;
+				}
+				if (phytype == WLC_PHY_TYPE_N)
+					*buf |= IWINFO_80211_N;
+				break;
+			default:
+				return -1;
+				break;
+		}
+			return 0;
+	}
+	return -1;
 }
 
 int wl_get_mbssid_support(const char *ifname, int *buf)
