diff '--exclude=.svn' -Nur package/mac80211/files/lib/wifi/mac80211.sh ../openwrt-trunk/package/mac80211/files/lib/wifi/mac80211.sh
--- package/mac80211/files/lib/wifi/mac80211.sh	2012-08-17 15:40:46.371971001 +0200
+++ ../openwrt-trunk/package/mac80211/files/lib/wifi/mac80211.sh	2012-08-18 14:47:33.025458002 +0200
@@ -16,6 +16,7 @@
 	config_get beacon_int "$device" beacon_int
 	config_get basic_rate_list "$device" basic_rate
 	config_get_bool noscan "$device" noscan
+	config_get_bool short_preamble "$device" short_preamble "0"
 
 	hostapd_set_log_options base_cfg "$device"
 
@@ -76,6 +77,8 @@
 			brstr="$brstr$brval"
 		done
 	}
+
+	append base_cfg "preamble=$short_preamble" "$N"
 	
 	cat >> "$cfgfile" <<EOF
 ctrl_interface=/var/run/hostapd-$phy
@@ -309,10 +312,10 @@
 		}
 	}
 
-	config_get ath9k_chanbw "$device" ath9k_chanbw
-	[ -n "$ath9k_chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath9k ] && echo "$ath9k_chanbw" > /sys/kernel/debug/ieee80211/$phy/ath9k/chanbw
+	config_get chanbw "$device" chanbw
+	[ -n "$chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath9k ] && echo "$chanbw" > /sys/kernel/debug/ieee80211/$phy/ath9k/chanbw
+	[ -n "$chanbw" -a -d /sys/kernel/debug/ieee80211/$phy/ath5k ] && echo "$chanbw" > /sys/kernel/debug/ieee80211/$phy/ath5k/bwmode
 
-	[ -n "$country" ] && iw reg set "$country"
 	[ "$channel" = "auto" -o "$channel" = "0" ] || {
 		fixed=1
 	}
@@ -442,8 +445,26 @@
 				config_get encryption "$vif" encryption
 				config_get key "$vif" key 1
 				config_get mcast_rate "$vif" mcast_rate
+				config_get htmode "$device" htmode
+				case "$htmode" in
+					HT20|HT40+|HT40-) ;;
+					*) htmode= ;;
+				esac
+
 
 				local keyspec=""
+				[ "$encryption" == "psk" -o "$encryption" == "psk2" ] && {
+					if eval "type wpa_supplicant_setup_vif" 2>/dev/null >/dev/null; then
+						wpa_supplicant_setup_vif "$vif" nl80211 "${hostapd_ctrl:+-H $hostapd_ctrl}" $freq $htmode || {
+							echo "enable_mac80211($device): Failed to set up wpa_supplicant for interface $ifname" >&2
+							# make sure this wifi interface won't accidentally stay open without encryption
+							ifconfig "$ifname" down
+						}
+						# wpa_supplicant will bring the iface up
+						continue
+					fi
+				}
+
 				[ "$encryption" == "wep" ] && {
 					case "$key" in
 						[1234])
@@ -481,12 +502,6 @@
 					[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
 				}
 
-				config_get htmode "$device" htmode
-				case "$htmode" in
-					HT20|HT40+|HT40-) ;;
-					*) htmode= ;;
-				esac
-
 				iw dev "$ifname" ibss join "$ssid" $freq $htmode \
 					${fixed:+fixed-freq} $bssid \
 					${beacon_int:+beacon-interval $beacon_int} \
diff '--exclude=.svn' -Nur package/mac80211/files/regdb.txt ../openwrt-trunk/package/mac80211/files/regdb.txt
--- package/mac80211/files/regdb.txt	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/files/regdb.txt	2012-08-18 14:47:33.025458002 +0200
@@ -0,0 +1,697 @@
+# This is the world regulatory domain
+country 00:
+	(2402 - 2472 @ 40), (3, 20)
+        # Channel 12 - 13. No HT40 channel fits here
+        (2457 - 2482 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS
+        # Channel 14. Only JP enables this and for 802.11b only
+        (2474 - 2494 @ 20), (3, 20), PASSIVE-SCAN, NO-IBSS, NO-OFDM
+        # Channel 36 - 48
+        (5170 - 5250 @ 40), (3, 20)
+        # NB: 5260 MHz - 5700 MHz requies DFS
+        # Channel 149 - 165
+        (5735 - 5835 @ 40), (3, 20), PASSIVE-SCAN, NO-IBSS
+
+
+country AE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AL:
+	(2402 - 2482 @ 20), (N/A, 20)
+
+country AM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 18)
+	(5250 - 5330 @ 20), (N/A, 18), DFS
+
+country AN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country AT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country AW:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country AZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country BA: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BB:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country BD:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country BE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BG: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 23)
+	(5250 - 5290 @ 40), (N/A, 23), DFS
+	(5490 - 5710 @ 40), (N/A, 30), DFS
+
+country BH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5735 - 5835 @ 20), (N/A, 20)
+
+country BL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country BN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country BO:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country BR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country BY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country BZ:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country CA:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country CH: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country CL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country CN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country CO:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country CR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country CS:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country CY: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+# Data from http://www.ctu.eu/164/download/VOR/VOR-12-08-2005-34.pdf
+# and http://www.ctu.eu/164/download/VOR/VOR-12-05-2007-6-AN.pdf
+# Power at 5250 - 5350 MHz and 5470 - 5725 MHz can be doubled if TPC is
+# implemented.
+country CZ: DFS-ETSI
+	(2400 - 2483.5 @ 40), (N/A, 100 mW)
+	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
+	(5250 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
+	(5470 - 5725 @ 40), (N/A, 500 mW), DFS
+
+# Data from "Frequenznutzungsplan" (as published in April 2008), downloaded from
+# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38448/publicationFile/2659/Frequenznutzungsplan2008_Id17448pdf.pdf
+# For the 5GHz range also see
+# http://www.bundesnetzagentur.de/cae/servlet/contentblob/38216/publicationFile/6579/WLAN5GHzVfg7_2010_28042010pdf.pdf
+# The values have been reduced by a factor of 2 (3db) for non TPC devices
+# (in other words: devices with TPC can use twice the tx power of this table).
+# Note that the docs do not require TPC for 5150--5250; the reduction to
+# 100mW thus is not strictly required -- however the conservative 100mW
+# limit is used here as the non-interference with radar and satellite
+# apps relies on the attenuation by the building walls only in the
+# absence of DFS; the neighbour countries have 100mW limit here as well.
+
+country DE: DFS-ETSI
+	# entries 279004 and 280006
+	(2400 - 2483.5 @ 40), (N/A, 100 mW)
+	# entry 303005
+	(5150 - 5250 @ 40), (N/A, 100 mW), NO-OUTDOOR
+	# entries 304002 and 305002
+	(5250 - 5350 @ 40), (N/A, 100 mW), NO-OUTDOOR, DFS
+	# entries 308002, 309001 and 310003
+	(5470 - 5725 @ 40), (N/A, 500 mW), DFS
+
+country DK: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country DO:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country DZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country EC:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country EE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country EG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country ES: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country FI: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country FR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country GB: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GD:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country GR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country GL: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+	(5490 - 5710 @ 20), (N/A, 27), DFS
+
+country GT:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country GU:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country HN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country HK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country HR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country HT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country HU: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country ID:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country IE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country IL:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5150 - 5250 @ 40), (N/A, 200 mW), NO-OUTDOOR
+	(5250 - 5350 @ 40), (N/A, 200 mW), NO-OUTDOOR, DFS
+
+country IN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country IS: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country IR:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country IT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country JM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country JP:
+	(2402 - 2472 @ 40), (N/A, 20)
+	(2457 - 2482 @ 20), (N/A, 20)
+	(2474 - 2494 @ 20), (N/A, 20), NO-OFDM
+	(4910 - 4930 @ 10), (N/A, 23)
+	(4910 - 4990 @ 40), (N/A, 23)
+	(4930 - 4950 @ 10), (N/A, 23)
+	(5030 - 5045 @ 10), (N/A, 23)
+	(5030 - 5090 @ 40), (N/A, 23)
+	(5050 - 5060 @ 10), (N/A, 23)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 23), DFS
+
+country JO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+
+country KE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country KH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country KP:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5330 @ 40), (3, 20)
+	(5160 - 5250 @ 40), (3, 20), DFS
+	(5490 - 5630 @ 40), (3, 30), DFS
+	(5735 - 5815 @ 40), (3, 30)
+
+country KR:
+	(2402 - 2482 @ 20), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 20)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5630 @ 20), (3, 30), DFS
+	(5735 - 5815 @ 20), (3, 30)
+
+country KW:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+
+country KZ:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country LB:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country LI: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 20), DFS
+	(5490 - 5710 @ 20), (3, 20), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country LT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LU: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country LV: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MC: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 18)
+	(5250 - 5330 @ 40), (N/A, 18), DFS
+
+country MA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country MO:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 23)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country MK: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country MY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 30), DFS
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country MX:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country NL: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20), NO-OUTDOOR
+	(5250 - 5330 @ 40), (N/A, 20), NO-OUTDOOR, DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country NO: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country NP:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country NZ:
+	(2402 - 2482 @ 40), (N/A, 30)
+	(5170 - 5250 @ 20), (3, 23)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country OM:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PA:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country PH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PK:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country PL: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country PT: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country PR:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 23), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country QA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 40), (N/A, 30)
+
+country RO: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country RU:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5835 @ 20), (N/A, 30)
+
+country SA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 23)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country SE: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SG:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5735 - 5835 @ 40), (N/A, 20)
+
+country SI: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SK: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+	(5490 - 5710 @ 40), (N/A, 27), DFS
+
+country SV:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (3, 17)
+	(5250 - 5330 @ 20), (3, 23), DFS
+	(5735 - 5835 @ 20), (3, 30)
+
+country SY:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country TW:
+	(2402 - 2472 @ 40), (3, 27)
+	(5270 - 5330 @ 40), (3, 17), DFS
+	(5735 - 5815 @ 40), (3, 30)
+
+country TH:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country TT:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country TN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country TR: DFS-ETSI
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 20), (N/A, 20)
+	(5250 - 5330 @ 20), (N/A, 20), DFS
+
+country UA:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country US: DFS-FCC
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5600 @ 40), (3, 20), DFS
+	(5650 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country UY:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country UZ:
+	(2402 - 2472 @ 40), (3, 27)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country VE:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5735 - 5815 @ 40), (N/A, 23)
+
+country VN:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (N/A, 20)
+	(5250 - 5330 @ 40), (N/A, 20), DFS
+
+country YE:
+	(2402 - 2482 @ 40), (N/A, 20)
+
+country ZA:
+	(2402 - 2482 @ 40), (N/A, 20)
+	(5170 - 5250 @ 40), (3, 17)
+	(5250 - 5330 @ 40), (3, 20), DFS
+	(5490 - 5710 @ 40), (3, 20), DFS
+	(5735 - 5835 @ 40), (3, 30)
+
+country ZW:
+	(2402 - 2482 @ 40), (N/A, 20)
+
diff '--exclude=.svn' -Nur package/mac80211/Makefile ../openwrt-trunk/package/mac80211/Makefile
--- package/mac80211/Makefile	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/Makefile	2012-08-18 14:47:33.135458002 +0200
@@ -1,5 +1,5 @@
 #
-# Copyright (C) 2007-2011 OpenWrt.org
+# Copyright (C) 2007-2012 OpenWrt.org
 #
 # This is free software, licensed under the GNU General Public License v2.
 # See /LICENSE for more information.
@@ -10,10 +10,10 @@
 
 PKG_NAME:=mac80211
 
-PKG_VERSION:=2011-12-01
+PKG_VERSION:=2012-07-16
 PKG_RELEASE:=1
 PKG_SOURCE_URL:=http://mirror2.openwrt.org/sources
-PKG_MD5SUM:=8d1fe2fd6bbabc4fbbf31dfbf015c62c
+PKG_MD5SUM:=8e41a935ad147631b78f99eda7187c1f
 
 PKG_SOURCE:=compat-wireless-$(PKG_VERSION).tar.bz2
 PKG_BUILD_DIR:=$(KERNEL_BUILD_DIR)/compat-wireless-$(PKG_VERSION)
@@ -26,7 +26,7 @@
 	rtl8180 rtl8187 zd1211rw mac80211-hwsim carl9170 b43 b43legacy \
 	ath9k-common ath9k ath9k-htc ath net-libipw net-ipw2100 net-ipw2200 \
 	mwl8k net-hermes net-hermes-pci net-hermes-plx net-hermes-pcmcia \
-	iwl-legacy iwl3945 iwl4965 iwlagn lib80211
+	iwl-legacy iwl3945 iwl4965 iwlagn wl12xx lib80211
 
 PKG_CONFIG_DEPENDS:= \
 	CONFIG_PACKAGE_kmod-mac80211 \
@@ -49,13 +49,13 @@
   SUBMENU:=$(WMENU)
   URL:=http://linuxwireless.org/
   MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
-  DEPENDS:=@(!(TARGET_avr32||TARGET_ep93xx)||BROKEN) @!LINUX_2_4
+  DEPENDS:=@(!(TARGET_avr32||TARGET_ep93xx||TARGET_ps3||TARGET_pxcab)||BROKEN)
 endef
 
 define KernelPackage/cfg80211
   $(call KernelPackage/mac80211/Default)
   TITLE:=cfg80211 - wireless configuration API
-  DEPENDS+= +wireless-tools +iw +crda
+  DEPENDS+= +wireless-tools +iw
   FILES:= \
 	$(PKG_BUILD_DIR)/compat/compat.ko \
 	$(PKG_BUILD_DIR)/net/wireless/cfg80211.ko
@@ -102,11 +102,11 @@
 endef
 
 PKG_LINUX_FIRMWARE_NAME:=linux-firmware
-PKG_LINUX_FIRMWARE_VERSION:=d543c1d98fc240267ee59fff93f7a0f36d9e2fc3
+PKG_LINUX_FIRMWARE_VERSION:=375e9548bf75a5664256d47a2f9e14b79181e02d
 PKG_LINUX_FIRMWARE_SOURCE:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION).tar.bz2
 PKG_LINUX_FIRMWARE_PROTO:=git
-# PKG_LINUX_FIRMWARE_SOURCE_URL:=git://git.kernel.org/pub/scm/linux/kernel/git/dwmw2/linux-firmware.git
-PKG_LINUX_FIRMWARE_SOURCE_URL:=git://git.infradead.org/users/dwmw2/linux-firmware.git
+# PKG_LINUX_FIRMWARE_SOURCE_URL:=git://git.infradead.org/users/dwmw2/linux-firmware.git
+PKG_LINUX_FIRMWARE_SOURCE_URL:=git://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git
 PKG_LINUX_FIRMWARE_SUBDIR:=$(PKG_LINUX_FIRMWARE_NAME)-$(PKG_LINUX_FIRMWARE_VERSION)
 
 define Download/linux-firmware
@@ -389,7 +389,7 @@
 define KernelPackage/ath
   $(call KernelPackage/mac80211/Default)
   TITLE:=Atheros common driver part
-  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx +kmod-mac80211
+  DEPENDS+= @PCI_SUPPORT||USB_SUPPORT||TARGET_ar71xx||TARGET_atheros +kmod-mac80211
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/ath/ath.ko
   AUTOLOAD:=$(call AutoLoad,26,ath)
   MENU:=1
@@ -475,7 +475,7 @@
 	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_wep.ko \
 	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_ccmp.ko \
 	$(PKG_BUILD_DIR)/net/wireless/lib80211_crypt_tkip.ko
-  AUTOLOAD:=$(call AutoLoad,10, \
+  AUTOLOAD:=$(call AutoLoad,21, \
 	lib80211 \
 	lib80211_crypt_wep \
 	lib80211_crypt_ccmp \
@@ -755,6 +755,23 @@
  Kernel modules for Marvell TOPDOG 802.11 Wireless cards
 endef
 
+
+define KernelPackage/wl12xx
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Driver for TI WL12xx
+  URL:=http://wireless.kernel.org/en/users/Drivers/wl12xx
+  DEPENDS+= @TARGET_omap4 +kmod-mac80211
+  FILES:= \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wl12xx/wl12xx.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore.ko \
+	$(PKG_BUILD_DIR)/drivers/net/wireless/ti/wlcore/wlcore_sdio.ko
+  AUTOLOAD:=$(call AutoLoad,61,wlcore wlcore_sdio wl12xx)
+endef
+
+define KernelPackage/wl12xx/description
+ Kernel modules for TI WL12xx
+endef
+
 #Broadcom firmware
 ifneq ($(CONFIG_B43_FW_5_10),)
   PKG_B43_FWV4_NAME:=broadcom-wl
@@ -859,6 +876,7 @@
 
 define KernelPackage/b43
 $(call KernelPackage/b43-common)
+  DEPENDS+= +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma
   TITLE:=Broadcom 43xx wireless support
   FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/b43/b43.ko
   AUTOLOAD:=$(call AutoLoad,30,b43)
@@ -871,12 +889,12 @@
 
 	choice
 		prompt "b43 firmware version"
-		default B43_FW_5_10
+		default B43_FW_5_100_138
 		help
 		  This option allows you to select the version of the b43 firmware.
 
 	config B43_FW_4_150
-		bool "Firmware 410.2160 from driver 4.150.10.5 (stable)"
+		bool "Firmware 410.2160 from driver 4.150.10.5 (old stable)"
 		help
 		  Stable firmware for BCM43xx devices.
 
@@ -899,9 +917,9 @@
 		  This firmware is mostly untested. It is needed for some N-PHY devices.
 
 		  If unsure, select the "stable" firmware.
-
+   
 	config B43_FW_5_100_138
-		bool "Firmware 666.2 from driver 5.100.138"
+		bool "Firmware 666.2 from driver 5.100.138 (stable)"
 		help
 		  Newer experimental firmware for BCM43xx devices.
 
@@ -938,7 +956,7 @@
 	config B43_FW_SQUASH_COREREVS
 		string "Core revisions to include"
 		depends on B43_FW_SQUASH
-		default "5,6,7,8,9,10,13,14,15"
+		default "5,6,7,8,9,10,11,13,14,15,16"
 		help
 		  This is a comma seperated list of core revision numbers.
 
@@ -951,7 +969,7 @@
 	config B43_FW_SQUASH_PHYTYPES
 		string "PHY types to include"
 		depends on B43_FW_SQUASH
-		default "G,LP"
+		default "G,LP,N"
 		help
 		  This is a comma seperated list of PHY types:
 		    A  => A-PHY
@@ -977,7 +995,6 @@
 
 	config PACKAGE_B43_PIO
 		bool "Enable support for PIO transfer mode"
-		depends BROKEN
 		default n
 		help
 		  Enable support for using PIO instead of DMA. Unless you have DMA
@@ -987,8 +1004,7 @@
 
 	config PACKAGE_B43_PHY_N
 		bool "Enable support for N-PHYs"
-		depends on BROKEN
-		select B43_FW_5_100_138
+		default y
 		help
 		  Enable support for BCM4321 and BCM4322.
 
@@ -998,8 +1014,6 @@
 
 	config PACKAGE_B43_PHY_HT
 		bool "Enable support for HT-PHYs"
-		depends on BROKEN
-		select B43_FW_5_100_138
 		default n
 		help
 		  Currently broken.
@@ -1009,7 +1023,6 @@
 	config PACKAGE_B43_PHY_LCN
 		bool "Enable support for LCN-PHYs"
 		depends on BROKEN
-		select B43_FW_5_100_138
 		default n
 		help
 		  Currently broken.
@@ -1065,8 +1078,62 @@
 Kernel module for Broadcom 43xx-legacy wireless support (mac80211 stack) new
 endef
 
+
+define KernelPackage/brcmutil
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Broadcom IEEE802.11n common driver parts
+  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
+  DEPENDS+=@PCI_SUPPORT||USB_SUPPORT
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmutil/brcmutil.ko
+  AUTOLOAD:=$(call AutoLoad,30,brcmutil)
+  MENU:=1
+endef
+
+define KernelPackage/brcmutil/description
+ This module contains some common parts needed by Broadcom Wireless drivers brcmsmac and brcmfmac.
+endef
+
+define KernelPackage/brcmutil/config
+	menu "Configuration"
+		depends on PACKAGE_kmod-brcmutil
+
+	config PACKAGE_BRCM80211_DEBUG
+		bool "Broadcom wireless driver debugging"
+		help
+		  Say Y, if you want to debug brcmsmac and brcmfmac wireless driver.
+
+	endmenu
+endef
+
+define KernelPackage/brcmsmac
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Broadcom IEEE802.11n PCIe SoftMAC WLAN driver
+  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
+  DEPENDS+= +kmod-mac80211 +@DRIVER_11N_SUPPORT +!TARGET_brcm47xx:kmod-bcma +kmod-lib-cordic +kmod-lib-crc8 +kmod-brcmutil
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmsmac/brcmsmac.ko
+  AUTOLOAD:=$(call AutoLoad,31,brcmsmac)
+endef
+
+define KernelPackage/brcmsmac/description
+ Kernel module for Broadcom IEEE802.11n PCIe Wireless cards
+endef
+
+define KernelPackage/brcmfmac
+  $(call KernelPackage/mac80211/Default)
+  TITLE:=Broadcom IEEE802.11n USB FullMAC WLAN driver
+  URL:=http://linuxwireless.org/en/users/Drivers/brcm80211
+  DEPENDS+= @USB_SUPPORT +kmod-usb-core +kmod-cfg80211 +@DRIVER_11N_SUPPORT +kmod-brcmutil
+  FILES:=$(PKG_BUILD_DIR)/drivers/net/wireless/brcm80211/brcmfmac/brcmfmac.ko
+  AUTOLOAD:=$(call AutoLoad,60,brcmfmac)
+endef
+
+define KernelPackage/brcmfmac/description
+ Kernel module for Broadcom IEEE802.11n USB Wireless cards
+endef
+
 BUILDFLAGS:= \
 	-I$(PKG_BUILD_DIR)/include \
+	-DCONFIG_CFG80211_INTERNAL_REGDB=y \
 	$(foreach opt,$(CONFOPTS),-DCONFIG_$(opt)) \
 	$(if $(CONFIG_PCI),-DCONFIG_B43_PCI_AUTOSELECT -DCONFIG_B43_PCICORE_AUTOSELECT) \
 	$(if $(CONFIG_LEDS_TRIGGERS), -DCONFIG_MAC80211_LEDS -DCONFIG_LEDS_TRIGGERS -DCONFIG_B43_LEDS -DCONFIG_B43LEGACY_LEDS) \
@@ -1085,6 +1152,7 @@
 	$(if $(CONFIG_PACKAGE_B43_PHY_N),-DCONFIG_B43_PHY_N) \
 	$(if $(CONFIG_PACKAGE_B43_PHY_HT),-DCONFIG_B43_PHY_HT) \
 	$(if $(CONFIG_PACKAGE_B43_PHY_LCN),-DCONFIG_B43_PHY_LCN) \
+	-DCONFIG_B43_BCMA -DCONFIG_B43_BCMA_EXTRA \
 	-DCONFIG_B43_SSB \
 	$(if $(CONFIG_PACKAGE_RT2X00_LIB_DEBUGFS),-DCONFIG_RT2X00_LIB_DEBUGFS) \
 	$(if $(CONFIG_PACKAGE_RT2X00_DEBUG),-DCONFIG_RT2X00_DEBUG) \
@@ -1095,16 +1163,21 @@
 	$(if $(NEED_RT2X00_LIB_LEDS),-DCONFIG_RT2X00_LIB_LEDS) \
 	$(if $(CONFIG_PACKAGE_kmod-rt2x00-pci),-DCONFIG_RT2X00_LIB_PCI) \
 	$(if $(CONFIG_PACKAGE_kmod-rt2x00-usb),-DCONFIG_RT2X00_LIB_USB) \
+	$(if $(CONFIG_PACKAGE_kmod-rt2x00-usb),-DCONFIG_RT2800USB_RT53XX) \
 	$(if $(CONFIG_PACKAGE_kmod-rt2x00-soc),-DCONFIG_RT2X00_LIB_SOC) \
 	$(if $(CONFIG_TARGET_atheros),-DCONFIG_ATH5K_AHB,-DCONFIG_ATH5K_PCI) \
 	$(if $(CONFIG_PACKAGE_kmod-iwl3945),-DCONFIG_IWL3945) \
-	$(if $(CONFIG_PACKAGE_kmod-iwl4965),-DCONFIG_COMPAT_IWL4965)
+	$(if $(CONFIG_PACKAGE_kmod-iwl4965),-DCONFIG_COMPAT_IWL4965) \
+	$(if $(CONFIG_PACKAGE_kmod-wl12xx),-DCONFIG_WL12XX -DCONFIG_COMPAT_WL12XX_SDIO) \
+	$(if $(CONFIG_PACKAGE_BRCM80211_DEBUG),-DCONFIG_BRCMDBG) \
+	$(if $(CONFIG_PACKAGE_kmod-brcmfmac),-DCONFIG_BRCMFMAC_USB)
 
 MAKE_OPTS:= \
 	CROSS_COMPILE="$(KERNEL_CROSS)" \
 	ARCH="$(LINUX_KARCH)" \
 	EXTRA_CFLAGS="$(BUILDFLAGS)" \
 	$(foreach opt,$(CONFOPTS),CONFIG_$(opt)=m) \
+	CONFIG_CFG80211_INTERNAL_REGDB=y \
 	CONFIG_CFG80211=$(if $(CONFIG_PACKAGE_kmod-cfg80211),m) \
 	CONFIG_MAC80211=$(if $(CONFIG_PACKAGE_kmod-mac80211),m) \
 	CONFIG_MAC80211_RC_MINSTREL=y \
@@ -1171,7 +1244,6 @@
 	CONFIG_RT2800_LIB=$(if $(CONFIG_PACKAGE_kmod-rt2800-lib),m) \
 	CONFIG_RT2800PCI=$(if $(CONFIG_PACKAGE_kmod-rt2800-pci),m) \
 	CONFIG_RT2800USB=$(if $(CONFIG_PACKAGE_kmod-rt2800-usb),m) \
-	CONFIG_RT2800USB_RT53XX=$(if $(CONFIG_PACKAGE_kmod-rt2800-usb),y) \
 	CONFIG_RTL8180=$(if $(CONFIG_PACKAGE_kmod-rtl8180),m) \
 	CONFIG_RTL8187=$(if $(CONFIG_PACKAGE_kmod-rtl8187),m) \
 	CONFIG_RTL8192CE= \
@@ -1205,7 +1277,10 @@
 	CONFIG_USB_NET_CDCETHER= \
 	CONFIG_USB_USBNET= \
 	CONFIG_AT76C50X_USB= \
-	CONFIG_WL12XX= \
+	CONFIG_WL_TI=$(if $(CONFIG_PACKAGE_kmod-wl12xx),m) \
+	CONFIG_WLCORE=$(if $(CONFIG_PACKAGE_kmod-wl12xx),m) \
+	CONFIG_WL12XX=$(if $(CONFIG_PACKAGE_kmod-wl12xx),m) \
+	CONFIG_WLCORE_SDIO=$(if $(CONFIG_PACKAGE_kmod-wl12xx),m) \
 	CONFIG_EEPROM_93CX6= \
 	CONFIG_HERMES=$(if $(CONFIG_PACKAGE_kmod-net-hermes),m) \
 	CONFIG_HERMES_CACHE_FW_ON_INIT= \
@@ -1220,6 +1295,7 @@
 	CONFIG_ORINOCO_USB= \
 	CONFIG_IWM= \
 	CONFIG_MWIFIEX= \
+	CONFIG_ATH6KL= \
 	CONFIG_MAC80211_RC_MINSTREL_HT=y \
 	MADWIFI= \
 	CONFIG_B44= \
@@ -1227,11 +1303,13 @@
 	CONFIG_ATL2= \
 	CONFIG_ATL1E= \
 	CONFIG_ATL1C= \
-	CONFIG_BRCMFMAC= \
-	CONFIG_BRCMUMAC= \
-	CONFIG_BRCMSMAC= \
+	CONFIG_BRCMUTIL=$(if $(CONFIG_PACKAGE_kmod-brcmutil),m) \
+	CONFIG_BRCMSMAC=$(if $(CONFIG_PACKAGE_kmod-brcmsmac),m) \
+	CONFIG_BRCMFMAC=$(if $(CONFIG_PACKAGE_kmod-brcmfmac),m) \
+	CONFIG_BRCMFMAC_USB=$(if $(CONFIG_PACKAGE_kmod-brcmfmac),y) \
+	CONFIG_BRCMDBG=$(if $(CONFIG_PACKAGE_BRCM80211_DEBUG),y) \
 	KLIB_BUILD="$(LINUX_DIR)" \
-	MODPROBE=: \
+	MODPROBE=true \
 	KLIB=$(TARGET_MODULES_DIR) \
 	KERNEL_SUBLEVEL=$(lastword $(subst ., ,$(KERNEL_PATCHVER))) \
 	KBUILD_LDFLAGS_MODULE_PREREQ=
@@ -1250,16 +1328,29 @@
 	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(ZD1211FW_NAME)-$(ZD1211FW_VERSION).tar.bz2
 	$(TAR) -C $(PKG_BUILD_DIR) -xjf $(DL_DIR)/$(PKG_LINUX_FIRMWARE_SOURCE)
 	rm -rf $(PKG_BUILD_DIR)/include/linux/ssb
+	rm -rf $(PKG_BUILD_DIR)/include/linux/bcma
+	rm -rf $(PKG_BUILD_DIR)/include/net/bluetooth/
+	rm -f $(PKG_BUILD_DIR)/include/linux/eeprom_93cx6.h
+	rm -f $(PKG_BUILD_DIR)/include/linux/wl12xx.h
+	rm -f $(PKG_BUILD_DIR)/include/linux/spi/libertas_spi.h
 	rm -f $(PKG_BUILD_DIR)/include/net/ieee80211.h
+	echo 'compat-wireless-$(PKG_VERSION)-$(PKG_RELEASE)-$(REVISION)' > $(PKG_BUILD_DIR)/compat_version
+	$(CP) ./files/regdb.txt $(PKG_BUILD_DIR)/net/wireless/db.txt
 endef
 
 ifneq ($(CONFIG_PACKAGE_kmod-cfg80211)$(CONFIG_PACKAGE_kmod-lib80211),)
  define Build/Compile/kmod
 	rm -rf $(PKG_BUILD_DIR)/modules
-	$(MAKE) $(PKG_JOBS) -C "$(PKG_BUILD_DIR)" $(MAKE_OPTS) all
+	$(MAKE) $(PKG_JOBS) -C "$(PKG_BUILD_DIR)" $(MAKE_OPTS) modules
  endef
 endif
 
+define Build/Configure
+	cmp $(PKG_BUILD_DIR)/include/linux/ath9k_platform.h $(LINUX_DIR)/include/linux/ath9k_platform.h
+	#cmp $(PKG_BUILD_DIR)/include/linux/ath5k_platform.h $(LINUX_DIR)/include/linux/ath5k_platform.h
+	#cmp $(PKG_BUILD_DIR)/include/linux/rt2x00_platform.h $(LINUX_DIR)/include/linux/rt2x00_platform.h
+endef
+
 define Build/Compile
 	$(call Build/Compile/kmod)
 endef
@@ -1341,6 +1432,17 @@
 	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/rt2870.bin $(1)/lib/firmware/
 endef
 
+define KernelPackage/wl12xx/install
+	$(INSTALL_DIR) $(1)/lib/firmware/ti-connectivity
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-4-mr.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-4-plt.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl127x-fw-4-sr.bin \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/ti-connectivity/wl1271-nvs.bin \
+		$(1)/lib/firmware/ti-connectivity
+endef
+
+
 define KernelPackage/zd1211rw/install
 	$(INSTALL_DIR) $(1)/lib/firmware/zd1211
 	$(INSTALL_DATA) $(PKG_BUILD_DIR)/$(ZD1211FW_NAME)/zd1211* $(1)/lib/firmware/zd1211
@@ -1355,14 +1457,14 @@
 endef
 
 define KernelPackage/mwl8k/install
-	$(INSTALL_DIR) $(1)/lib/firmware
+	$(INSTALL_DIR) $(1)/lib/firmware/mwl8k
 	$(INSTALL_DATA) \
 		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366_ap-2.fw \
 		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8366.fw \
 		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8366.fw \
 		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/fmimage_8687.fw \
 		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/mwl8k/helper_8687.fw \
-		$(1)/lib/firmware/
+		$(1)/lib/firmware/mwl8k/
 endef
 
 define KernelPackage/net-ipw2100/install
@@ -1462,6 +1564,21 @@
 endif
 endef
 
+define KernelPackage/brcmsmac/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx-0.fw \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/bcm43xx_hdr-0.fw \
+		$(1)/lib/firmware/brcm/
+endef
+
+define KernelPackage/brcmfmac/install
+	$(INSTALL_DIR) $(1)/lib/firmware/brcm
+	$(INSTALL_DATA) \
+		$(PKG_BUILD_DIR)/$(PKG_LINUX_FIRMWARE_SUBDIR)/brcm/brcmfmac43236b.bin \
+		$(1)/lib/firmware/brcm/
+endef
+
 $(eval $(call KernelPackage,ath5k))
 $(eval $(call KernelPackage,lib80211))
 $(eval $(call KernelPackage,libertas-usb))
@@ -1495,6 +1612,9 @@
 $(eval $(call KernelPackage,carl9170))
 $(eval $(call KernelPackage,b43))
 $(eval $(call KernelPackage,b43legacy))
+$(eval $(call KernelPackage,brcmutil))
+$(eval $(call KernelPackage,brcmsmac))
+$(eval $(call KernelPackage,brcmfmac))
 $(eval $(call KernelPackage,net-libipw))
 $(eval $(call KernelPackage,net-ipw2100))
 $(eval $(call KernelPackage,net-ipw2200))
@@ -1507,3 +1627,4 @@
 $(eval $(call KernelPackage,net-hermes-pci))
 $(eval $(call KernelPackage,net-hermes-plx))
 $(eval $(call KernelPackage,net-hermes-pcmcia))
+$(eval $(call KernelPackage,wl12xx))
diff '--exclude=.svn' -Nur package/mac80211/patches/000-disable_ethernet.patch ../openwrt-trunk/package/mac80211/patches/000-disable_ethernet.patch
--- package/mac80211/patches/000-disable_ethernet.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/000-disable_ethernet.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -29,9 +29,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
+@@ -45,9 +45,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
  
  obj-$(CONFIG_COMPAT_NET_USB_MODULES) += drivers/net/usb/
  
diff '--exclude=.svn' -Nur package/mac80211/patches/001-disable_b44.patch ../openwrt-trunk/package/mac80211/patches/001-disable_b44.patch
--- package/mac80211/patches/001-disable_b44.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/001-disable_b44.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,13 +1,13 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -378,8 +378,8 @@ CONFIG_B43_BCMA_PIO=y
+@@ -376,8 +376,8 @@ export CONFIG_B43_BCMA_EXTRA=y
  
- CONFIG_P54_PCI=m
+ export CONFIG_P54_PCI=m
  
--CONFIG_B44=m
--CONFIG_B44_PCI=y
-+# CONFIG_B44=m
-+# CONFIG_B44_PCI=y
+-export CONFIG_B44=m
+-export CONFIG_B44_PCI=y
++# export CONFIG_B44=m
++# export CONFIG_B44_PCI=y
  
- CONFIG_RTL8180=m
+ export CONFIG_RTL8180=m
  
diff '--exclude=.svn' -Nur package/mac80211/patches/002-disable_rfkill.patch ../openwrt-trunk/package/mac80211/patches/002-disable_rfkill.patch
--- package/mac80211/patches/002-disable_rfkill.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/002-disable_rfkill.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,26 +1,26 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -95,7 +95,7 @@ endif # build check
+@@ -77,7 +77,7 @@ endif # build check
  endif # kernel Makefile check
  
  # These both are needed by compat-wireless || compat-bluetooth so enable them
-- CONFIG_COMPAT_RFKILL=y
-+# CONFIG_COMPAT_RFKILL=y
+- export CONFIG_COMPAT_RFKILL=y
++# export CONFIG_COMPAT_RFKILL=y
  
  ifeq ($(CONFIG_MAC80211),y)
  $(error "ERROR: you have MAC80211 compiled into the kernel, CONFIG_MAC80211=y, as such you cannot replace its mac80211 driver. You need this set to CONFIG_MAC80211=m. If you are using Fedora upgrade your kernel as later version should this set as modular. For further information on Fedora see https://bugzilla.redhat.com/show_bug.cgi?id=470143. If you are using your own kernel recompile it and make mac80211 modular")
-@@ -671,10 +671,10 @@ endif #CONFIG_COMPAT_KERNEL_2_6_27
+@@ -688,10 +688,10 @@ endif #CONFIG_COMPAT_KERNEL_2_6_27
  # We need the backported rfkill module on kernel < 2.6.31.
  # In more recent kernel versions use the in kernel rfkill module.
  ifdef CONFIG_COMPAT_KERNEL_2_6_31
--CONFIG_RFKILL_BACKPORT=m
-+# CONFIG_RFKILL_BACKPORT=m
+-export CONFIG_RFKILL_BACKPORT=m
++#export CONFIG_RFKILL_BACKPORT=m
  ifdef CONFIG_LEDS_TRIGGERS
--CONFIG_RFKILL_BACKPORT_LEDS=y
-+# CONFIG_RFKILL_BACKPORT_LEDS=y
+-export CONFIG_RFKILL_BACKPORT_LEDS=y
++#export CONFIG_RFKILL_BACKPORT_LEDS=y
  endif #CONFIG_LEDS_TRIGGERS
--CONFIG_RFKILL_BACKPORT_INPUT=y
-+# CONFIG_RFKILL_BACKPORT_INPUT=y
+-export CONFIG_RFKILL_BACKPORT_INPUT=y
++#export CONFIG_RFKILL_BACKPORT_INPUT=y
  endif #CONFIG_COMPAT_KERNEL_2_6_31
  
 --- a/include/linux/rfkill.h
diff '--exclude=.svn' -Nur package/mac80211/patches/003-disable_bt.patch ../openwrt-trunk/package/mac80211/patches/003-disable_bt.patch
--- package/mac80211/patches/003-disable_bt.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/003-disable_bt.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,13 +1,15 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -117,8 +117,8 @@ ifndef CONFIG_COMPAT_KERNEL_2_6_27
+@@ -99,9 +99,9 @@ ifndef CONFIG_COMPAT_KERNEL_2_6_27
  ifeq ($(CONFIG_BT),y)
  # we'll ignore compiling bluetooth
  else
-- CONFIG_COMPAT_BLUETOOTH=y
-- CONFIG_COMPAT_BLUETOOTH_MODULES=m
-+# CONFIG_COMPAT_BLUETOOTH=y
-+# CONFIG_COMPAT_BLUETOOTH_MODULES=m
+- export CONFIG_COMPAT_BLUETOOTH=y
+- export CONFIG_COMPAT_BLUETOOTH_MODULES=m
+- export CONFIG_HID_GENERIC=m
++# export CONFIG_COMPAT_BLUETOOTH=y
++# export CONFIG_COMPAT_BLUETOOTH_MODULES=m
++# export CONFIG_HID_GENERIC=m
  endif
  endif #CONFIG_COMPAT_KERNEL_2_6_27
  
diff '--exclude=.svn' -Nur package/mac80211/patches/005-disable_ssb_build.patch ../openwrt-trunk/package/mac80211/patches/005-disable_ssb_build.patch
--- package/mac80211/patches/005-disable_ssb_build.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/005-disable_ssb_build.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -29,7 +29,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
+@@ -45,7 +45,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
  
  obj-$(CONFIG_COMPAT_NET_USB_MODULES) += drivers/net/usb/
  
@@ -10,15 +10,16 @@
  
 --- a/config.mk
 +++ b/config.mk
-@@ -9,7 +9,6 @@ ifeq ($(wildcard $(KLIB_BUILD)/.config),
-  CONFIG_PCI=y
-  CONFIG_USB=y
-  CONFIG_PCMCIA=y
-- CONFIG_SSB=m
+@@ -3,7 +3,7 @@ ifeq ($(wildcard $(KLIB_BUILD)/.config),
+  export CONFIG_PCI=y
+  export CONFIG_USB=y
+  export CONFIG_PCMCIA=y
+- export CONFIG_SSB=m
++# export CONFIG_SSB=m
  else
  include $(KLIB_BUILD)/.config
  endif
-@@ -354,7 +353,8 @@ CONFIG_IPW2200_QOS=y
+@@ -352,7 +352,8 @@ export CONFIG_IPW2200_QOS=y
  # % echo 1 > /sys/bus/pci/drivers/ipw2200/*/rtap_iface
  endif #CONFIG_WIRELESS_EXT
  
@@ -26,22 +27,23 @@
 +# disabled
 +ifdef __CONFIG_SSB
  # Sonics Silicon Backplane
- CONFIG_SSB_SPROM=y
+ export CONFIG_SSB_SPROM=y
  
-@@ -367,7 +367,7 @@ endif #CONFIG_PCMCIA
- # CONFIG_SSB_DEBUG=y
- CONFIG_SSB_DRIVER_PCICORE=y
- CONFIG_B43_SSB=y
+@@ -365,7 +366,7 @@ endif #CONFIG_PCMCIA
+ # export CONFIG_SSB_DEBUG=y
+ export CONFIG_SSB_DRIVER_PCICORE=y
+ export CONFIG_B43_SSB=y
 -endif #CONFIG_SSB
 +endif #__CONFIG_SSB
  
- CONFIG_BCMA=m
- CONFIG_BCMA_BLOCKIO=y
-@@ -574,7 +574,6 @@ endif #CONFIG_SPI_MASTER end of SPI driv
+ export CONFIG_BCMA=m
+ export CONFIG_BCMA_BLOCKIO=y
+@@ -582,7 +583,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
  
  ifdef CONFIG_MMC
  
--CONFIG_SSB_SDIOHOST=y
- CONFIG_B43_SDIO=y
+-export CONFIG_SSB_SDIOHOST=y
++# export CONFIG_SSB_SDIOHOST=y
+ export CONFIG_B43_SDIO=y
  
  ifdef CONFIG_CRC7
diff '--exclude=.svn' -Nur package/mac80211/patches/006-disable_bcma_build.patch ../openwrt-trunk/package/mac80211/patches/006-disable_bcma_build.patch
--- package/mac80211/patches/006-disable_bcma_build.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/006-disable_bcma_build.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,6 +1,6 @@
 --- a/Makefile
 +++ b/Makefile
-@@ -29,7 +29,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
+@@ -45,7 +45,6 @@ obj-$(CONFIG_COMPAT_WIRELESS_MODULES) +=
  
  obj-$(CONFIG_COMPAT_NET_USB_MODULES) += drivers/net/usb/
  
@@ -10,21 +10,21 @@
  ifeq ($(CONFIG_STAGING_EXCLUDE_BUILD),)
 --- a/config.mk
 +++ b/config.mk
-@@ -369,12 +369,12 @@ CONFIG_SSB_DRIVER_PCICORE=y
- CONFIG_B43_SSB=y
+@@ -368,12 +368,12 @@ export CONFIG_SSB_DRIVER_PCICORE=y
+ export CONFIG_B43_SSB=y
  endif #__CONFIG_SSB
  
--CONFIG_BCMA=m
--CONFIG_BCMA_BLOCKIO=y
--CONFIG_BCMA_HOST_PCI=y
-+# CONFIG_BCMA=m
-+# CONFIG_BCMA_BLOCKIO=y
-+# CONFIG_BCMA_HOST_PCI=y
- # CONFIG_BCMA_DEBUG=y
--CONFIG_B43_BCMA=y
--CONFIG_B43_BCMA_PIO=y
-+# CONFIG_B43_BCMA=y
-+# CONFIG_B43_BCMA_PIO=y
+-export CONFIG_BCMA=m
+-export CONFIG_BCMA_BLOCKIO=y
+-export CONFIG_BCMA_HOST_PCI=y
++# export CONFIG_BCMA=m
++# export CONFIG_BCMA_BLOCKIO=y
++# export CONFIG_BCMA_HOST_PCI=y
+ # export CONFIG_BCMA_DEBUG=y
+-export CONFIG_B43_BCMA=y
+-export CONFIG_B43_BCMA_EXTRA=y
++# export CONFIG_B43_BCMA=y
++# export CONFIG_B43_BCMA_EXTRA=y
  
- CONFIG_P54_PCI=m
+ export CONFIG_P54_PCI=m
  
diff '--exclude=.svn' -Nur package/mac80211/patches/007-remove_misc_drivers.patch ../openwrt-trunk/package/mac80211/patches/007-remove_misc_drivers.patch
--- package/mac80211/patches/007-remove_misc_drivers.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/007-remove_misc_drivers.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,62 +1,66 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -252,7 +252,7 @@ $(warning "WARNING: CONFIG_CFG80211_WEXT
+@@ -240,7 +240,7 @@ $(warning "WARNING: CONFIG_CFG80211_WEXT
  endif #CONFIG_WIRELESS_EXT
  
  ifdef CONFIG_STAGING
--CONFIG_COMPAT_STAGING=m
-+# CONFIG_COMPAT_STAGING=m
+-export CONFIG_COMPAT_STAGING=m
++# export CONFIG_COMPAT_STAGING=m
  endif #CONFIG_STAGING
  
  # mac80211 test driver
-@@ -406,13 +406,13 @@ endif #CONFIG_CRC_ITU_T
- CONFIG_MWL8K=m
+@@ -405,15 +405,15 @@ endif #CONFIG_CRC_ITU_T
+ export CONFIG_MWL8K=m
  
  # Ethernet drivers go here
--CONFIG_ATL1=m
--CONFIG_ATL2=m
--CONFIG_ATL1E=m
-+# CONFIG_ATL1=m
-+# CONFIG_ATL2=m
-+# CONFIG_ATL1E=m
- ifdef CONFIG_COMPAT_KERNEL_2_6_27
--CONFIG_ATL1C=n
-+# CONFIG_ATL1C=n
- else #CONFIG_COMPAT_KERNEL_2_6_27
--CONFIG_ATL1C=m
-+# CONFIG_ATL1C=m
- endif #CONFIG_COMPAT_KERNEL_2_6_27
+-export CONFIG_ATL1=m
+-export CONFIG_ATL2=m
+-export CONFIG_ATL1E=m
++# export CONFIG_ATL1=m
++# export CONFIG_ATL2=m
++# export CONFIG_ATL1E=m
+ ifdef CONFIG_COMPAT_KERNEL_2_6_28
+-export CONFIG_ATL1C=m
+-export CONFIG_ALX=n
++# export CONFIG_ATL1C=m
++# export CONFIG_ALX=n
+ else #CONFIG_COMPAT_KERNEL_2_6_28
+-export CONFIG_ATL1C=n
+-export CONFIG_ALX=m
++# export CONFIG_ATL1C=n
++# export CONFIG_ALX=m
+ endif #CONFIG_COMPAT_KERNEL_2_6_28
  
  ifdef CONFIG_WIRELESS_EXT
-@@ -471,21 +471,21 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
+@@ -474,21 +474,21 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
  # Note: this depends on CONFIG_USB_NET_RNDIS_HOST and CONFIG_USB_NET_CDCETHER
  # it also requires new RNDIS_HOST and CDC_ETHER modules which we add
  ifdef CONFIG_COMPAT_KERNEL_2_6_29
--CONFIG_USB_COMPAT_USBNET=n
--CONFIG_USB_NET_COMPAT_RNDIS_HOST=n
--CONFIG_USB_NET_COMPAT_RNDIS_WLAN=n
--CONFIG_USB_NET_COMPAT_CDCETHER=n
-+# CONFIG_USB_COMPAT_USBNET=n
-+# CONFIG_USB_NET_COMPAT_RNDIS_HOST=n
-+# CONFIG_USB_NET_COMPAT_RNDIS_WLAN=n
-+# CONFIG_USB_NET_COMPAT_CDCETHER=n
+-export CONFIG_USB_COMPAT_USBNET=n
+-export CONFIG_USB_NET_COMPAT_RNDIS_HOST=n
+-export CONFIG_USB_NET_COMPAT_RNDIS_WLAN=n
+-export CONFIG_USB_NET_COMPAT_CDCETHER=n
++# export CONFIG_USB_COMPAT_USBNET=n
++# export CONFIG_USB_NET_COMPAT_RNDIS_HOST=n
++# export CONFIG_USB_NET_COMPAT_RNDIS_WLAN=n
++# export CONFIG_USB_NET_COMPAT_CDCETHER=n
  else #CONFIG_COMPAT_KERNEL_2_6_29
--CONFIG_USB_COMPAT_USBNET=m
-+# CONFIG_USB_COMPAT_USBNET=m
+-export CONFIG_USB_COMPAT_USBNET=m
++# export CONFIG_USB_COMPAT_USBNET=m
  ifdef CONFIG_USB_NET_CDCETHER
--CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
--CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
-+# CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
-+# CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
+-export CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
+-export CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
++# export CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
++# export CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
  endif #CONFIG_USB_NET_CDCETHER
  ifdef CONFIG_USB_NET_CDCETHER_MODULE
--CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
--CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
-+# CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
-+# CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
+-export CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
+-export CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
++# export CONFIG_USB_NET_COMPAT_RNDIS_HOST=m
++# export CONFIG_USB_NET_COMPAT_RNDIS_WLAN=m
  endif #CONFIG_USB_NET_CDCETHER
--CONFIG_USB_NET_COMPAT_CDCETHER=m
-+# CONFIG_USB_NET_COMPAT_CDCETHER=m
+-export CONFIG_USB_NET_COMPAT_CDCETHER=m
++# export CONFIG_USB_NET_COMPAT_CDCETHER=m
  endif #CONFIG_COMPAT_KERNEL_2_6_29
  
  
diff '--exclude=.svn' -Nur package/mac80211/patches/008-disable_mesh.patch ../openwrt-trunk/package/mac80211/patches/008-disable_mesh.patch
--- package/mac80211/patches/008-disable_mesh.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/008-disable_mesh.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,11 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -188,7 +188,7 @@ CONFIG_MAC80211_LEDS=y
+@@ -176,7 +176,7 @@ export CONFIG_MAC80211_LEDS=y
  endif #CONFIG_LEDS_TRIGGERS
  
  # enable mesh networking too
--CONFIG_MAC80211_MESH=y
-+# CONFIG_MAC80211_MESH=y
+-export CONFIG_MAC80211_MESH=y
++# export CONFIG_MAC80211_MESH=y
  
- CONFIG_CFG80211=m
- CONFIG_CFG80211_DEFAULT_PS=y
+ export CONFIG_CFG80211=m
+ export CONFIG_CFG80211_DEFAULT_PS=y
diff '--exclude=.svn' -Nur package/mac80211/patches/009-remove_mac80211_module_dependence.patch ../openwrt-trunk/package/mac80211/patches/009-remove_mac80211_module_dependence.patch
--- package/mac80211/patches/009-remove_mac80211_module_dependence.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/009-remove_mac80211_module_dependence.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,26 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -58,23 +58,6 @@ $(error "ERROR: Your 2.6.27 kernel has C
+@@ -53,7 +53,7 @@ endif
+ ifeq ($(KERNEL_VERSION),2)
+ ifeq ($(shell test $(KERNEL_VERSION) -eq 2 -a $(KERNEL_26SUBLEVEL) -ge 27 -a $(KERNEL_26SUBLEVEL) -le 31 && echo yes),yes)
+ ifeq ($(CONFIG_MAC80211),)
+-$(error "ERROR: Your >=2.6.27 and <= 2.6.31 kernel has CONFIG_MAC80211 disabled, you should have it CONFIG_MAC80211=m if you want to use this thing.")
++# $(error "ERROR: Your >=2.6.27 and <= 2.6.31 kernel has CONFIG_MAC80211 disabled, you should have it CONFIG_MAC80211=m if you want to use this thing.")
+ endif
  endif
  endif
- 
--# This is because with CONFIG_MAC80211 include/linux/skbuff.h will
--# enable on 2.6.27 a new attribute:
--#
--# skb->do_not_encrypt
--#
--# and on 2.6.28 another new attribute:
--#
--# skb->requeue
--#
--# In kernel 2.6.32 both attributes were removed.
--#
--ifeq ($(shell test $(KERNEL_VERSION) -eq 2 -a $(KERNEL_SUBLEVEL) -ge 27 -a $(KERNEL_SUBLEVEL) -le 31 && echo yes),yes)
--ifeq ($(CONFIG_MAC80211),)
--$(error "ERROR: Your >=2.6.27 and <= 2.6.31 kernel has CONFIG_MAC80211 disabled, you should have it CONFIG_MAC80211=m if you want to use this thing.")
--endif
--endif
--
- ifneq ($(KERNELRELEASE),) # This prevents a warning
- 
- # We will warn when you don't have MQ support or NET_SCHED enabled.
diff '--exclude=.svn' -Nur package/mac80211/patches/010-no_pcmcia.patch ../openwrt-trunk/package/mac80211/patches/010-no_pcmcia.patch
--- package/mac80211/patches/010-no_pcmcia.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/010-no_pcmcia.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,20 +1,20 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -8,7 +8,7 @@ ifeq ($(wildcard $(KLIB_BUILD)/.config),
+@@ -2,7 +2,7 @@ ifeq ($(wildcard $(KLIB_BUILD)/.config),
  # These will be ignored by compat autoconf
-  CONFIG_PCI=y
-  CONFIG_USB=y
-- CONFIG_PCMCIA=y
-+# CONFIG_PCMCIA=y
+  export CONFIG_PCI=y
+  export CONFIG_USB=y
+- export CONFIG_PCMCIA=y
++# export CONFIG_PCMCIA=y
+ # export CONFIG_SSB=m
  else
  include $(KLIB_BUILD)/.config
- endif
-@@ -286,7 +286,7 @@ CONFIG_B43=m
- CONFIG_B43_HWRNG=y
- CONFIG_B43_PCI_AUTOSELECT=y
+@@ -303,7 +303,7 @@ export CONFIG_B43=m
+ export CONFIG_B43_HWRNG=y
+ export CONFIG_B43_PCI_AUTOSELECT=y
  ifdef CONFIG_PCMCIA
--CONFIG_B43_PCMCIA=y
-+# CONFIG_B43_PCMCIA=y
+-export CONFIG_B43_PCMCIA=y
++# export CONFIG_B43_PCMCIA=y
  endif #CONFIG_PCMCIA
  ifdef CONFIG_MAC80211_LEDS
- CONFIG_B43_LEDS=y
+ export CONFIG_B43_LEDS=y
diff '--exclude=.svn' -Nur package/mac80211/patches/011-no_sdio.patch ../openwrt-trunk/package/mac80211/patches/011-no_sdio.patch
--- package/mac80211/patches/011-no_sdio.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/011-no_sdio.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,11 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -557,7 +557,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
- 
+@@ -584,7 +584,7 @@ endif #CONFIG_SPI_MASTER end of SPI driv
  ifdef CONFIG_MMC
  
--CONFIG_B43_SDIO=y
-+# CONFIG_B43_SDIO=y
+ # export CONFIG_SSB_SDIOHOST=y
+-export CONFIG_B43_SDIO=y
++# export CONFIG_B43_SDIO=y
  
  ifdef CONFIG_CRC7
  ifdef CONFIG_WL12XX_PLATFORM_DATA
diff '--exclude=.svn' -Nur package/mac80211/patches/013-disable_b43_nphy.patch ../openwrt-trunk/package/mac80211/patches/013-disable_b43_nphy.patch
--- package/mac80211/patches/013-disable_b43_nphy.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/013-disable_b43_nphy.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,13 +1,13 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -292,8 +292,8 @@ ifdef CONFIG_MAC80211_LEDS
- CONFIG_B43_LEDS=y
+@@ -309,8 +309,8 @@ ifdef CONFIG_MAC80211_LEDS
+ export CONFIG_B43_LEDS=y
  endif #CONFIG_MAC80211_LEDS
- CONFIG_B43_PHY_LP=y
--CONFIG_B43_PHY_N=y
--CONFIG_B43_PHY_HT=y
-+# CONFIG_B43_PHY_N=y
-+# CONFIG_B43_PHY_HT=y
- # CONFIG_B43_PHY_LCN=y
- # CONFIG_B43_FORCE_PIO=y
- # CONFIG_B43_DEBUG=y
+ export CONFIG_B43_PHY_LP=y
+-export CONFIG_B43_PHY_N=y
+-export CONFIG_B43_PHY_HT=y
++# export CONFIG_B43_PHY_N=y
++# export CONFIG_B43_PHY_HT=y
+ # export CONFIG_B43_PHY_LCN=y
+ # export CONFIG_B43_DEBUG=y
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/015-remove-rt2x00-options.patch ../openwrt-trunk/package/mac80211/patches/015-remove-rt2x00-options.patch
--- package/mac80211/patches/015-remove-rt2x00-options.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/015-remove-rt2x00-options.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,20 +1,20 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -368,7 +368,7 @@ CONFIG_RTL8180=m
+@@ -384,7 +384,7 @@ export CONFIG_RTL8180=m
  
- CONFIG_ADM8211=m
+ export CONFIG_ADM8211=m
  
--CONFIG_RT2X00_LIB_PCI=m
-+# CONFIG_RT2X00_LIB_PCI=m
- CONFIG_RT2400PCI=m
- CONFIG_RT2500PCI=m
+-export CONFIG_RT2X00_LIB_PCI=m
++# export CONFIG_RT2X00_LIB_PCI=m
+ export CONFIG_RT2400PCI=m
+ export CONFIG_RT2500PCI=m
  ifdef CONFIG_CRC_CCITT
-@@ -506,7 +506,7 @@ CONFIG_RT2800USB_RT35XX=y
- # CONFIG_RT2800USB_RT53XX=y
- CONFIG_RT2800USB_UNKNOWN=y
+@@ -530,7 +530,7 @@ export CONFIG_RT2800USB_RT35XX=y
+ export CONFIG_RT2800USB_RT53XX=y
+ export CONFIG_RT2800USB_UNKNOWN=y
  endif #CONFIG_CRC_CCITT
--CONFIG_RT2X00_LIB_USB=m
-+# CONFIG_RT2X00_LIB_USB=m
+-export CONFIG_RT2X00_LIB_USB=m
++# export CONFIG_RT2X00_LIB_USB=m
  NEED_RT2X00=y
  # RT73USB requires firmware
  ifdef CONFIG_CRC_ITU_T
diff '--exclude=.svn' -Nur package/mac80211/patches/016-remove_pid_algo.patch ../openwrt-trunk/package/mac80211/patches/016-remove_pid_algo.patch
--- package/mac80211/patches/016-remove_pid_algo.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/016-remove_pid_algo.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,11 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -163,7 +163,7 @@ CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+@@ -168,7 +168,7 @@ export CONFIG_MAC80211_RC_DEFAULT_MINSTR
  # This is the one used by our compat-wireless net/mac80211/rate.c
  # in case you have and old kernel which is overriding this to pid.
- CONFIG_COMPAT_MAC80211_RC_DEFAULT=minstrel_ht
--CONFIG_MAC80211_RC_PID=y
-+# CONFIG_MAC80211_RC_PID=y
- CONFIG_MAC80211_RC_MINSTREL=y
- CONFIG_MAC80211_RC_MINSTREL_HT=y
+ export CONFIG_COMPAT_MAC80211_RC_DEFAULT=minstrel_ht
+-export CONFIG_MAC80211_RC_PID=y
++# export CONFIG_MAC80211_RC_PID=y
+ export CONFIG_MAC80211_RC_MINSTREL=y
+ export CONFIG_MAC80211_RC_MINSTREL_HT=y
  ifdef CONFIG_LEDS_TRIGGERS
diff '--exclude=.svn' -Nur package/mac80211/patches/017-remove_ath9k_rc.patch ../openwrt-trunk/package/mac80211/patches/017-remove_ath9k_rc.patch
--- package/mac80211/patches/017-remove_ath9k_rc.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/017-remove_ath9k_rc.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,11 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -259,7 +259,7 @@ CONFIG_ATH9K_COMMON=m
+@@ -264,7 +264,7 @@ export CONFIG_ATH9K_COMMON=m
  # as default once we get minstrel properly tested and blessed by
  # our systems engineering team. CCK rates also need to be used
  # for long range considerations.
--CONFIG_ATH9K_RATE_CONTROL=y
-+# CONFIG_ATH9K_RATE_CONTROL=y
+-export CONFIG_COMPAT_ATH9K_RATE_CONTROL=y
++# export CONFIG_COMPAT_ATH9K_RATE_CONTROL=y
+ 
+ export CONFIG_ATH9K_BTCOEX_SUPPORT=y
  
- # PCI Drivers
- ifdef CONFIG_PCI
diff '--exclude=.svn' -Nur package/mac80211/patches/018-revert_printk_va_format.patch ../openwrt-trunk/package/mac80211/patches/018-revert_printk_va_format.patch
--- package/mac80211/patches/018-revert_printk_va_format.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/018-revert_printk_va_format.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/b43/main.c
 +++ b/drivers/net/wireless/b43/main.c
-@@ -339,83 +339,59 @@ static int b43_ratelimit(struct b43_wl *
+@@ -341,83 +341,59 @@ static int b43_ratelimit(struct b43_wl *
  
  void b43info(struct b43_wl *wl, const char *fmt, ...)
  {
diff '--exclude=.svn' -Nur package/mac80211/patches/019-remove_ath5k_pci_option.patch ../openwrt-trunk/package/mac80211/patches/019-remove_ath5k_pci_option.patch
--- package/mac80211/patches/019-remove_ath5k_pci_option.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/019-remove_ath5k_pci_option.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,11 +1,11 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -264,7 +264,7 @@ CONFIG_ATH9K_COMMON=m
+@@ -281,7 +281,7 @@ endif #CONFIG_COMPAT_KERNEL_2_6_27
  # PCI Drivers
  ifdef CONFIG_PCI
  
--CONFIG_ATH5K_PCI=y
-+# CONFIG_ATH5K_PCI=y
- CONFIG_ATH9K_PCI=y
+-export CONFIG_ATH5K_PCI=y
++# export CONFIG_ATH5K_PCI=y
+ export CONFIG_ATH9K_PCI=y
  
- CONFIG_IWLWIFI=m
+ export CONFIG_IWLWIFI=m
diff '--exclude=.svn' -Nur package/mac80211/patches/021-add_include_for_bcma.patch ../openwrt-trunk/package/mac80211/patches/021-add_include_for_bcma.patch
--- package/mac80211/patches/021-add_include_for_bcma.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/021-add_include_for_bcma.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,8 +1,8 @@
 --- a/include/linux/compat-3.0.h
 +++ b/include/linux/compat-3.0.h
-@@ -7,6 +7,8 @@
+@@ -36,6 +36,8 @@ static inline struct page *shmem_read_ma
+ #endif
  
- #include <linux/rcupdate.h>
  
 +#include <linux/mod_devicetable.h>
 +
diff '--exclude=.svn' -Nur package/mac80211/patches/022-remove_crc8_and_cordic.patch ../openwrt-trunk/package/mac80211/patches/022-remove_crc8_and_cordic.patch
--- package/mac80211/patches/022-remove_crc8_and_cordic.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/022-remove_crc8_and_cordic.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,166 @@
+--- a/compat/Makefile
++++ b/compat/Makefile
+@@ -44,8 +44,6 @@ compat-$(CONFIG_COMPAT_KERNEL_3_3) += \
+ 	flow_dissector.o
+ compat-$(CONFIG_COMPAT_KERNEL_3_4) += compat-3.4.o
+ 
+-compat-$(CONFIG_COMPAT_CORDIC) += cordic.o
+-compat-$(CONFIG_COMPAT_CRC8) += crc8.o
+ 
+ ifndef CONFIG_64BIT
+ ifndef CONFIG_GENERIC_ATOMIC64
+--- a/include/linux/cordic.h
++++ /dev/null
+@@ -1,48 +0,0 @@
+-/*
+- * Copyright (c) 2011 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+- */
+-#ifndef __CORDIC_H_
+-#define __CORDIC_H_
+-
+-#include <linux/types.h>
+-
+-/**
+- * struct cordic_iq - i/q coordinate.
+- *
+- * @i: real part of coordinate (in phase).
+- * @q: imaginary part of coordinate (quadrature).
+- */
+-struct cordic_iq {
+-	s32 i;
+-	s32 q;
+-};
+-
+-/**
+- * cordic_calc_iq() - calculates the i/q coordinate for given angle.
+- *
+- * @theta: angle in degrees for which i/q coordinate is to be calculated.
+- * @coord: function output parameter holding the i/q coordinate.
+- *
+- * The function calculates the i/q coordinate for a given angle using
+- * cordic algorithm. The coordinate consists of a real (i) and an
+- * imaginary (q) part. The real part is essentially the cosine of the
+- * angle and the imaginary part is the sine of the angle. The returned
+- * values are scaled by 2^16 for precision. The range for theta is
+- * for -180 degrees to +180 degrees. Passed values outside this range are
+- * converted before doing the actual calculation.
+- */
+-struct cordic_iq cordic_calc_iq(s32 theta);
+-
+-#endif /* __CORDIC_H_ */
+--- a/include/linux/crc8.h
++++ /dev/null
+@@ -1,101 +0,0 @@
+-/*
+- * Copyright (c) 2011 Broadcom Corporation
+- *
+- * Permission to use, copy, modify, and/or distribute this software for any
+- * purpose with or without fee is hereby granted, provided that the above
+- * copyright notice and this permission notice appear in all copies.
+- *
+- * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+- * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+- * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+- * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+- * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
+- * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
+- * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+- */
+-#ifndef __CRC8_H_
+-#define __CRC8_H_
+-
+-#include <linux/types.h>
+-
+-/* see usage of this value in crc8() description */
+-#define CRC8_INIT_VALUE		0xFF
+-
+-/*
+- * Return value of crc8() indicating valid message+crc. This is true
+- * if a CRC is inverted before transmission. The CRC computed over the
+- * whole received bitstream is _table[x], where x is the bit pattern
+- * of the modification (almost always 0xff).
+- */
+-#define CRC8_GOOD_VALUE(_table)	(_table[0xFF])
+-
+-/* required table size for crc8 algorithm */
+-#define CRC8_TABLE_SIZE			256
+-
+-/* helper macro assuring right table size is used */
+-#define DECLARE_CRC8_TABLE(_table) \
+-	static u8 _table[CRC8_TABLE_SIZE]
+-
+-/**
+- * crc8_populate_lsb - fill crc table for given polynomial in regular bit order.
+- *
+- * @table:	table to be filled.
+- * @polynomial:	polynomial for which table is to be filled.
+- *
+- * This function fills the provided table according the polynomial provided for
+- * regular bit order (lsb first). Polynomials in CRC algorithms are typically
+- * represented as shown below.
+- *
+- *	poly = x^8 + x^7 + x^6 + x^4 + x^2 + 1
+- *
+- * For lsb first direction x^7 maps to the lsb. So the polynomial is as below.
+- *
+- * - lsb first: poly = 10101011(1) = 0xAB
+- */
+-void crc8_populate_lsb(u8 table[CRC8_TABLE_SIZE], u8 polynomial);
+-
+-/**
+- * crc8_populate_msb - fill crc table for given polynomial in reverse bit order.
+- *
+- * @table:	table to be filled.
+- * @polynomial:	polynomial for which table is to be filled.
+- *
+- * This function fills the provided table according the polynomial provided for
+- * reverse bit order (msb first). Polynomials in CRC algorithms are typically
+- * represented as shown below.
+- *
+- *	poly = x^8 + x^7 + x^6 + x^4 + x^2 + 1
+- *
+- * For msb first direction x^7 maps to the msb. So the polynomial is as below.
+- *
+- * - msb first: poly = (1)11010101 = 0xD5
+- */
+-void crc8_populate_msb(u8 table[CRC8_TABLE_SIZE], u8 polynomial);
+-
+-/**
+- * crc8() - calculate a crc8 over the given input data.
+- *
+- * @table:	crc table used for calculation.
+- * @pdata:	pointer to data buffer.
+- * @nbytes:	number of bytes in data buffer.
+- * @crc:	previous returned crc8 value.
+- *
+- * The CRC8 is calculated using the polynomial given in crc8_populate_msb()
+- * or crc8_populate_lsb().
+- *
+- * The caller provides the initial value (either %CRC8_INIT_VALUE
+- * or the previous returned value) to allow for processing of
+- * discontiguous blocks of data.  When generating the CRC the
+- * caller is responsible for complementing the final return value
+- * and inserting it into the byte stream.  When validating a byte
+- * stream (including CRC8), a final return value of %CRC8_GOOD_VALUE
+- * indicates the byte stream data can be considered valid.
+- *
+- * Reference:
+- * "A Painless Guide to CRC Error Detection Algorithms", ver 3, Aug 1993
+- * Williams, Ross N., ross<at>ross.net
+- * (see URL http://www.ross.net/crc/download/crc_v3.txt).
+- */
+-u8 crc8(const u8 table[CRC8_TABLE_SIZE], u8 *pdata, size_t nbytes, u8 crc);
+-
+-#endif /* __CRC8_H_ */
diff '--exclude=.svn' -Nur package/mac80211/patches/023-ath9k_disable_btcoex.patch ../openwrt-trunk/package/mac80211/patches/023-ath9k_disable_btcoex.patch
--- package/mac80211/patches/023-ath9k_disable_btcoex.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/023-ath9k_disable_btcoex.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,11 @@
+--- a/config.mk
++++ b/config.mk
+@@ -266,7 +266,7 @@ export CONFIG_ATH9K_COMMON=m
+ # for long range considerations.
+ # export CONFIG_COMPAT_ATH9K_RATE_CONTROL=y
+ 
+-export CONFIG_ATH9K_BTCOEX_SUPPORT=y
++# export CONFIG_ATH9K_BTCOEX_SUPPORT=y
+ 
+ # WIL6210 requires MSI only available >= 2.6.30
+ ifndef CONFIG_COMPAT_KERNEL_2_6_30
diff '--exclude=.svn' -Nur package/mac80211/patches/050-compat_firmware.patch ../openwrt-trunk/package/mac80211/patches/050-compat_firmware.patch
--- package/mac80211/patches/050-compat_firmware.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/050-compat_firmware.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,23 +1,20 @@
 --- a/compat/Makefile
 +++ b/compat/Makefile
-@@ -1,10 +1,13 @@
+@@ -1,7 +1,10 @@
  obj-m += compat.o
  #compat-objs :=
  
 -obj-$(CONFIG_COMPAT_FIRMWARE_CLASS) += compat_firmware_class.o
- 
- compat-y += main.o
- 
 +ifdef CONFIG_COMPAT_FIRMWARE_CLASS
 +  compat-y += compat_firmware_class.o
 +endif
 +
- # Compat kernel compatibility code
- compat-$(CONFIG_COMPAT_KERNEL_2_6_14) += compat-2.6.14.o
- compat-$(CONFIG_COMPAT_KERNEL_2_6_18) += compat-2.6.18.o
+ obj-$(CONFIG_COMPAT_NET_SCH_CODEL) += sch_codel.o
+ obj-$(CONFIG_COMPAT_NET_SCH_FQ_CODEL) += sch_fq_codel.o
+ 
 --- a/compat/compat_firmware_class.c
 +++ b/compat/compat_firmware_class.c
-@@ -741,19 +741,16 @@ request_firmware_nowait(
+@@ -741,19 +741,16 @@ compat_request_firmware_nowait(
  	return 0;
  }
  
@@ -36,14 +33,14 @@
 -fs_initcall(firmware_class_init);
 -module_exit(firmware_class_exit);
 -
- EXPORT_SYMBOL(release_firmware);
- EXPORT_SYMBOL(request_firmware);
- EXPORT_SYMBOL(request_firmware_nowait);
+ EXPORT_SYMBOL_GPL(release_firmware);
+ EXPORT_SYMBOL_GPL(request_firmware);
+ EXPORT_SYMBOL_GPL(request_firmware_nowait);
 --- a/compat/main.c
 +++ b/compat/main.c
-@@ -32,6 +32,17 @@ module_param(compat_version, charp, 0400
- MODULE_PARM_DESC(compat_version,
- 		 "Version of the kernel compat backport work");
+@@ -47,6 +47,17 @@ void compat_dependency_symbol(void)
+ EXPORT_SYMBOL_GPL(compat_dependency_symbol);
+ 
  
 +#if defined(CONFIG_FW_LOADER) && (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33))
 +int __init firmware_class_init(void);
@@ -58,10 +55,10 @@
 +
  static int __init compat_init(void)
  {
- 	/* pm-qos for kernels <= 2.6.24, this is a no-op on newer kernels */
-@@ -46,7 +57,8 @@ static int __init compat_init(void)
- 	       COMPAT_BASE_TREE " " COMPAT_BASE_TREE_VERSION
- 	       "\n");
+ 	compat_pm_qos_power_init();
+@@ -63,7 +74,8 @@ static int __init compat_init(void)
+ 	printk(KERN_INFO "compat.git: "
+ 	       COMPAT_BASE_TREE "\n");
  
 -        return 0;
 +	firmware_class_init();
@@ -69,7 +66,7 @@
  }
  module_init(compat_init);
  
-@@ -55,7 +67,8 @@ static void __exit compat_exit(void)
+@@ -72,7 +84,8 @@ static void __exit compat_exit(void)
  	compat_pm_qos_power_deinit();
  	compat_system_workqueue_destroy();
  
diff '--exclude=.svn' -Nur package/mac80211/patches/060-compat_add_module_pci_driver.patch ../openwrt-trunk/package/mac80211/patches/060-compat_add_module_pci_driver.patch
--- package/mac80211/patches/060-compat_add_module_pci_driver.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/060-compat_add_module_pci_driver.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,22 @@
+--- a/include/linux/compat-3.4.h
++++ b/include/linux/compat-3.4.h
+@@ -81,6 +81,19 @@ static inline void eth_hw_addr_random(st
+ 	module_driver(__pci_driver, pci_register_driver, \
+ 		       pci_unregister_driver)
+ 
++/* source include/linux/pci.h */
++/**
++ * module_pci_driver() - Helper macro for registering a PCI driver
++ * @__pci_driver: pci_driver struct
++ *
++ * Helper macro for PCI drivers which do not do anything special in module
++ * init/exit. This eliminates a lot of boilerplate. Each module may only
++ * use this macro once, and calling it replaces module_init() and module_exit()
++ */
++#define module_pci_driver(__pci_driver) \
++	module_driver(__pci_driver, pci_register_driver, \
++		       pci_unregister_driver)
++
+ #endif /* (LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)) */
+ 
+ #endif /* LINUX_5_4_COMPAT_H */
diff '--exclude=.svn' -Nur package/mac80211/patches/060-fix_compat_security.patch ../openwrt-trunk/package/mac80211/patches/060-fix_compat_security.patch
--- package/mac80211/patches/060-fix_compat_security.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/060-fix_compat_security.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- a/include/linux/compat-3.1.h
-+++ b/include/linux/compat-3.1.h
-@@ -5,6 +5,8 @@
- 
- #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
- 
-+#include <linux/security.h>
-+
- #define genl_dump_check_consistent(cb, user_hdr, family)
- 
- #define IFF_TX_SKB_SHARING	0x10000	/* The interface supports sharing
diff '--exclude=.svn' -Nur package/mac80211/patches/070-deactivate_mac80211_tracing.patch ../openwrt-trunk/package/mac80211/patches/070-deactivate_mac80211_tracing.patch
--- package/mac80211/patches/070-deactivate_mac80211_tracing.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/070-deactivate_mac80211_tracing.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
-Do not activate the mac80211 tracing by default as it does not work with 
-kernel <= 2.6.32. Compat also includes include/trace/define_trace.h over
-include/trace/events/module.h which makes this not compiling any more.
-
---- a/net/mac80211/Makefile
-+++ b/net/mac80211/Makefile
-@@ -24,8 +24,7 @@ mac80211-y := \
- 	util.o \
- 	wme.o \
- 	event.o \
--	chan.o \
--	driver-trace.o
-+	chan.o
- 
- mac80211-$(CONFIG_MAC80211_LEDS) += led.o
- mac80211-$(CONFIG_MAC80211_DEBUGFS) += \
-@@ -42,6 +41,7 @@ mac80211-$(CONFIG_MAC80211_MESH) += \
- 
- mac80211-$(CONFIG_PM) += pm.o
- 
-+mac80211-$(CONFIG_MAC80211_DRIVER_API_TRACER) += driver-trace.o
- CFLAGS_driver-trace.o := -I$(src)
- 
- # objects for PID algorithm
---- a/net/mac80211/driver-trace.h
-+++ b/net/mac80211/driver-trace.h
-@@ -5,6 +5,17 @@
- #include <net/mac80211.h>
- #include "ieee80211_i.h"
- 
-+#if !defined(CONFIG_MAC80211_DRIVER_API_TRACER) || defined(__CHECKER__)
-+#undef TRACE_EVENT
-+#define TRACE_EVENT(name, proto, ...) \
-+static inline void trace_ ## name(proto) {}
-+#undef DECLARE_EVENT_CLASS
-+#define DECLARE_EVENT_CLASS(...)
-+#undef DEFINE_EVENT
-+#define DEFINE_EVENT(evt_class, name, proto, ...) \
-+static inline void trace_ ## name(proto) {}
-+#endif
-+
- #undef TRACE_SYSTEM
- #define TRACE_SYSTEM mac80211
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/070-disable_codel.patch ../openwrt-trunk/package/mac80211/patches/070-disable_codel.patch
--- package/mac80211/patches/070-disable_codel.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/070-disable_codel.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,19 @@
+--- a/compat/scripts/gen-compat-config.sh
++++ b/compat/scripts/gen-compat-config.sh
+@@ -62,16 +62,3 @@ fi
+ if [[ ${CONFIG_COMPAT_KERNEL_2_6_36} = "y" ]]; then
+ 	echo "export CONFIG_COMPAT_KFIFO=y"
+ fi
+-
+-if [[ ${CONFIG_COMPAT_KERNEL_3_5} = "y" ]]; then
+-	# We don't have 2.6.24 backport support yet for Codel / FQ CoDel
+-	# For those who want to try this is what is required that I can tell
+-	# so far:
+-	#  * struct Qdisc_ops
+-	#	- init and change callback ops use a different argument dataype
+-	# 	- you need to parse data received from userspace differently
+-	if [[ ${CONFIG_COMPAT_KERNEL_2_6_25} != "y" ]]; then
+-		echo "export CONFIG_COMPAT_NET_SCH_CODEL=m"
+-		echo "export CONFIG_COMPAT_NET_SCH_FQ_CODEL=m"
+-	fi
+-fi
diff '--exclude=.svn' -Nur package/mac80211/patches/071-add_codel_ifdef.patch ../openwrt-trunk/package/mac80211/patches/071-add_codel_ifdef.patch
--- package/mac80211/patches/071-add_codel_ifdef.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/071-add_codel_ifdef.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,19 @@
+--- a/include/linux/compat-3.5.h
++++ b/include/linux/compat-3.5.h
+@@ -8,6 +8,8 @@
+ 
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,5,0))
+ 
++#ifndef TCA_CODEL_MAX
++
+ /*
+  * This backports:
+  *
+@@ -135,6 +137,7 @@ static inline int compat_vga_switcheroo_
+ 
+ #define SIZE_MAX    (~(size_t)0)
+ 
++#endif /* TCA_CODEL_MAX */
+ 
+ #include <linux/pkt_sched.h>
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/100-disable_pcmcia_compat.patch ../openwrt-trunk/package/mac80211/patches/100-disable_pcmcia_compat.patch
--- package/mac80211/patches/100-disable_pcmcia_compat.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/100-disable_pcmcia_compat.patch	2012-08-18 14:47:33.125458002 +0200
@@ -21,7 +21,7 @@
  /**
   * pccard_loop_tuple() - loop over tuples in the CIS
 @@ -73,7 +73,7 @@ next_entry:
- EXPORT_SYMBOL(pccard_loop_tuple);
+ EXPORT_SYMBOL_GPL(pccard_loop_tuple);
  /* Source: drivers/pcmcia/cistpl.c */
  
 -#if defined(CONFIG_PCMCIA) || defined(CONFIG_PCMCIA_MODULE)
@@ -31,7 +31,7 @@
  	struct pcmcia_device *p_dev;
 --- a/include/linux/compat-2.6.28.h
 +++ b/include/linux/compat-2.6.28.h
-@@ -27,7 +27,7 @@
+@@ -48,7 +48,7 @@ typedef u32 phys_addr_t;
  })
  #endif /* From include/asm-generic/bug.h */
  
diff '--exclude=.svn' -Nur package/mac80211/patches/110-disable_usb_compat.patch ../openwrt-trunk/package/mac80211/patches/110-disable_usb_compat.patch
--- package/mac80211/patches/110-disable_usb_compat.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/110-disable_usb_compat.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,6 +1,6 @@
 --- a/compat/compat-2.6.28.c
 +++ b/compat/compat-2.6.28.c
-@@ -165,7 +165,7 @@ EXPORT_SYMBOL(pcmcia_loop_config);
+@@ -165,7 +165,7 @@ EXPORT_SYMBOL_GPL(pcmcia_loop_config);
  
  #endif /* CONFIG_PCMCIA */
  
@@ -12,7 +12,7 @@
 --- a/compat/compat-2.6.29.c
 +++ b/compat/compat-2.6.29.c
 @@ -49,7 +49,7 @@ void netdev_attach_ops(struct net_device
- EXPORT_SYMBOL(netdev_attach_ops);
+ EXPORT_SYMBOL_GPL(netdev_attach_ops);
  
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23))
 -#if defined(CONFIG_USB) || defined(CONFIG_USB_MODULE)
@@ -22,7 +22,7 @@
   * @anchor: anchor the requests are bound to
 --- a/include/linux/compat-2.6.28.h
 +++ b/include/linux/compat-2.6.28.h
-@@ -52,7 +52,7 @@ int pcmcia_loop_config(struct pcmcia_dev
+@@ -73,7 +73,7 @@ int pcmcia_loop_config(struct pcmcia_dev
  /* USB anchors were added as of 2.6.23 */
  #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,23))
  
@@ -33,12 +33,12 @@
  #endif
 --- a/config.mk
 +++ b/config.mk
-@@ -492,7 +492,7 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
+@@ -512,7 +512,7 @@ endif #CONFIG_COMPAT_KERNEL_2_6_29
  # This activates a threading fix for usb urb.
  # this is mainline commit: b3e670443b7fb8a2d29831b62b44a039c283e351
  # This fix will be included in some stable releases.
--CONFIG_COMPAT_USB_URB_THREAD_FIX=y
-+# CONFIG_COMPAT_USB_URB_THREAD_FIX=y
+-export CONFIG_COMPAT_USB_URB_THREAD_FIX=y
++# export CONFIG_COMPAT_USB_URB_THREAD_FIX=y
  
- CONFIG_ATH9K_HTC=m
- # CONFIG_ATH9K_HTC_DEBUGFS=y
+ export CONFIG_ATH9K_HTC=m
+ # export CONFIG_ATH9K_HTC_DEBUGFS=y
diff '--exclude=.svn' -Nur package/mac80211/patches/120-pr_fmt_warnings.patch ../openwrt-trunk/package/mac80211/patches/120-pr_fmt_warnings.patch
--- package/mac80211/patches/120-pr_fmt_warnings.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/120-pr_fmt_warnings.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,177 +1,10 @@
---- a/drivers/net/wireless/iwlegacy/3945-mac.c
-+++ b/drivers/net/wireless/iwlegacy/3945-mac.c
-@@ -27,6 +27,7 @@
-  *
-  *****************************************************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/libertas_tf/cmd.c
-+++ b/drivers/net/wireless/libertas_tf/cmd.c
-@@ -7,6 +7,7 @@
-  *  the Free Software Foundation; either version 2 of the License, or (at
-  *  your option) any later version.
-  */
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/hardirq.h>
---- a/drivers/net/wireless/libertas_tf/if_usb.c
-+++ b/drivers/net/wireless/libertas_tf/if_usb.c
-@@ -9,6 +9,7 @@
-  */
- #define DRV_NAME "lbtf_usb"
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include "libertas_tf.h"
---- a/drivers/net/wireless/libertas_tf/main.c
-+++ b/drivers/net/wireless/libertas_tf/main.c
-@@ -7,6 +7,7 @@
-  *  the Free Software Foundation; either version 2 of the License, or (at
-  *  your option) any later version.
-  */
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/hardirq.h>
---- a/net/wireless/core.c
-+++ b/net/wireless/core.c
-@@ -4,6 +4,7 @@
-  * Copyright 2006-2010		Johannes Berg <johannes@sipsolutions.net>
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/if.h>
---- a/net/wireless/lib80211.c
-+++ b/net/wireless/lib80211.c
-@@ -13,6 +13,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
---- a/net/wireless/lib80211_crypt_tkip.c
-+++ b/net/wireless/lib80211_crypt_tkip.c
-@@ -10,6 +10,7 @@
-  * more details.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/err.h>
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -33,6 +33,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/iwlegacy/4965-mac.c
-+++ b/drivers/net/wireless/iwlegacy/4965-mac.c
-@@ -27,6 +27,7 @@
-  *
-  *****************************************************************************/
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/libertas/cfg.c
-+++ b/drivers/net/wireless/libertas/cfg.c
-@@ -6,6 +6,7 @@
-  *
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/hardirq.h>
---- a/drivers/net/wireless/libertas/if_cs.c
-+++ b/drivers/net/wireless/libertas/if_cs.c
-@@ -21,6 +21,7 @@
- 
- */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
---- a/drivers/net/wireless/libertas/if_sdio.c
-+++ b/drivers/net/wireless/libertas/if_sdio.c
-@@ -26,6 +26,7 @@
-  * if_sdio_card_to_host() to pad the data.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/kernel.h>
---- a/drivers/net/wireless/libertas/if_spi.c
-+++ b/drivers/net/wireless/libertas/if_spi.c
-@@ -17,6 +17,7 @@
-  * (at your option) any later version.
+--- a/drivers/net/wireless/ath/ath5k/debug.c
++++ b/drivers/net/wireless/ath/ath5k/debug.c
+@@ -58,6 +58,7 @@
+  * THE POSSIBILITY OF SUCH DAMAGES.
   */
  
 +#undef pr_fmt
  #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
  
- #include <linux/hardirq.h>
---- a/drivers/net/wireless/libertas/if_usb.c
-+++ b/drivers/net/wireless/libertas/if_usb.c
-@@ -2,6 +2,7 @@
-  * This file contains functions used in USB interface module.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/delay.h>
---- a/drivers/net/wireless/libertas/main.c
-+++ b/drivers/net/wireless/libertas/main.c
-@@ -4,6 +4,7 @@
-  * thread etc..
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
---- a/drivers/net/wireless/libertas/mesh.c
-+++ b/drivers/net/wireless/libertas/mesh.c
-@@ -1,3 +1,4 @@
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/delay.h>
---- a/drivers/net/wireless/libertas/rx.c
-+++ b/drivers/net/wireless/libertas/rx.c
-@@ -2,6 +2,7 @@
-  * This file contains the handling of RX in wlan driver.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
- 
- #include <linux/etherdevice.h>
---- a/compat/crc8.c
-+++ b/compat/crc8.c
-@@ -14,6 +14,7 @@
-  * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#undef pr_fmt
- #define pr_fmt(fmt)		KBUILD_MODNAME ": " fmt
- 
- #include <linux/module.h>
+ #include <linux/export.h>
diff '--exclude=.svn' -Nur package/mac80211/patches/130-fix_sublevel_check.patch ../openwrt-trunk/package/mac80211/patches/130-fix_sublevel_check.patch
--- package/mac80211/patches/130-fix_sublevel_check.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/130-fix_sublevel_check.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,22 +0,0 @@
---- a/config.mk
-+++ b/config.mk
-@@ -20,16 +20,16 @@ COMPAT_LATEST_VERSION = 3
- KERNEL_VERSION := $(shell $(MAKE) -C $(KLIB_BUILD) kernelversion | sed -n 's/^\([0-9]\)\..*/\1/p')
- 
- ifneq ($(KERNEL_VERSION),2)
--KERNEL_SUBLEVEL := $(shell $(MAKE) -C $(KLIB_BUILD) kernelversion | sed -n 's/^3\.\([0-9]\+\).*/\1/p')
-+COMPAT_KERNEL_SUBLEVEL := $(shell $(MAKE) -C $(KLIB_BUILD) kernelversion | sed -n 's/^3\.\([0-9]\+\).*/\1/p')
- else
- COMPAT_26LATEST_VERSION = 39
- KERNEL_26SUBLEVEL := $(shell $(MAKE) -C $(KLIB_BUILD) kernelversion | sed -n 's/^2\.6\.\([0-9]\+\).*/\1/p')
- COMPAT_26VERSIONS := $(shell I=$(COMPAT_26LATEST_VERSION); while [ "$$I" -gt $(KERNEL_26SUBLEVEL) ]; do echo $$I; I=$$(($$I - 1)); done)
- $(foreach ver,$(COMPAT_26VERSIONS),$(eval CONFIG_COMPAT_KERNEL_2_6_$(ver)=y))
--KERNEL_SUBLEVEL := -1
-+COMPAT_KERNEL_SUBLEVEL := -1
- endif
- 
--COMPAT_VERSIONS := $(shell I=$(COMPAT_LATEST_VERSION); while [ "$$I" -gt $(KERNEL_SUBLEVEL) ]; do echo $$I; I=$$(($$I - 1)); done)
-+COMPAT_VERSIONS := $(shell I=$(COMPAT_LATEST_VERSION); while [ "$$I" -gt $(COMPAT_KERNEL_SUBLEVEL) ]; do echo $$I; I=$$(($$I - 1)); done)
- $(foreach ver,$(COMPAT_VERSIONS),$(eval CONFIG_COMPAT_KERNEL_3_$(ver)=y))
- 
- RHEL_MAJOR := $(shell grep ^RHEL_MAJOR $(KLIB_BUILD)/Makefile | sed -n 's/.*= *\(.*\)/\1/p')
diff '--exclude=.svn' -Nur package/mac80211/patches/130-mesh_pathtbl_backport.patch ../openwrt-trunk/package/mac80211/patches/130-mesh_pathtbl_backport.patch
--- package/mac80211/patches/130-mesh_pathtbl_backport.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/130-mesh_pathtbl_backport.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,10 @@
+--- a/net/mac80211/mesh_pathtbl.c
++++ b/net/mac80211/mesh_pathtbl.c
+@@ -817,7 +817,6 @@ static void table_flush_by_iface(struct 
+ 	struct hlist_node *p;
+ 	int i;
+ 
+-	WARN_ON(!rcu_read_lock_held());
+ 	for_each_mesh_entry(tbl, p, node, i) {
+ 		mpath = node->mpath;
+ 		if (mpath->sdata != sdata)
diff '--exclude=.svn' -Nur package/mac80211/patches/140-mesh_pathtbl_backport.patch ../openwrt-trunk/package/mac80211/patches/140-mesh_pathtbl_backport.patch
--- package/mac80211/patches/140-mesh_pathtbl_backport.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/140-mesh_pathtbl_backport.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
---- a/net/mac80211/mesh_pathtbl.c
-+++ b/net/mac80211/mesh_pathtbl.c
-@@ -826,7 +826,6 @@ static void table_flush_by_iface(struct 
- 	struct hlist_node *p;
- 	int i;
- 
--	WARN_ON(!rcu_read_lock_held());
- 	for_each_mesh_entry(tbl, p, node, i) {
- 		mpath = node->mpath;
- 		if (mpath->sdata != sdata)
diff '--exclude=.svn' -Nur package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch ../openwrt-trunk/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch
--- package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/201-ath5k-WAR-for-AR71xx-PCI-bug.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,10 +1,10 @@
 --- a/drivers/net/wireless/ath/ath5k/initvals.c
 +++ b/drivers/net/wireless/ath/ath5k/initvals.c
-@@ -60,8 +60,14 @@ static const struct ath5k_ini ar5210_ini
+@@ -65,8 +65,14 @@ static const struct ath5k_ini ar5210_ini
  	{ AR5K_IMR,		0 },
  	{ AR5K_IER,		AR5K_IER_DISABLE },
  	{ AR5K_BSR,		0, AR5K_INI_READ },
-+#ifndef CONFIG_ATHEROS_AR71XX
++#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
  	{ AR5K_TXCFG,		AR5K_DMASIZE_128B },
  	{ AR5K_RXCFG,		AR5K_DMASIZE_128B },
 +#else
@@ -17,11 +17,11 @@
  	{ AR5K_RXNOFRM,		8 },
 --- a/drivers/net/wireless/ath/ath5k/dma.c
 +++ b/drivers/net/wireless/ath/ath5k/dma.c
-@@ -858,10 +858,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
+@@ -863,10 +863,18 @@ ath5k_hw_dma_init(struct ath5k_hw *ah)
  	 * guess we can tweak it and see how it goes ;-)
  	 */
  	if (ah->ah_version != AR5K_AR5210) {
-+#ifndef CONFIG_ATHEROS_AR71XX
++#if !defined(CONFIG_ATHEROS_AR71XX) && !defined(CONFIG_ATH79)
  		AR5K_REG_WRITE_BITS(ah, AR5K_TXCFG,
  			AR5K_TXCFG_SDMAMR, AR5K_DMASIZE_128B);
  		AR5K_REG_WRITE_BITS(ah, AR5K_RXCFG,
diff '--exclude=.svn' -Nur package/mac80211/patches/300-pending_work.patch ../openwrt-trunk/package/mac80211/patches/300-pending_work.patch
--- package/mac80211/patches/300-pending_work.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/300-pending_work.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,547 +1,3734 @@
---- a/drivers/net/wireless/ath/ath9k/ar9002_calib.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9002_calib.c
-@@ -203,7 +203,7 @@ static void ar9002_hw_iqcalibrate(struct
- 			i);
- 
- 		ath_dbg(common, ATH_DBG_CALIBRATE,
--			"Orignal: Chn %diq_corr_meas = 0x%08x\n",
-+			"Original: Chn %d iq_corr_meas = 0x%08x\n",
- 			i, ah->totalIqCorrMeas[i]);
- 
- 		iqCorrNeg = 0;
---- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c
-@@ -226,7 +226,7 @@ static void ar9003_hw_iqcalibrate(struct
- 			i);
- 
- 		ath_dbg(common, ATH_DBG_CALIBRATE,
--			"Orignal: Chn %diq_corr_meas = 0x%08x\n",
-+			"Original: Chn %d iq_corr_meas = 0x%08x\n",
- 			i, ah->totalIqCorrMeas[i]);
+--- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
++++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
+@@ -210,8 +210,8 @@ ath5k_config(struct ieee80211_hw *hw, u3
+ 	}
+ 
+ 	if ((changed & IEEE80211_CONF_CHANGE_POWER) &&
+-	(ah->power_level != conf->power_level)) {
+-		ah->power_level = conf->power_level;
++	(ah->ah_txpower.txp_requested != conf->power_level)) {
++		ah->ah_txpower.txp_requested = conf->power_level;
+ 
+ 		/* Half dB steps */
+ 		ath5k_hw_set_txpower_limit(ah, (conf->power_level * 2));
+@@ -622,7 +622,7 @@ ath5k_conf_tx(struct ieee80211_hw *hw, s
+ 	qi.tqi_aifs = params->aifs;
+ 	qi.tqi_cw_min = params->cw_min;
+ 	qi.tqi_cw_max = params->cw_max;
+-	qi.tqi_burst_time = params->txop;
++	qi.tqi_burst_time = params->txop * 32;
+ 
+ 	ATH5K_DBG(ah, ATH5K_DEBUG_ANY,
+ 		  "Configure tx [queue %d],  "
+--- a/drivers/net/wireless/ath/ath9k/ar9002_hw.c
++++ b/drivers/net/wireless/ath/ath9k/ar9002_hw.c
+@@ -26,106 +26,74 @@
+ static void ar9002_hw_init_mode_regs(struct ath_hw *ah)
+ {
+ 	if (AR_SREV_9271(ah)) {
+-		INIT_INI_ARRAY(&ah->iniModes, ar9271Modes_9271,
+-			       ARRAY_SIZE(ar9271Modes_9271), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar9271Common_9271,
+-			       ARRAY_SIZE(ar9271Common_9271), 2);
+-		INIT_INI_ARRAY(&ah->iniModes_9271_ANI_reg, ar9271Modes_9271_ANI_reg,
+-			       ARRAY_SIZE(ar9271Modes_9271_ANI_reg), 5);
++		INIT_INI_ARRAY(&ah->iniModes, ar9271Modes_9271);
++		INIT_INI_ARRAY(&ah->iniCommon, ar9271Common_9271);
++		INIT_INI_ARRAY(&ah->iniModes_9271_ANI_reg, ar9271Modes_9271_ANI_reg);
+ 		return;
+ 	}
+ 
+ 	if (ah->config.pcie_clock_req)
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdes,
+-			   ar9280PciePhy_clkreq_off_L1_9280,
+-			   ARRAY_SIZE(ar9280PciePhy_clkreq_off_L1_9280), 2);
++			   ar9280PciePhy_clkreq_off_L1_9280);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdes,
+-			   ar9280PciePhy_clkreq_always_on_L1_9280,
+-			   ARRAY_SIZE(ar9280PciePhy_clkreq_always_on_L1_9280), 2);
++			   ar9280PciePhy_clkreq_always_on_L1_9280);
+ #ifdef CONFIG_PM_SLEEP
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdesWow,
+-			       ar9280PciePhy_awow,
+-			       ARRAY_SIZE(ar9280PciePhy_awow), 2);
++			       ar9280PciePhy_awow);
+ #endif
+ 
+ 	if (AR_SREV_9287_11_OR_LATER(ah)) {
+-		INIT_INI_ARRAY(&ah->iniModes, ar9287Modes_9287_1_1,
+-				ARRAY_SIZE(ar9287Modes_9287_1_1), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar9287Common_9287_1_1,
+-				ARRAY_SIZE(ar9287Common_9287_1_1), 2);
++		INIT_INI_ARRAY(&ah->iniModes, ar9287Modes_9287_1_1);
++		INIT_INI_ARRAY(&ah->iniCommon, ar9287Common_9287_1_1);
+ 	} else if (AR_SREV_9285_12_OR_LATER(ah)) {
+-		INIT_INI_ARRAY(&ah->iniModes, ar9285Modes_9285_1_2,
+-			       ARRAY_SIZE(ar9285Modes_9285_1_2), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar9285Common_9285_1_2,
+-			       ARRAY_SIZE(ar9285Common_9285_1_2), 2);
++		INIT_INI_ARRAY(&ah->iniModes, ar9285Modes_9285_1_2);
++		INIT_INI_ARRAY(&ah->iniCommon, ar9285Common_9285_1_2);
+ 	} else if (AR_SREV_9280_20_OR_LATER(ah)) {
+-		INIT_INI_ARRAY(&ah->iniModes, ar9280Modes_9280_2,
+-			       ARRAY_SIZE(ar9280Modes_9280_2), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar9280Common_9280_2,
+-			       ARRAY_SIZE(ar9280Common_9280_2), 2);
++		INIT_INI_ARRAY(&ah->iniModes, ar9280Modes_9280_2);
++		INIT_INI_ARRAY(&ah->iniCommon, ar9280Common_9280_2);
+ 
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+-			       ar9280Modes_fast_clock_9280_2,
+-			       ARRAY_SIZE(ar9280Modes_fast_clock_9280_2), 3);
++			       ar9280Modes_fast_clock_9280_2);
+ 	} else if (AR_SREV_9160_10_OR_LATER(ah)) {
+-		INIT_INI_ARRAY(&ah->iniModes, ar5416Modes_9160,
+-			       ARRAY_SIZE(ar5416Modes_9160), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar5416Common_9160,
+-			       ARRAY_SIZE(ar5416Common_9160), 2);
++		INIT_INI_ARRAY(&ah->iniModes, ar5416Modes_9160);
++		INIT_INI_ARRAY(&ah->iniCommon, ar5416Common_9160);
+ 		if (AR_SREV_9160_11(ah)) {
+ 			INIT_INI_ARRAY(&ah->iniAddac,
+-				       ar5416Addac_9160_1_1,
+-				       ARRAY_SIZE(ar5416Addac_9160_1_1), 2);
++				       ar5416Addac_9160_1_1);
+ 		} else {
+-			INIT_INI_ARRAY(&ah->iniAddac, ar5416Addac_9160,
+-				       ARRAY_SIZE(ar5416Addac_9160), 2);
++			INIT_INI_ARRAY(&ah->iniAddac, ar5416Addac_9160);
+ 		}
+ 	} else if (AR_SREV_9100_OR_LATER(ah)) {
+-		INIT_INI_ARRAY(&ah->iniModes, ar5416Modes_9100,
+-			       ARRAY_SIZE(ar5416Modes_9100), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar5416Common_9100,
+-			       ARRAY_SIZE(ar5416Common_9100), 2);
+-		INIT_INI_ARRAY(&ah->iniBank6, ar5416Bank6_9100,
+-			       ARRAY_SIZE(ar5416Bank6_9100), 3);
+-		INIT_INI_ARRAY(&ah->iniAddac, ar5416Addac_9100,
+-			       ARRAY_SIZE(ar5416Addac_9100), 2);
++		INIT_INI_ARRAY(&ah->iniModes, ar5416Modes_9100);
++		INIT_INI_ARRAY(&ah->iniCommon, ar5416Common_9100);
++		INIT_INI_ARRAY(&ah->iniBank6, ar5416Bank6_9100);
++		INIT_INI_ARRAY(&ah->iniAddac, ar5416Addac_9100);
+ 	} else {
+-		INIT_INI_ARRAY(&ah->iniModes, ar5416Modes,
+-			       ARRAY_SIZE(ar5416Modes), 5);
+-		INIT_INI_ARRAY(&ah->iniCommon, ar5416Common,
+-			       ARRAY_SIZE(ar5416Common), 2);
+-		INIT_INI_ARRAY(&ah->iniBank6TPC, ar5416Bank6TPC,
+-			       ARRAY_SIZE(ar5416Bank6TPC), 3);
+-		INIT_INI_ARRAY(&ah->iniAddac, ar5416Addac,
+-			       ARRAY_SIZE(ar5416Addac), 2);
++		INIT_INI_ARRAY(&ah->iniModes, ar5416Modes);
++		INIT_INI_ARRAY(&ah->iniCommon, ar5416Common);
++		INIT_INI_ARRAY(&ah->iniBank6TPC, ar5416Bank6TPC);
++		INIT_INI_ARRAY(&ah->iniAddac, ar5416Addac);
+ 	}
+ 
+ 	if (!AR_SREV_9280_20_OR_LATER(ah)) {
+ 		/* Common for AR5416, AR913x, AR9160 */
+-		INIT_INI_ARRAY(&ah->iniBB_RfGain, ar5416BB_RfGain,
+-			       ARRAY_SIZE(ar5416BB_RfGain), 3);
++		INIT_INI_ARRAY(&ah->iniBB_RfGain, ar5416BB_RfGain);
+ 
+-		INIT_INI_ARRAY(&ah->iniBank0, ar5416Bank0,
+-			       ARRAY_SIZE(ar5416Bank0), 2);
+-		INIT_INI_ARRAY(&ah->iniBank1, ar5416Bank1,
+-			       ARRAY_SIZE(ar5416Bank1), 2);
+-		INIT_INI_ARRAY(&ah->iniBank2, ar5416Bank2,
+-			       ARRAY_SIZE(ar5416Bank2), 2);
+-		INIT_INI_ARRAY(&ah->iniBank3, ar5416Bank3,
+-			       ARRAY_SIZE(ar5416Bank3), 3);
+-		INIT_INI_ARRAY(&ah->iniBank7, ar5416Bank7,
+-			       ARRAY_SIZE(ar5416Bank7), 2);
++		INIT_INI_ARRAY(&ah->iniBank0, ar5416Bank0);
++		INIT_INI_ARRAY(&ah->iniBank1, ar5416Bank1);
++		INIT_INI_ARRAY(&ah->iniBank2, ar5416Bank2);
++		INIT_INI_ARRAY(&ah->iniBank3, ar5416Bank3);
++		INIT_INI_ARRAY(&ah->iniBank7, ar5416Bank7);
+ 
+ 		/* Common for AR5416, AR9160 */
+ 		if (!AR_SREV_9100(ah))
+-			INIT_INI_ARRAY(&ah->iniBank6, ar5416Bank6,
+-				       ARRAY_SIZE(ar5416Bank6), 3);
++			INIT_INI_ARRAY(&ah->iniBank6, ar5416Bank6);
+ 
+ 		/* Common for AR913x, AR9160 */
+ 		if (!AR_SREV_5416(ah))
+-			INIT_INI_ARRAY(&ah->iniBank6TPC, ar5416Bank6TPC_9100,
+-				       ARRAY_SIZE(ar5416Bank6TPC_9100), 3);
++			INIT_INI_ARRAY(&ah->iniBank6TPC,
++				      ar5416Bank6TPC_9100);
+ 	}
+ 
+ 	/* iniAddac needs to be modified for these chips */
+@@ -148,13 +116,9 @@ static void ar9002_hw_init_mode_regs(str
+ 	}
+ 	if (AR_SREV_9287_11_OR_LATER(ah)) {
+ 		INIT_INI_ARRAY(&ah->iniCckfirNormal,
+-		       ar9287Common_normal_cck_fir_coeff_9287_1_1,
+-		       ARRAY_SIZE(ar9287Common_normal_cck_fir_coeff_9287_1_1),
+-		       2);
++		       ar9287Common_normal_cck_fir_coeff_9287_1_1);
+ 		INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+-		       ar9287Common_japan_2484_cck_fir_coeff_9287_1_1,
+-		       ARRAY_SIZE(ar9287Common_japan_2484_cck_fir_coeff_9287_1_1),
+-		       2);
++		       ar9287Common_japan_2484_cck_fir_coeff_9287_1_1);
+ 	}
+ }
+ 
+@@ -168,20 +132,16 @@ static void ar9280_20_hw_init_rxgain_ini
+ 
+ 		if (rxgain_type == AR5416_EEP_RXGAIN_13DB_BACKOFF)
+ 			INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9280Modes_backoff_13db_rxgain_9280_2,
+-			ARRAY_SIZE(ar9280Modes_backoff_13db_rxgain_9280_2), 5);
++				       ar9280Modes_backoff_13db_rxgain_9280_2);
+ 		else if (rxgain_type == AR5416_EEP_RXGAIN_23DB_BACKOFF)
+ 			INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9280Modes_backoff_23db_rxgain_9280_2,
+-			ARRAY_SIZE(ar9280Modes_backoff_23db_rxgain_9280_2), 5);
++				       ar9280Modes_backoff_23db_rxgain_9280_2);
+ 		else
+ 			INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9280Modes_original_rxgain_9280_2,
+-			ARRAY_SIZE(ar9280Modes_original_rxgain_9280_2), 5);
++				       ar9280Modes_original_rxgain_9280_2);
+ 	} else {
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9280Modes_original_rxgain_9280_2,
+-			ARRAY_SIZE(ar9280Modes_original_rxgain_9280_2), 5);
++			       ar9280Modes_original_rxgain_9280_2);
+ 	}
+ }
+ 
+@@ -191,16 +151,13 @@ static void ar9280_20_hw_init_txgain_ini
+ 	    AR5416_EEP_MINOR_VER_19) {
+ 		if (txgain_type == AR5416_EEP_TXGAIN_HIGH_POWER)
+ 			INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9280Modes_high_power_tx_gain_9280_2,
+-			ARRAY_SIZE(ar9280Modes_high_power_tx_gain_9280_2), 5);
++				       ar9280Modes_high_power_tx_gain_9280_2);
+ 		else
+ 			INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9280Modes_original_tx_gain_9280_2,
+-			ARRAY_SIZE(ar9280Modes_original_tx_gain_9280_2), 5);
++				       ar9280Modes_original_tx_gain_9280_2);
+ 	} else {
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-		ar9280Modes_original_tx_gain_9280_2,
+-		ARRAY_SIZE(ar9280Modes_original_tx_gain_9280_2), 5);
++			       ar9280Modes_original_tx_gain_9280_2);
+ 	}
+ }
+ 
+@@ -208,12 +165,10 @@ static void ar9271_hw_init_txgain_ini(st
+ {
+ 	if (txgain_type == AR5416_EEP_TXGAIN_HIGH_POWER)
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			       ar9271Modes_high_power_tx_gain_9271,
+-			       ARRAY_SIZE(ar9271Modes_high_power_tx_gain_9271), 5);
++			       ar9271Modes_high_power_tx_gain_9271);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			       ar9271Modes_normal_power_tx_gain_9271,
+-			       ARRAY_SIZE(ar9271Modes_normal_power_tx_gain_9271), 5);
++			       ar9271Modes_normal_power_tx_gain_9271);
+ }
+ 
+ static void ar9002_hw_init_mode_gain_regs(struct ath_hw *ah)
+@@ -222,8 +177,7 @@ static void ar9002_hw_init_mode_gain_reg
+ 
+ 	if (AR_SREV_9287_11_OR_LATER(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-		ar9287Modes_rx_gain_9287_1_1,
+-		ARRAY_SIZE(ar9287Modes_rx_gain_9287_1_1), 5);
++			       ar9287Modes_rx_gain_9287_1_1);
+ 	else if (AR_SREV_9280_20(ah))
+ 		ar9280_20_hw_init_rxgain_ini(ah);
+ 
+@@ -231,8 +185,7 @@ static void ar9002_hw_init_mode_gain_reg
+ 		ar9271_hw_init_txgain_ini(ah, txgain_type);
+ 	} else if (AR_SREV_9287_11_OR_LATER(ah)) {
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-		ar9287Modes_tx_gain_9287_1_1,
+-		ARRAY_SIZE(ar9287Modes_tx_gain_9287_1_1), 5);
++			       ar9287Modes_tx_gain_9287_1_1);
+ 	} else if (AR_SREV_9280_20(ah)) {
+ 		ar9280_20_hw_init_txgain_ini(ah, txgain_type);
+ 	} else if (AR_SREV_9285_12_OR_LATER(ah)) {
+@@ -240,26 +193,18 @@ static void ar9002_hw_init_mode_gain_reg
+ 		if (txgain_type == AR5416_EEP_TXGAIN_HIGH_POWER) {
+ 			if (AR_SREV_9285E_20(ah)) {
+ 				INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9285Modes_XE2_0_high_power,
+-				ARRAY_SIZE(
+-				  ar9285Modes_XE2_0_high_power), 5);
++					       ar9285Modes_XE2_0_high_power);
+ 			} else {
+ 				INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9285Modes_high_power_tx_gain_9285_1_2,
+-				ARRAY_SIZE(
+-				  ar9285Modes_high_power_tx_gain_9285_1_2), 5);
++					ar9285Modes_high_power_tx_gain_9285_1_2);
+ 			}
+ 		} else {
+ 			if (AR_SREV_9285E_20(ah)) {
+ 				INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9285Modes_XE2_0_normal_power,
+-				ARRAY_SIZE(
+-				  ar9285Modes_XE2_0_normal_power), 5);
++					       ar9285Modes_XE2_0_normal_power);
+ 			} else {
+ 				INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9285Modes_original_tx_gain_9285_1_2,
+-				ARRAY_SIZE(
+-				  ar9285Modes_original_tx_gain_9285_1_2), 5);
++					ar9285Modes_original_tx_gain_9285_1_2);
+ 			}
+ 		}
+ 	}
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
+@@ -131,8 +131,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0cf0e0e0),
+ 		.papdRateMaskHt40 = LE32(0x6cf0e0e0),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	 },
+ 	.base_ext1 = {
+@@ -331,8 +332,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0c80c080),
+ 		.papdRateMaskHt40 = LE32(0x0080c080),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	 },
+ 	.base_ext2 = {
+@@ -704,8 +706,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0c80c080),
+ 		.papdRateMaskHt40 = LE32(0x0080c080),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	 },
+ 	 .base_ext1 = {
+@@ -904,8 +907,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0cf0e0e0),
+ 		.papdRateMaskHt40 = LE32(0x6cf0e0e0),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	 },
+ 	.base_ext2 = {
+@@ -1278,8 +1282,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0c80c080),
+ 		.papdRateMaskHt40 = LE32(0x0080c080),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	},
+ 	.base_ext1 = {
+@@ -1478,8 +1483,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0cf0e0e0),
+ 		.papdRateMaskHt40 = LE32(0x6cf0e0e0),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	},
+ 	.base_ext2 = {
+@@ -1852,8 +1858,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0c80c080),
+ 		.papdRateMaskHt40 = LE32(0x0080c080),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	},
+ 	.base_ext1 = {
+@@ -2052,8 +2059,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0cf0e0e0),
+ 		.papdRateMaskHt40 = LE32(0x6cf0e0e0),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	},
+ 	.base_ext2 = {
+@@ -2425,8 +2433,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0c80C080),
+ 		.papdRateMaskHt40 = LE32(0x0080C080),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	 },
+ 	 .base_ext1 = {
+@@ -2625,8 +2634,9 @@ static const struct ar9300_eeprom ar9300
+ 		.thresh62 = 28,
+ 		.papdRateMaskHt20 = LE32(0x0cf0e0e0),
+ 		.papdRateMaskHt40 = LE32(0x6cf0e0e0),
++		.xlna_bias_strength = 0,
+ 		.futureModal = {
+-			0, 0, 0, 0, 0, 0, 0, 0,
++			0, 0, 0, 0, 0, 0, 0,
+ 		},
+ 	 },
+ 	.base_ext2 = {
+@@ -2971,14 +2981,6 @@ static u32 ath9k_hw_ar9300_get_eeprom(st
+ 		return (pBase->txrxMask >> 4) & 0xf;
+ 	case EEP_RX_MASK:
+ 		return pBase->txrxMask & 0xf;
+-	case EEP_DRIVE_STRENGTH:
+-#define AR9300_EEP_BASE_DRIV_STRENGTH	0x1
+-		return pBase->miscConfiguration & AR9300_EEP_BASE_DRIV_STRENGTH;
+-	case EEP_INTERNAL_REGULATOR:
+-		/* Bit 4 is internal regulator flag */
+-		return (pBase->featureEnable & 0x10) >> 4;
+-	case EEP_SWREG:
+-		return le32_to_cpu(pBase->swreg);
+ 	case EEP_PAPRD:
+ 		return !!(pBase->featureEnable & BIT(5));
+ 	case EEP_CHAIN_MASK_REDUCE:
+@@ -2989,8 +2991,6 @@ static u32 ath9k_hw_ar9300_get_eeprom(st
+ 		return eep->modalHeader5G.antennaGain;
+ 	case EEP_ANTENNA_GAIN_2G:
+ 		return eep->modalHeader2G.antennaGain;
+-	case EEP_QUICK_DROP:
+-		return pBase->miscConfiguration & BIT(1);
+ 	default:
+ 		return 0;
+ 	}
+@@ -3260,10 +3260,20 @@ static int ar9300_eeprom_restore_interna
+ 	int it;
+ 	u16 checksum, mchecksum;
+ 	struct ath_common *common = ath9k_hw_common(ah);
++	struct ar9300_eeprom *eep;
+ 	eeprom_read_op read;
+ 
+-	if (ath9k_hw_use_flash(ah))
+-		return ar9300_eeprom_restore_flash(ah, mptr, mdata_size);
++	if (ath9k_hw_use_flash(ah)) {
++		u8 txrx;
++
++		ar9300_eeprom_restore_flash(ah, mptr, mdata_size);
++
++		/* check if eeprom contains valid data */
++		eep = (struct ar9300_eeprom *) mptr;
++		txrx = eep->baseEepHeader.txrxMask;
++		if (txrx != 0 && txrx != 0xff)
++			return 0;
++	}
+ 
+ 	word = kzalloc(2048, GFP_KERNEL);
+ 	if (!word)
+@@ -3493,19 +3503,20 @@ static int ath9k_hw_ar9300_get_eeprom_re
+ 	return 0;
+ }
+ 
+-static s32 ar9003_hw_xpa_bias_level_get(struct ath_hw *ah, bool is2ghz)
++static struct ar9300_modal_eep_header *ar9003_modal_header(struct ath_hw *ah,
++							   bool is2ghz)
+ {
+ 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ 
+ 	if (is2ghz)
+-		return eep->modalHeader2G.xpaBiasLvl;
++		return &eep->modalHeader2G;
+ 	else
+-		return eep->modalHeader5G.xpaBiasLvl;
++		return &eep->modalHeader5G;
+ }
+ 
+ static void ar9003_hw_xpa_bias_level_apply(struct ath_hw *ah, bool is2ghz)
+ {
+-	int bias = ar9003_hw_xpa_bias_level_get(ah, is2ghz);
++	int bias = ar9003_modal_header(ah, is2ghz)->xpaBiasLvl;
+ 
+ 	if (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah))
+ 		REG_RMW_FIELD(ah, AR_CH0_TOP2, AR_CH0_TOP2_XPABIASLVL, bias);
+@@ -3521,57 +3532,26 @@ static void ar9003_hw_xpa_bias_level_app
+ 	}
+ }
+ 
+-static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is_2ghz)
++static u16 ar9003_switch_com_spdt_get(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	__le16 val;
+-
+-	if (is_2ghz)
+-		val = eep->modalHeader2G.switchcomspdt;
+-	else
+-		val = eep->modalHeader5G.switchcomspdt;
+-	return le16_to_cpu(val);
++	return le16_to_cpu(ar9003_modal_header(ah, is2ghz)->switchcomspdt);
+ }
+ 
+ 
+ static u32 ar9003_hw_ant_ctrl_common_get(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	__le32 val;
+-
+-	if (is2ghz)
+-		val = eep->modalHeader2G.antCtrlCommon;
+-	else
+-		val = eep->modalHeader5G.antCtrlCommon;
+-	return le32_to_cpu(val);
++	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon);
+ }
+ 
+ static u32 ar9003_hw_ant_ctrl_common_2_get(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	__le32 val;
+-
+-	if (is2ghz)
+-		val = eep->modalHeader2G.antCtrlCommon2;
+-	else
+-		val = eep->modalHeader5G.antCtrlCommon2;
+-	return le32_to_cpu(val);
++	return le32_to_cpu(ar9003_modal_header(ah, is2ghz)->antCtrlCommon2);
+ }
+ 
+-static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah,
+-					int chain,
++static u16 ar9003_hw_ant_ctrl_chain_get(struct ath_hw *ah, int chain,
+ 					bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	__le16 val = 0;
+-
+-	if (chain >= 0 && chain < AR9300_MAX_CHAINS) {
+-		if (is2ghz)
+-			val = eep->modalHeader2G.antCtrlChain[chain];
+-		else
+-			val = eep->modalHeader5G.antCtrlChain[chain];
+-	}
+-
++	__le16 val = ar9003_modal_header(ah, is2ghz)->antCtrlChain[chain];
+ 	return le16_to_cpu(val);
+ }
+ 
+@@ -3681,11 +3661,12 @@ static void ar9003_hw_ant_ctrl_apply(str
+ 
+ static void ar9003_hw_drive_strength_apply(struct ath_hw *ah)
+ {
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
+ 	int drive_strength;
+ 	unsigned long reg;
+ 
+-	drive_strength = ath9k_hw_ar9300_get_eeprom(ah, EEP_DRIVE_STRENGTH);
+-
++	drive_strength = pBase->miscConfiguration & BIT(0);
+ 	if (!drive_strength)
+ 		return;
+ 
+@@ -3815,11 +3796,11 @@ static bool is_pmu_set(struct ath_hw *ah
+ 
+ void ar9003_hw_internal_regulator_apply(struct ath_hw *ah)
+ {
+-	int internal_regulator =
+-		ath9k_hw_ar9300_get_eeprom(ah, EEP_INTERNAL_REGULATOR);
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
+ 	u32 reg_val;
+ 
+-	if (internal_regulator) {
++	if (pBase->featureEnable & BIT(4)) {
+ 		if (AR_SREV_9330(ah) || AR_SREV_9485(ah)) {
+ 			int reg_pmu_set;
+ 
+@@ -3863,11 +3844,11 @@ void ar9003_hw_internal_regulator_apply(
+ 			if (!is_pmu_set(ah, AR_PHY_PMU2, reg_pmu_set))
+ 				return;
+ 		} else if (AR_SREV_9462(ah)) {
+-			reg_val = ath9k_hw_ar9300_get_eeprom(ah, EEP_SWREG);
++			reg_val = le32_to_cpu(pBase->swreg);
+ 			REG_WRITE(ah, AR_PHY_PMU1, reg_val);
+ 		} else {
+ 			/* Internal regulator is ON. Write swreg register. */
+-			reg_val = ath9k_hw_ar9300_get_eeprom(ah, EEP_SWREG);
++			reg_val = le32_to_cpu(pBase->swreg);
+ 			REG_WRITE(ah, AR_RTC_REG_CONTROL1,
+ 				  REG_READ(ah, AR_RTC_REG_CONTROL1) &
+ 				  (~AR_RTC_REG_CONTROL1_SWREG_PROGRAM));
+@@ -3909,6 +3890,9 @@ static void ar9003_hw_apply_tuning_caps(
+ 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ 	u8 tuning_caps_param = eep->baseEepHeader.params_for_tuning_caps[0];
+ 
++	if (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah))
++		return;
++
+ 	if (eep->baseEepHeader.featureEnable & 0x40) {
+ 		tuning_caps_param &= 0x7f;
+ 		REG_RMW_FIELD(ah, AR_CH0_XTAL, AR_CH0_XTAL_CAPINDAC,
+@@ -3921,10 +3905,11 @@ static void ar9003_hw_apply_tuning_caps(
+ static void ar9003_hw_quick_drop_apply(struct ath_hw *ah, u16 freq)
+ {
+ 	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-	int quick_drop = ath9k_hw_ar9300_get_eeprom(ah, EEP_QUICK_DROP);
++	struct ar9300_base_eep_hdr *pBase = &eep->baseEepHeader;
++	int quick_drop;
+ 	s32 t[3], f[3] = {5180, 5500, 5785};
+ 
+-	if (!quick_drop)
++	if (!(pBase->miscConfiguration & BIT(1)))
+ 		return;
+ 
+ 	if (freq < 4000)
+@@ -3938,13 +3923,11 @@ static void ar9003_hw_quick_drop_apply(s
+ 	REG_RMW_FIELD(ah, AR_PHY_AGC, AR_PHY_AGC_QUICK_DROP, quick_drop);
+ }
+ 
+-static void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, u16 freq)
++static void ar9003_hw_txend_to_xpa_off_apply(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+ 	u32 value;
+ 
+-	value = (freq < 4000) ? eep->modalHeader2G.txEndToXpaOff :
+-				eep->modalHeader5G.txEndToXpaOff;
++	value = ar9003_modal_header(ah, is2ghz)->txEndToXpaOff;
+ 
+ 	REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
+ 		      AR_PHY_XPA_TIMING_CTL_TX_END_XPAB_OFF, value);
+@@ -3952,19 +3935,63 @@ static void ar9003_hw_txend_to_xpa_off_a
+ 		      AR_PHY_XPA_TIMING_CTL_TX_END_XPAA_OFF, value);
+ }
+ 
++static void ar9003_hw_xpa_timing_control_apply(struct ath_hw *ah, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	u8 xpa_ctl;
++
++	if (!(eep->baseEepHeader.featureEnable & 0x80))
++		return;
++
++	if (!AR_SREV_9300(ah) && !AR_SREV_9340(ah) && !AR_SREV_9580(ah))
++		return;
++
++	xpa_ctl = ar9003_modal_header(ah, is2ghz)->txFrameToXpaOn;
++	if (is2ghz)
++		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
++			      AR_PHY_XPA_TIMING_CTL_FRAME_XPAB_ON, xpa_ctl);
++	else
++		REG_RMW_FIELD(ah, AR_PHY_XPA_TIMING_CTL,
++			      AR_PHY_XPA_TIMING_CTL_FRAME_XPAA_ON, xpa_ctl);
++}
++
++static void ar9003_hw_xlna_bias_strength_apply(struct ath_hw *ah, bool is2ghz)
++{
++	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
++	u8 bias;
++
++	if (!(eep->baseEepHeader.featureEnable & 0x40))
++		return;
++
++	if (!AR_SREV_9300(ah))
++		return;
++
++	bias = ar9003_modal_header(ah, is2ghz)->xlna_bias_strength;
++	REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,
++		      bias & 0x3);
++	bias >>= 2;
++	REG_RMW_FIELD(ah, AR_PHY_65NM_CH1_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,
++		      bias & 0x3);
++	bias >>= 2;
++	REG_RMW_FIELD(ah, AR_PHY_65NM_CH2_RXTX4, AR_PHY_65NM_RXTX4_XLNA_BIAS,
++		      bias & 0x3);
++}
++
+ static void ath9k_hw_ar9300_set_board_values(struct ath_hw *ah,
+ 					     struct ath9k_channel *chan)
+ {
+-	ar9003_hw_xpa_bias_level_apply(ah, IS_CHAN_2GHZ(chan));
+-	ar9003_hw_ant_ctrl_apply(ah, IS_CHAN_2GHZ(chan));
++	bool is2ghz = IS_CHAN_2GHZ(chan);
++	ar9003_hw_xpa_timing_control_apply(ah, is2ghz);
++	ar9003_hw_xpa_bias_level_apply(ah, is2ghz);
++	ar9003_hw_ant_ctrl_apply(ah, is2ghz);
+ 	ar9003_hw_drive_strength_apply(ah);
++	ar9003_hw_xlna_bias_strength_apply(ah, is2ghz);
+ 	ar9003_hw_atten_apply(ah, chan);
+ 	ar9003_hw_quick_drop_apply(ah, chan->channel);
+ 	if (!AR_SREV_9330(ah) && !AR_SREV_9340(ah) && !AR_SREV_9550(ah))
+ 		ar9003_hw_internal_regulator_apply(ah);
+-	if (AR_SREV_9485(ah) || AR_SREV_9330(ah) || AR_SREV_9340(ah))
+-		ar9003_hw_apply_tuning_caps(ah);
+-	ar9003_hw_txend_to_xpa_off_apply(ah, chan->channel);
++	ar9003_hw_apply_tuning_caps(ah);
++	ar9003_hw_txend_to_xpa_off_apply(ah, is2ghz);
+ }
+ 
+ static void ath9k_hw_ar9300_set_addac(struct ath_hw *ah,
+@@ -5100,14 +5127,9 @@ s32 ar9003_hw_get_rx_gain_idx(struct ath
+ 	return (eep->baseEepHeader.txrxgain) & 0xf; /* bits 3:0 */
+ }
+ 
+-u8 *ar9003_get_spur_chan_ptr(struct ath_hw *ah, bool is_2ghz)
++u8 *ar9003_get_spur_chan_ptr(struct ath_hw *ah, bool is2ghz)
+ {
+-	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+-
+-	if (is_2ghz)
+-		return eep->modalHeader2G.spurChans;
+-	else
+-		return eep->modalHeader5G.spurChans;
++	return ar9003_modal_header(ah, is2ghz)->spurChans;
+ }
+ 
+ unsigned int ar9003_get_paprd_scale_factor(struct ath_hw *ah,
+--- a/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_eeprom.h
+@@ -231,7 +231,8 @@ struct ar9300_modal_eep_header {
+ 	__le32 papdRateMaskHt20;
+ 	__le32 papdRateMaskHt40;
+ 	__le16 switchcomspdt;
+-	u8 futureModal[8];
++	u8 xlna_bias_strength;
++	u8 futureModal[7];
+ } __packed;
+ 
+ struct ar9300_cal_data_per_freq_op_loop {
+--- a/drivers/net/wireless/ath/ath9k/ar9003_hw.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_hw.c
+@@ -44,462 +44,310 @@ static void ar9003_hw_init_mode_regs(str
+ 		ar9462_2p0_baseband_core_txfir_coeff_japan_2484
+ 	if (AR_SREV_9330_11(ah)) {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar9331_1p1_mac_core,
+-				ARRAY_SIZE(ar9331_1p1_mac_core), 2);
++				ar9331_1p1_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9331_1p1_mac_postamble,
+-				ARRAY_SIZE(ar9331_1p1_mac_postamble), 5);
++				ar9331_1p1_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9331_1p1_baseband_core,
+-				ARRAY_SIZE(ar9331_1p1_baseband_core), 2);
++				ar9331_1p1_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9331_1p1_baseband_postamble,
+-				ARRAY_SIZE(ar9331_1p1_baseband_postamble), 5);
++				ar9331_1p1_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9331_1p1_radio_core,
+-				ARRAY_SIZE(ar9331_1p1_radio_core), 2);
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST], NULL, 0, 0);
++				ar9331_1p1_radio_core);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9331_1p1_soc_preamble,
+-				ARRAY_SIZE(ar9331_1p1_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar9331_1p1_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar9331_1p1_soc_postamble,
+-				ARRAY_SIZE(ar9331_1p1_soc_postamble), 2);
++				ar9331_1p1_soc_postamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9331_common_rx_gain_1p1,
+-				ARRAY_SIZE(ar9331_common_rx_gain_1p1), 2);
++				ar9331_common_rx_gain_1p1);
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_lowest_ob_db_tx_gain_1p1,
+-			ARRAY_SIZE(ar9331_modes_lowest_ob_db_tx_gain_1p1),
+-			5);
++				ar9331_modes_lowest_ob_db_tx_gain_1p1);
+ 
+ 		/* additional clock settings */
+ 		if (ah->is_clk_25mhz)
+ 			INIT_INI_ARRAY(&ah->iniAdditional,
+-					ar9331_1p1_xtal_25M,
+-					ARRAY_SIZE(ar9331_1p1_xtal_25M), 2);
++					ar9331_1p1_xtal_25M);
+ 		else
+ 			INIT_INI_ARRAY(&ah->iniAdditional,
+-					ar9331_1p1_xtal_40M,
+-					ARRAY_SIZE(ar9331_1p1_xtal_40M), 2);
++					ar9331_1p1_xtal_40M);
+ 	} else if (AR_SREV_9330_12(ah)) {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar9331_1p2_mac_core,
+-				ARRAY_SIZE(ar9331_1p2_mac_core), 2);
++				ar9331_1p2_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9331_1p2_mac_postamble,
+-				ARRAY_SIZE(ar9331_1p2_mac_postamble), 5);
++				ar9331_1p2_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9331_1p2_baseband_core,
+-				ARRAY_SIZE(ar9331_1p2_baseband_core), 2);
++				ar9331_1p2_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9331_1p2_baseband_postamble,
+-				ARRAY_SIZE(ar9331_1p2_baseband_postamble), 5);
++				ar9331_1p2_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9331_1p2_radio_core,
+-				ARRAY_SIZE(ar9331_1p2_radio_core), 2);
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST], NULL, 0, 0);
++				ar9331_1p2_radio_core);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9331_1p2_soc_preamble,
+-				ARRAY_SIZE(ar9331_1p2_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar9331_1p2_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar9331_1p2_soc_postamble,
+-				ARRAY_SIZE(ar9331_1p2_soc_postamble), 2);
++				ar9331_1p2_soc_postamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9331_common_rx_gain_1p2,
+-				ARRAY_SIZE(ar9331_common_rx_gain_1p2), 2);
++				ar9331_common_rx_gain_1p2);
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_lowest_ob_db_tx_gain_1p2,
+-			ARRAY_SIZE(ar9331_modes_lowest_ob_db_tx_gain_1p2),
+-			5);
++				ar9331_modes_lowest_ob_db_tx_gain_1p2);
+ 
+ 		/* additional clock settings */
+ 		if (ah->is_clk_25mhz)
+ 			INIT_INI_ARRAY(&ah->iniAdditional,
+-					ar9331_1p2_xtal_25M,
+-					ARRAY_SIZE(ar9331_1p2_xtal_25M), 2);
++					ar9331_1p2_xtal_25M);
+ 		else
+ 			INIT_INI_ARRAY(&ah->iniAdditional,
+-					ar9331_1p2_xtal_40M,
+-					ARRAY_SIZE(ar9331_1p2_xtal_40M), 2);
++					ar9331_1p2_xtal_40M);
+ 	} else if (AR_SREV_9340(ah)) {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar9340_1p0_mac_core,
+-				ARRAY_SIZE(ar9340_1p0_mac_core), 2);
++				ar9340_1p0_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9340_1p0_mac_postamble,
+-				ARRAY_SIZE(ar9340_1p0_mac_postamble), 5);
++				ar9340_1p0_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9340_1p0_baseband_core,
+-				ARRAY_SIZE(ar9340_1p0_baseband_core), 2);
++				ar9340_1p0_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9340_1p0_baseband_postamble,
+-				ARRAY_SIZE(ar9340_1p0_baseband_postamble), 5);
++				ar9340_1p0_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9340_1p0_radio_core,
+-				ARRAY_SIZE(ar9340_1p0_radio_core), 2);
++				ar9340_1p0_radio_core);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+-				ar9340_1p0_radio_postamble,
+-				ARRAY_SIZE(ar9340_1p0_radio_postamble), 5);
++				ar9340_1p0_radio_postamble);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9340_1p0_soc_preamble,
+-				ARRAY_SIZE(ar9340_1p0_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar9340_1p0_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar9340_1p0_soc_postamble,
+-				ARRAY_SIZE(ar9340_1p0_soc_postamble), 5);
++				ar9340_1p0_soc_postamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9340Common_wo_xlna_rx_gain_table_1p0,
+-				ARRAY_SIZE(ar9340Common_wo_xlna_rx_gain_table_1p0),
+-				5);
+-		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9340Modes_high_ob_db_tx_gain_table_1p0,
+-				ARRAY_SIZE(ar9340Modes_high_ob_db_tx_gain_table_1p0),
+-				5);
++				ar9340Common_wo_xlna_rx_gain_table_1p0);
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++				ar9340Modes_high_ob_db_tx_gain_table_1p0);
+ 
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+-				ar9340Modes_fast_clock_1p0,
+-				ARRAY_SIZE(ar9340Modes_fast_clock_1p0),
+-				3);
++				ar9340Modes_fast_clock_1p0);
+ 
+ 		if (!ah->is_clk_25mhz)
+ 			INIT_INI_ARRAY(&ah->iniAdditional,
+-				       ar9340_1p0_radio_core_40M,
+-				       ARRAY_SIZE(ar9340_1p0_radio_core_40M),
+-				       2);
++				       ar9340_1p0_radio_core_40M);
+ 	} else if (AR_SREV_9485_11(ah)) {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar9485_1_1_mac_core,
+-				ARRAY_SIZE(ar9485_1_1_mac_core), 2);
++				ar9485_1_1_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9485_1_1_mac_postamble,
+-				ARRAY_SIZE(ar9485_1_1_mac_postamble), 5);
++				ar9485_1_1_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], ar9485_1_1,
+-				ARRAY_SIZE(ar9485_1_1), 2);
++		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], ar9485_1_1);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9485_1_1_baseband_core,
+-				ARRAY_SIZE(ar9485_1_1_baseband_core), 2);
++				ar9485_1_1_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9485_1_1_baseband_postamble,
+-				ARRAY_SIZE(ar9485_1_1_baseband_postamble), 5);
++				ar9485_1_1_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9485_1_1_radio_core,
+-				ARRAY_SIZE(ar9485_1_1_radio_core), 2);
++				ar9485_1_1_radio_core);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+-				ar9485_1_1_radio_postamble,
+-				ARRAY_SIZE(ar9485_1_1_radio_postamble), 2);
++				ar9485_1_1_radio_postamble);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9485_1_1_soc_preamble,
+-				ARRAY_SIZE(ar9485_1_1_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST], NULL, 0, 0);
++				ar9485_1_1_soc_preamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9485Common_wo_xlna_rx_gain_1_1,
+-				ARRAY_SIZE(ar9485Common_wo_xlna_rx_gain_1_1), 2);
++				ar9485Common_wo_xlna_rx_gain_1_1);
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9485_modes_lowest_ob_db_tx_gain_1_1,
+-				ARRAY_SIZE(ar9485_modes_lowest_ob_db_tx_gain_1_1),
+-				5);
++				ar9485_modes_lowest_ob_db_tx_gain_1_1);
+ 
+ 		/* Load PCIE SERDES settings from INI */
+ 
+ 		/* Awake Setting */
+ 
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdes,
+-				ar9485_1_1_pcie_phy_clkreq_disable_L1,
+-				ARRAY_SIZE(ar9485_1_1_pcie_phy_clkreq_disable_L1),
+-				2);
++				ar9485_1_1_pcie_phy_clkreq_disable_L1);
+ 
+ 		/* Sleep Setting */
+ 
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
+-				ar9485_1_1_pcie_phy_clkreq_disable_L1,
+-				ARRAY_SIZE(ar9485_1_1_pcie_phy_clkreq_disable_L1),
+-				2);
++				ar9485_1_1_pcie_phy_clkreq_disable_L1);
+ 	} else if (AR_SREV_9462_20(ah)) {
+ 
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE], ar9462_2p0_mac_core,
+-				ARRAY_SIZE(ar9462_2p0_mac_core), 2);
++		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE], ar9462_2p0_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9462_2p0_mac_postamble,
+-				ARRAY_SIZE(ar9462_2p0_mac_postamble), 5);
++				ar9462_2p0_mac_postamble);
+ 
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9462_2p0_baseband_core,
+-				ARRAY_SIZE(ar9462_2p0_baseband_core), 2);
++				ar9462_2p0_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9462_2p0_baseband_postamble,
+-				ARRAY_SIZE(ar9462_2p0_baseband_postamble), 5);
++				ar9462_2p0_baseband_postamble);
+ 
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9462_2p0_radio_core,
+-				ARRAY_SIZE(ar9462_2p0_radio_core), 2);
++				ar9462_2p0_radio_core);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+-				ar9462_2p0_radio_postamble,
+-				ARRAY_SIZE(ar9462_2p0_radio_postamble), 5);
++				ar9462_2p0_radio_postamble);
+ 		INIT_INI_ARRAY(&ah->ini_radio_post_sys2ant,
+-				ar9462_2p0_radio_postamble_sys2ant,
+-				ARRAY_SIZE(ar9462_2p0_radio_postamble_sys2ant),
+-				5);
++				ar9462_2p0_radio_postamble_sys2ant);
+ 
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9462_2p0_soc_preamble,
+-				ARRAY_SIZE(ar9462_2p0_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar9462_2p0_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar9462_2p0_soc_postamble,
+-				ARRAY_SIZE(ar9462_2p0_soc_postamble), 5);
++				ar9462_2p0_soc_postamble);
+ 
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9462_common_rx_gain_table_2p0,
+-				ARRAY_SIZE(ar9462_common_rx_gain_table_2p0), 2);
++				ar9462_common_rx_gain_table_2p0);
+ 
+ 		/* Awake -> Sleep Setting */
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdes,
+-				PCIE_PLL_ON_CREQ_DIS_L1_2P0,
+-				ARRAY_SIZE(PCIE_PLL_ON_CREQ_DIS_L1_2P0),
+-				2);
++				PCIE_PLL_ON_CREQ_DIS_L1_2P0);
+ 		/* Sleep -> Awake Setting */
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
+-				PCIE_PLL_ON_CREQ_DIS_L1_2P0,
+-				ARRAY_SIZE(PCIE_PLL_ON_CREQ_DIS_L1_2P0),
+-				2);
++				PCIE_PLL_ON_CREQ_DIS_L1_2P0);
+ 
+ 		/* Fast clock modal settings */
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+-				ar9462_modes_fast_clock_2p0,
+-				ARRAY_SIZE(ar9462_modes_fast_clock_2p0), 3);
++				ar9462_modes_fast_clock_2p0);
+ 
+ 		INIT_INI_ARRAY(&ah->iniCckfirJapan2484,
+-				AR9462_BB_CTX_COEFJ(2p0),
+-				ARRAY_SIZE(AR9462_BB_CTX_COEFJ(2p0)), 2);
++				AR9462_BB_CTX_COEFJ(2p0));
+ 
+-		INIT_INI_ARRAY(&ah->ini_japan2484, AR9462_BBC_TXIFR_COEFFJ,
+-				ARRAY_SIZE(AR9462_BBC_TXIFR_COEFFJ), 2);
++		INIT_INI_ARRAY(&ah->ini_japan2484, AR9462_BBC_TXIFR_COEFFJ);
+ 	} else if (AR_SREV_9550(ah)) {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar955x_1p0_mac_core,
+-				ARRAY_SIZE(ar955x_1p0_mac_core), 2);
++				ar955x_1p0_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar955x_1p0_mac_postamble,
+-				ARRAY_SIZE(ar955x_1p0_mac_postamble), 5);
++				ar955x_1p0_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar955x_1p0_baseband_core,
+-				ARRAY_SIZE(ar955x_1p0_baseband_core), 2);
++				ar955x_1p0_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar955x_1p0_baseband_postamble,
+-				ARRAY_SIZE(ar955x_1p0_baseband_postamble), 5);
++				ar955x_1p0_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar955x_1p0_radio_core,
+-				ARRAY_SIZE(ar955x_1p0_radio_core), 2);
++				ar955x_1p0_radio_core);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+-				ar955x_1p0_radio_postamble,
+-				ARRAY_SIZE(ar955x_1p0_radio_postamble), 5);
++				ar955x_1p0_radio_postamble);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar955x_1p0_soc_preamble,
+-				ARRAY_SIZE(ar955x_1p0_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar955x_1p0_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar955x_1p0_soc_postamble,
+-				ARRAY_SIZE(ar955x_1p0_soc_postamble), 5);
++				ar955x_1p0_soc_postamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar955x_1p0_common_wo_xlna_rx_gain_table,
+-			ARRAY_SIZE(ar955x_1p0_common_wo_xlna_rx_gain_table),
+-			2);
++			ar955x_1p0_common_wo_xlna_rx_gain_table);
+ 		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+-			ar955x_1p0_common_wo_xlna_rx_gain_bounds,
+-			ARRAY_SIZE(ar955x_1p0_common_wo_xlna_rx_gain_bounds),
+-			5);
+-		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar955x_1p0_modes_xpa_tx_gain_table,
+-				ARRAY_SIZE(ar955x_1p0_modes_xpa_tx_gain_table),
+-				9);
++			ar955x_1p0_common_wo_xlna_rx_gain_bounds);
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++				ar955x_1p0_modes_xpa_tx_gain_table);
+ 
+ 		/* Fast clock modal settings */
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+-				ar955x_1p0_modes_fast_clock,
+-				ARRAY_SIZE(ar955x_1p0_modes_fast_clock), 3);
++				ar955x_1p0_modes_fast_clock);
+ 	} else if (AR_SREV_9580(ah)) {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar9580_1p0_mac_core,
+-				ARRAY_SIZE(ar9580_1p0_mac_core), 2);
++				ar9580_1p0_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9580_1p0_mac_postamble,
+-				ARRAY_SIZE(ar9580_1p0_mac_postamble), 5);
++				ar9580_1p0_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9580_1p0_baseband_core,
+-				ARRAY_SIZE(ar9580_1p0_baseband_core), 2);
++				ar9580_1p0_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9580_1p0_baseband_postamble,
+-				ARRAY_SIZE(ar9580_1p0_baseband_postamble), 5);
++				ar9580_1p0_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9580_1p0_radio_core,
+-				ARRAY_SIZE(ar9580_1p0_radio_core), 2);
++				ar9580_1p0_radio_core);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+-				ar9580_1p0_radio_postamble,
+-				ARRAY_SIZE(ar9580_1p0_radio_postamble), 5);
++				ar9580_1p0_radio_postamble);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9580_1p0_soc_preamble,
+-				ARRAY_SIZE(ar9580_1p0_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar9580_1p0_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar9580_1p0_soc_postamble,
+-				ARRAY_SIZE(ar9580_1p0_soc_postamble), 5);
++				ar9580_1p0_soc_postamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9580_1p0_rx_gain_table,
+-				ARRAY_SIZE(ar9580_1p0_rx_gain_table), 2);
++				ar9580_1p0_rx_gain_table);
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9580_1p0_low_ob_db_tx_gain_table,
+-				ARRAY_SIZE(ar9580_1p0_low_ob_db_tx_gain_table),
+-				5);
++				ar9580_1p0_low_ob_db_tx_gain_table);
+ 
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+-				ar9580_1p0_modes_fast_clock,
+-				ARRAY_SIZE(ar9580_1p0_modes_fast_clock),
+-				3);
++				ar9580_1p0_modes_fast_clock);
+ 	} else {
+ 		/* mac */
+-		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_CORE],
+-				ar9300_2p2_mac_core,
+-				ARRAY_SIZE(ar9300_2p2_mac_core), 2);
++				ar9300_2p2_mac_core);
+ 		INIT_INI_ARRAY(&ah->iniMac[ATH_INI_POST],
+-				ar9300_2p2_mac_postamble,
+-				ARRAY_SIZE(ar9300_2p2_mac_postamble), 5);
++				ar9300_2p2_mac_postamble);
+ 
+ 		/* bb */
+-		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_CORE],
+-				ar9300_2p2_baseband_core,
+-				ARRAY_SIZE(ar9300_2p2_baseband_core), 2);
++				ar9300_2p2_baseband_core);
+ 		INIT_INI_ARRAY(&ah->iniBB[ATH_INI_POST],
+-				ar9300_2p2_baseband_postamble,
+-				ARRAY_SIZE(ar9300_2p2_baseband_postamble), 5);
++				ar9300_2p2_baseband_postamble);
+ 
+ 		/* radio */
+-		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_PRE], NULL, 0, 0);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_CORE],
+-				ar9300_2p2_radio_core,
+-				ARRAY_SIZE(ar9300_2p2_radio_core), 2);
++				ar9300_2p2_radio_core);
+ 		INIT_INI_ARRAY(&ah->iniRadio[ATH_INI_POST],
+-				ar9300_2p2_radio_postamble,
+-				ARRAY_SIZE(ar9300_2p2_radio_postamble), 5);
++				ar9300_2p2_radio_postamble);
+ 
+ 		/* soc */
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_PRE],
+-				ar9300_2p2_soc_preamble,
+-				ARRAY_SIZE(ar9300_2p2_soc_preamble), 2);
+-		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_CORE], NULL, 0, 0);
++				ar9300_2p2_soc_preamble);
+ 		INIT_INI_ARRAY(&ah->iniSOC[ATH_INI_POST],
+-				ar9300_2p2_soc_postamble,
+-				ARRAY_SIZE(ar9300_2p2_soc_postamble), 5);
++				ar9300_2p2_soc_postamble);
+ 
+ 		/* rx/tx gain */
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9300Common_rx_gain_table_2p2,
+-				ARRAY_SIZE(ar9300Common_rx_gain_table_2p2), 2);
++				ar9300Common_rx_gain_table_2p2);
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-				ar9300Modes_lowest_ob_db_tx_gain_table_2p2,
+-				ARRAY_SIZE(ar9300Modes_lowest_ob_db_tx_gain_table_2p2),
+-				5);
++				ar9300Modes_lowest_ob_db_tx_gain_table_2p2);
+ 
+ 		/* Load PCIE SERDES settings from INI */
+ 
+ 		/* Awake Setting */
+ 
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdes,
+-				ar9300PciePhy_pll_on_clkreq_disable_L1_2p2,
+-				ARRAY_SIZE(ar9300PciePhy_pll_on_clkreq_disable_L1_2p2),
+-				2);
++				ar9300PciePhy_pll_on_clkreq_disable_L1_2p2);
+ 
+ 		/* Sleep Setting */
+ 
+ 		INIT_INI_ARRAY(&ah->iniPcieSerdesLowPower,
+-				ar9300PciePhy_pll_on_clkreq_disable_L1_2p2,
+-				ARRAY_SIZE(ar9300PciePhy_pll_on_clkreq_disable_L1_2p2),
+-				2);
++				ar9300PciePhy_pll_on_clkreq_disable_L1_2p2);
+ 
+ 		/* Fast clock modal settings */
+ 		INIT_INI_ARRAY(&ah->iniModesFastClock,
+-				ar9300Modes_fast_clock_2p2,
+-				ARRAY_SIZE(ar9300Modes_fast_clock_2p2),
+-				3);
++				ar9300Modes_fast_clock_2p2);
+ 	}
+ }
+ 
+@@ -507,156 +355,110 @@ static void ar9003_tx_gain_table_mode0(s
+ {
+ 	if (AR_SREV_9330_12(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_lowest_ob_db_tx_gain_1p2,
+-			ARRAY_SIZE(ar9331_modes_lowest_ob_db_tx_gain_1p2),
+-			5);
++			ar9331_modes_lowest_ob_db_tx_gain_1p2);
+ 	else if (AR_SREV_9330_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_lowest_ob_db_tx_gain_1p1,
+-			ARRAY_SIZE(ar9331_modes_lowest_ob_db_tx_gain_1p1),
+-			5);
++			ar9331_modes_lowest_ob_db_tx_gain_1p1);
+ 	else if (AR_SREV_9340(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9340Modes_lowest_ob_db_tx_gain_table_1p0,
+-			ARRAY_SIZE(ar9340Modes_lowest_ob_db_tx_gain_table_1p0),
+-			5);
++			ar9340Modes_lowest_ob_db_tx_gain_table_1p0);
+ 	else if (AR_SREV_9485_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9485_modes_lowest_ob_db_tx_gain_1_1,
+-			ARRAY_SIZE(ar9485_modes_lowest_ob_db_tx_gain_1_1),
+-			5);
++			ar9485_modes_lowest_ob_db_tx_gain_1_1);
+ 	else if (AR_SREV_9550(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar955x_1p0_modes_xpa_tx_gain_table,
+-			ARRAY_SIZE(ar955x_1p0_modes_xpa_tx_gain_table),
+-			9);
++			ar955x_1p0_modes_xpa_tx_gain_table);
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9580_1p0_lowest_ob_db_tx_gain_table,
+-			ARRAY_SIZE(ar9580_1p0_lowest_ob_db_tx_gain_table),
+-			5);
++			ar9580_1p0_lowest_ob_db_tx_gain_table);
+ 	else if (AR_SREV_9462_20(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9462_modes_low_ob_db_tx_gain_table_2p0,
+-			ARRAY_SIZE(ar9462_modes_low_ob_db_tx_gain_table_2p0),
+-			5);
++			ar9462_modes_low_ob_db_tx_gain_table_2p0);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9300Modes_lowest_ob_db_tx_gain_table_2p2,
+-			ARRAY_SIZE(ar9300Modes_lowest_ob_db_tx_gain_table_2p2),
+-			5);
++			ar9300Modes_lowest_ob_db_tx_gain_table_2p2);
+ }
+ 
+ static void ar9003_tx_gain_table_mode1(struct ath_hw *ah)
+ {
+ 	if (AR_SREV_9330_12(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_high_ob_db_tx_gain_1p2,
+-			ARRAY_SIZE(ar9331_modes_high_ob_db_tx_gain_1p2),
+-			5);
++			ar9331_modes_high_ob_db_tx_gain_1p2);
+ 	else if (AR_SREV_9330_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_high_ob_db_tx_gain_1p1,
+-			ARRAY_SIZE(ar9331_modes_high_ob_db_tx_gain_1p1),
+-			5);
++			ar9331_modes_high_ob_db_tx_gain_1p1);
+ 	else if (AR_SREV_9340(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9340Modes_lowest_ob_db_tx_gain_table_1p0,
+-			ARRAY_SIZE(ar9340Modes_lowest_ob_db_tx_gain_table_1p0),
+-			5);
++			ar9340Modes_high_ob_db_tx_gain_table_1p0);
+ 	else if (AR_SREV_9485_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9485Modes_high_ob_db_tx_gain_1_1,
+-			ARRAY_SIZE(ar9485Modes_high_ob_db_tx_gain_1_1),
+-			5);
++			ar9485Modes_high_ob_db_tx_gain_1_1);
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9580_1p0_high_ob_db_tx_gain_table,
+-			ARRAY_SIZE(ar9580_1p0_high_ob_db_tx_gain_table),
+-			5);
++			ar9580_1p0_high_ob_db_tx_gain_table);
+ 	else if (AR_SREV_9550(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar955x_1p0_modes_no_xpa_tx_gain_table,
+-			ARRAY_SIZE(ar955x_1p0_modes_no_xpa_tx_gain_table),
+-			9);
++			ar955x_1p0_modes_no_xpa_tx_gain_table);
+ 	else if (AR_SREV_9462_20(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9462_modes_high_ob_db_tx_gain_table_2p0,
+-			ARRAY_SIZE(ar9462_modes_high_ob_db_tx_gain_table_2p0),
+-			5);
++			ar9462_modes_high_ob_db_tx_gain_table_2p0);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9300Modes_high_ob_db_tx_gain_table_2p2,
+-			ARRAY_SIZE(ar9300Modes_high_ob_db_tx_gain_table_2p2),
+-			5);
++			ar9300Modes_high_ob_db_tx_gain_table_2p2);
+ }
+ 
+ static void ar9003_tx_gain_table_mode2(struct ath_hw *ah)
+ {
+ 	if (AR_SREV_9330_12(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_low_ob_db_tx_gain_1p2,
+-			ARRAY_SIZE(ar9331_modes_low_ob_db_tx_gain_1p2),
+-			5);
++			ar9331_modes_low_ob_db_tx_gain_1p2);
+ 	else if (AR_SREV_9330_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_low_ob_db_tx_gain_1p1,
+-			ARRAY_SIZE(ar9331_modes_low_ob_db_tx_gain_1p1),
+-			5);
++			ar9331_modes_low_ob_db_tx_gain_1p1);
+ 	else if (AR_SREV_9340(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9340Modes_lowest_ob_db_tx_gain_table_1p0,
+-			ARRAY_SIZE(ar9340Modes_lowest_ob_db_tx_gain_table_1p0),
+-			5);
++			ar9340Modes_low_ob_db_tx_gain_table_1p0);
+ 	else if (AR_SREV_9485_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9485Modes_low_ob_db_tx_gain_1_1,
+-			ARRAY_SIZE(ar9485Modes_low_ob_db_tx_gain_1_1),
+-			5);
++			ar9485Modes_low_ob_db_tx_gain_1_1);
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9580_1p0_low_ob_db_tx_gain_table,
+-			ARRAY_SIZE(ar9580_1p0_low_ob_db_tx_gain_table),
+-			5);
++			ar9580_1p0_low_ob_db_tx_gain_table);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9300Modes_low_ob_db_tx_gain_table_2p2,
+-			ARRAY_SIZE(ar9300Modes_low_ob_db_tx_gain_table_2p2),
+-			5);
++			ar9300Modes_low_ob_db_tx_gain_table_2p2);
+ }
+ 
+ static void ar9003_tx_gain_table_mode3(struct ath_hw *ah)
+ {
+ 	if (AR_SREV_9330_12(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_high_power_tx_gain_1p2,
+-			ARRAY_SIZE(ar9331_modes_high_power_tx_gain_1p2),
+-			5);
++			ar9331_modes_high_power_tx_gain_1p2);
+ 	else if (AR_SREV_9330_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9331_modes_high_power_tx_gain_1p1,
+-			ARRAY_SIZE(ar9331_modes_high_power_tx_gain_1p1),
+-			5);
++			ar9331_modes_high_power_tx_gain_1p1);
+ 	else if (AR_SREV_9340(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9340Modes_lowest_ob_db_tx_gain_table_1p0,
+-			ARRAY_SIZE(ar9340Modes_lowest_ob_db_tx_gain_table_1p0),
+-			5);
++			ar9340Modes_high_power_tx_gain_table_1p0);
+ 	else if (AR_SREV_9485_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9485Modes_high_power_tx_gain_1_1,
+-			ARRAY_SIZE(ar9485Modes_high_power_tx_gain_1_1),
+-			5);
++			ar9485Modes_high_power_tx_gain_1_1);
+ 	else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9580_1p0_high_power_tx_gain_table,
+-			ARRAY_SIZE(ar9580_1p0_high_power_tx_gain_table),
+-			5);
++			ar9580_1p0_high_power_tx_gain_table);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesTxGain,
+-			ar9300Modes_high_power_tx_gain_table_2p2,
+-			ARRAY_SIZE(ar9300Modes_high_power_tx_gain_table_2p2),
+-			5);
++			ar9300Modes_high_power_tx_gain_table_2p2);
++}
++
++static void ar9003_tx_gain_table_mode4(struct ath_hw *ah)
++{
++	if (AR_SREV_9340(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			ar9340Modes_mixed_ob_db_tx_gain_table_1p0);
++	else if (AR_SREV_9580(ah))
++		INIT_INI_ARRAY(&ah->iniModesTxGain,
++			ar9580_1p0_mixed_ob_db_tx_gain_table);
+ }
+ 
+ static void ar9003_tx_gain_table_apply(struct ath_hw *ah)
+@@ -675,6 +477,9 @@ static void ar9003_tx_gain_table_apply(s
+ 	case 3:
+ 		ar9003_tx_gain_table_mode3(ah);
+ 		break;
++	case 4:
++		ar9003_tx_gain_table_mode4(ah);
++		break;
+ 	}
+ }
+ 
+@@ -682,104 +487,67 @@ static void ar9003_rx_gain_table_mode0(s
+ {
+ 	if (AR_SREV_9330_12(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9331_common_rx_gain_1p2,
+-				ARRAY_SIZE(ar9331_common_rx_gain_1p2),
+-				2);
++				ar9331_common_rx_gain_1p2);
+ 	else if (AR_SREV_9330_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9331_common_rx_gain_1p1,
+-				ARRAY_SIZE(ar9331_common_rx_gain_1p1),
+-				2);
++				ar9331_common_rx_gain_1p1);
+ 	else if (AR_SREV_9340(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9340Common_rx_gain_table_1p0,
+-				ARRAY_SIZE(ar9340Common_rx_gain_table_1p0),
+-				2);
++				ar9340Common_rx_gain_table_1p0);
+ 	else if (AR_SREV_9485_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9485Common_wo_xlna_rx_gain_1_1,
+-				ARRAY_SIZE(ar9485Common_wo_xlna_rx_gain_1_1),
+-				2);
++				ar9485Common_wo_xlna_rx_gain_1_1);
+ 	else if (AR_SREV_9550(ah)) {
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar955x_1p0_common_rx_gain_table,
+-				ARRAY_SIZE(ar955x_1p0_common_rx_gain_table),
+-				2);
++				ar955x_1p0_common_rx_gain_table);
+ 		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+-				ar955x_1p0_common_rx_gain_bounds,
+-				ARRAY_SIZE(ar955x_1p0_common_rx_gain_bounds),
+-				5);
++				ar955x_1p0_common_rx_gain_bounds);
+ 	} else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9580_1p0_rx_gain_table,
+-				ARRAY_SIZE(ar9580_1p0_rx_gain_table),
+-				2);
++				ar9580_1p0_rx_gain_table);
+ 	else if (AR_SREV_9462_20(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9462_common_rx_gain_table_2p0,
+-				ARRAY_SIZE(ar9462_common_rx_gain_table_2p0),
+-				2);
++				ar9462_common_rx_gain_table_2p0);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-				ar9300Common_rx_gain_table_2p2,
+-				ARRAY_SIZE(ar9300Common_rx_gain_table_2p2),
+-				2);
++				ar9300Common_rx_gain_table_2p2);
+ }
+ 
+ static void ar9003_rx_gain_table_mode1(struct ath_hw *ah)
+ {
+ 	if (AR_SREV_9330_12(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9331_common_wo_xlna_rx_gain_1p2,
+-			ARRAY_SIZE(ar9331_common_wo_xlna_rx_gain_1p2),
+-			2);
++			ar9331_common_wo_xlna_rx_gain_1p2);
+ 	else if (AR_SREV_9330_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9331_common_wo_xlna_rx_gain_1p1,
+-			ARRAY_SIZE(ar9331_common_wo_xlna_rx_gain_1p1),
+-			2);
++			ar9331_common_wo_xlna_rx_gain_1p1);
+ 	else if (AR_SREV_9340(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9340Common_wo_xlna_rx_gain_table_1p0,
+-			ARRAY_SIZE(ar9340Common_wo_xlna_rx_gain_table_1p0),
+-			2);
++			ar9340Common_wo_xlna_rx_gain_table_1p0);
+ 	else if (AR_SREV_9485_11(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9485Common_wo_xlna_rx_gain_1_1,
+-			ARRAY_SIZE(ar9485Common_wo_xlna_rx_gain_1_1),
+-			2);
++			ar9485Common_wo_xlna_rx_gain_1_1);
+ 	else if (AR_SREV_9462_20(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9462_common_wo_xlna_rx_gain_table_2p0,
+-			ARRAY_SIZE(ar9462_common_wo_xlna_rx_gain_table_2p0),
+-			2);
++			ar9462_common_wo_xlna_rx_gain_table_2p0);
+ 	else if (AR_SREV_9550(ah)) {
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar955x_1p0_common_wo_xlna_rx_gain_table,
+-			ARRAY_SIZE(ar955x_1p0_common_wo_xlna_rx_gain_table),
+-			2);
++			ar955x_1p0_common_wo_xlna_rx_gain_table);
+ 		INIT_INI_ARRAY(&ah->ini_modes_rx_gain_bounds,
+-			ar955x_1p0_common_wo_xlna_rx_gain_bounds,
+-			ARRAY_SIZE(ar955x_1p0_common_wo_xlna_rx_gain_bounds),
+-			5);
++			ar955x_1p0_common_wo_xlna_rx_gain_bounds);
+ 	} else if (AR_SREV_9580(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9580_1p0_wo_xlna_rx_gain_table,
+-			ARRAY_SIZE(ar9580_1p0_wo_xlna_rx_gain_table),
+-			2);
++			ar9580_1p0_wo_xlna_rx_gain_table);
+ 	else
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			ar9300Common_wo_xlna_rx_gain_table_2p2,
+-			ARRAY_SIZE(ar9300Common_wo_xlna_rx_gain_table_2p2),
+-			2);
++			ar9300Common_wo_xlna_rx_gain_table_2p2);
+ }
+ 
+ static void ar9003_rx_gain_table_mode2(struct ath_hw *ah)
+ {
+ 	if (AR_SREV_9462_20(ah))
+ 		INIT_INI_ARRAY(&ah->iniModesRxGain,
+-			       ar9462_common_mixed_rx_gain_table_2p0,
+-			       ARRAY_SIZE(ar9462_common_mixed_rx_gain_table_2p0), 2);
++			       ar9462_common_mixed_rx_gain_table_2p0);
+ }
+ 
+ static void ar9003_rx_gain_table_apply(struct ath_hw *ah)
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.c
+@@ -117,8 +117,8 @@ static int ar9003_hw_set_channel(struct 
+ 		    ah->is_clk_25mhz) {
+ 			u32 chan_frac;
+ 
+-			channelSel = (freq * 2) / 75;
+-			chan_frac = (((freq * 2) % 75) * 0x20000) / 75;
++			channelSel = freq / 75;
++			chan_frac = ((freq % 75) * 0x20000) / 75;
+ 			channelSel = (channelSel << 17) | chan_frac;
+ 		} else {
+ 			channelSel = CHANSEL_5G(freq);
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+@@ -633,6 +633,8 @@
+ #define AR_PHY_65NM_CH0_BIAS2       0x160c4
+ #define AR_PHY_65NM_CH0_BIAS4       0x160cc
+ #define AR_PHY_65NM_CH0_RXTX4       0x1610c
++#define AR_PHY_65NM_CH1_RXTX4       0x1650c
++#define AR_PHY_65NM_CH2_RXTX4       0x1690c
+ 
+ #define AR_CH0_TOP	(AR_SREV_9300(ah) ? 0x16288 : \
+ 				((AR_SREV_9462(ah) ? 0x1628c : 0x16280)))
+@@ -876,6 +878,9 @@
+ #define AR_PHY_65NM_CH0_RXTX4_THERM_ON          0x10000000
+ #define AR_PHY_65NM_CH0_RXTX4_THERM_ON_S        28
+ 
++#define AR_PHY_65NM_RXTX4_XLNA_BIAS		0xC0000000
++#define AR_PHY_65NM_RXTX4_XLNA_BIAS_S		30
++
+ /*
+  * Channel 1 Register Map
+  */
+--- a/drivers/net/wireless/ath/ath9k/ath9k.h
++++ b/drivers/net/wireless/ath/ath9k/ath9k.h
+@@ -297,6 +297,8 @@ struct ath_tx {
+ 	struct ath_txq txq[ATH9K_NUM_TX_QUEUES];
+ 	struct ath_descdma txdma;
+ 	struct ath_txq *txq_map[WME_NUM_AC];
++	u32 txq_max_pending[WME_NUM_AC];
++	u16 max_aggr_framelen[WME_NUM_AC][4][32];
+ };
+ 
+ struct ath_rx_edma {
+@@ -341,6 +343,7 @@ int ath_tx_init(struct ath_softc *sc, in
+ void ath_tx_cleanup(struct ath_softc *sc);
+ int ath_txq_update(struct ath_softc *sc, int qnum,
+ 		   struct ath9k_tx_queue_info *q);
++void ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop);
+ int ath_tx_start(struct ieee80211_hw *hw, struct sk_buff *skb,
+ 		 struct ath_tx_control *txctl);
+ void ath_tx_tasklet(struct ath_softc *sc);
+@@ -360,7 +363,7 @@ void ath_tx_aggr_sleep(struct ieee80211_
+ 
+ struct ath_vif {
+ 	int av_bslot;
+-	bool is_bslot_active, primary_sta_vif;
++	bool primary_sta_vif;
+ 	__le64 tsf_adjust; /* TSF adjustment for staggered beacons */
+ 	struct ath_buf *av_bcbuf;
+ };
+@@ -386,6 +389,7 @@ struct ath_beacon_config {
+ 	u16 dtim_period;
+ 	u16 bmiss_timeout;
+ 	u8 dtim_count;
++	bool enable_beacon;
+ };
+ 
+ struct ath_beacon {
+@@ -397,7 +401,6 @@ struct ath_beacon {
+ 
+ 	u32 beaconq;
+ 	u32 bmisscnt;
+-	u32 ast_be_xmit;
+ 	u32 bc_tstamp;
+ 	struct ieee80211_vif *bslot[ATH_BCBUF];
+ 	int slottime;
+@@ -411,12 +414,14 @@ struct ath_beacon {
+ 	bool tx_last;
+ };
+ 
+-void ath_beacon_tasklet(unsigned long data);
+-void ath_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif);
+-int ath_beacon_alloc(struct ath_softc *sc, struct ieee80211_vif *vif);
+-void ath_beacon_return(struct ath_softc *sc, struct ath_vif *avp);
+-int ath_beaconq_config(struct ath_softc *sc);
+-void ath_set_beacon(struct ath_softc *sc);
++void ath9k_beacon_tasklet(unsigned long data);
++bool ath9k_allow_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif);
++void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif,
++			 u32 changed);
++void ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif);
++void ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif);
++void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif);
++void ath9k_set_beacon(struct ath_softc *sc);
+ void ath9k_set_beaconing_status(struct ath_softc *sc, bool status);
+ 
+ /*******************/
+@@ -442,9 +447,12 @@ void ath_rx_poll(unsigned long data);
+ void ath_start_rx_poll(struct ath_softc *sc, u8 nbeacon);
+ void ath_paprd_calibrate(struct work_struct *work);
+ void ath_ani_calibrate(unsigned long data);
+-void ath_start_ani(struct ath_common *common);
++void ath_start_ani(struct ath_softc *sc);
++void ath_stop_ani(struct ath_softc *sc);
++void ath_check_ani(struct ath_softc *sc);
+ int ath_update_survey_stats(struct ath_softc *sc);
+ void ath_update_survey_nf(struct ath_softc *sc, int channel);
++void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type);
+ 
+ /**********/
+ /* BTCOEX */
+@@ -619,7 +627,6 @@ enum sc_op_flags {
+ 	SC_OP_INVALID,
+ 	SC_OP_BEACONS,
+ 	SC_OP_RXFLUSH,
+-	SC_OP_TSF_RESET,
+ 	SC_OP_ANI_RUN,
+ 	SC_OP_PRIM_STA_VIF,
+ 	SC_OP_HW_RESET,
+--- a/drivers/net/wireless/ath/ath9k/beacon.c
++++ b/drivers/net/wireless/ath/ath9k/beacon.c
+@@ -30,7 +30,7 @@ static void ath9k_reset_beacon_status(st
+  *  the operating mode of the station (AP or AdHoc).  Parameters are AIFS
+  *  settings and channel width min/max
+ */
+-int ath_beaconq_config(struct ath_softc *sc)
++static void ath9k_beaconq_config(struct ath_softc *sc)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+@@ -38,6 +38,7 @@ int ath_beaconq_config(struct ath_softc 
+ 	struct ath_txq *txq;
+ 
+ 	ath9k_hw_get_txq_props(ah, sc->beacon.beaconq, &qi);
++
+ 	if (sc->sc_ah->opmode == NL80211_IFTYPE_AP) {
+ 		/* Always burst out beacon and CAB traffic. */
+ 		qi.tqi_aifs = 1;
+@@ -56,12 +57,9 @@ int ath_beaconq_config(struct ath_softc 
+ 	}
+ 
+ 	if (!ath9k_hw_set_txq_props(ah, sc->beacon.beaconq, &qi)) {
+-		ath_err(common,
+-			"Unable to update h/w beacon queue parameters\n");
+-		return 0;
++		ath_err(common, "Unable to update h/w beacon queue parameters\n");
+ 	} else {
+ 		ath9k_hw_resettxqueue(ah, sc->beacon.beaconq);
+-		return 1;
+ 	}
+ }
+ 
+@@ -70,7 +68,7 @@ int ath_beaconq_config(struct ath_softc 
+  *  up rate codes, and channel flags. Beacons are always sent out at the
+  *  lowest rate, and are not retried.
+ */
+-static void ath_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif,
++static void ath9k_beacon_setup(struct ath_softc *sc, struct ieee80211_vif *vif,
+ 			     struct ath_buf *bf, int rateidx)
+ {
+ 	struct sk_buff *skb = bf->bf_mpdu;
+@@ -81,8 +79,6 @@ static void ath_beacon_setup(struct ath_
+ 	u8 chainmask = ah->txchainmask;
+ 	u8 rate = 0;
+ 
+-	ath9k_reset_beacon_status(sc);
+-
+ 	sband = &sc->sbands[common->hw->conf.channel->band];
+ 	rate = sband->bitrates[rateidx].hw_value;
+ 	if (vif->bss_conf.use_short_preamble)
+@@ -111,7 +107,7 @@ static void ath_beacon_setup(struct ath_
+ 	ath9k_hw_set_txdesc(ah, bf->bf_desc, &info);
+ }
+ 
+-static void ath_tx_cabq(struct ieee80211_hw *hw, struct sk_buff *skb)
++static void ath9k_tx_cabq(struct ieee80211_hw *hw, struct sk_buff *skb)
+ {
+ 	struct ath_softc *sc = hw->priv;
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+@@ -128,28 +124,22 @@ static void ath_tx_cabq(struct ieee80211
+ 	}
+ }
+ 
+-static struct ath_buf *ath_beacon_generate(struct ieee80211_hw *hw,
+-					   struct ieee80211_vif *vif)
++static struct ath_buf *ath9k_beacon_generate(struct ieee80211_hw *hw,
++					     struct ieee80211_vif *vif)
+ {
+ 	struct ath_softc *sc = hw->priv;
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ 	struct ath_buf *bf;
+-	struct ath_vif *avp;
++	struct ath_vif *avp = (void *)vif->drv_priv;
+ 	struct sk_buff *skb;
+-	struct ath_txq *cabq;
++	struct ath_txq *cabq = sc->beacon.cabq;
+ 	struct ieee80211_tx_info *info;
++	struct ieee80211_mgmt *mgmt_hdr;
+ 	int cabq_depth;
+ 
+-	ath9k_reset_beacon_status(sc);
+-
+-	avp = (void *)vif->drv_priv;
+-	cabq = sc->beacon.cabq;
+-
+-	if ((avp->av_bcbuf == NULL) || !avp->is_bslot_active)
++	if (avp->av_bcbuf == NULL)
+ 		return NULL;
+ 
+-	/* Release the old beacon first */
+-
+ 	bf = avp->av_bcbuf;
+ 	skb = bf->bf_mpdu;
+ 	if (skb) {
+@@ -159,14 +149,14 @@ static struct ath_buf *ath_beacon_genera
+ 		bf->bf_buf_addr = 0;
+ 	}
+ 
+-	/* Get a new beacon from mac80211 */
+-
+ 	skb = ieee80211_beacon_get(hw, vif);
+-	bf->bf_mpdu = skb;
+ 	if (skb == NULL)
+ 		return NULL;
+-	((struct ieee80211_mgmt *)skb->data)->u.beacon.timestamp =
+-		avp->tsf_adjust;
++
++	bf->bf_mpdu = skb;
++
++	mgmt_hdr = (struct ieee80211_mgmt *)skb->data;
++	mgmt_hdr->u.beacon.timestamp = avp->tsf_adjust;
+ 
+ 	info = IEEE80211_SKB_CB(skb);
+ 	if (info->flags & IEEE80211_TX_CTL_ASSIGN_SEQ) {
+@@ -212,61 +202,52 @@ static struct ath_buf *ath_beacon_genera
+ 		}
+ 	}
+ 
+-	ath_beacon_setup(sc, vif, bf, info->control.rates[0].idx);
++	ath9k_beacon_setup(sc, vif, bf, info->control.rates[0].idx);
+ 
+ 	while (skb) {
+-		ath_tx_cabq(hw, skb);
++		ath9k_tx_cabq(hw, skb);
+ 		skb = ieee80211_get_buffered_bc(hw, vif);
+ 	}
+ 
+ 	return bf;
+ }
+ 
+-int ath_beacon_alloc(struct ath_softc *sc, struct ieee80211_vif *vif)
++void ath9k_beacon_assign_slot(struct ath_softc *sc, struct ieee80211_vif *vif)
+ {
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+-	struct ath_vif *avp;
+-	struct ath_buf *bf;
+-	struct sk_buff *skb;
+-	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+-	__le64 tstamp;
++	struct ath_vif *avp = (void *)vif->drv_priv;
++	int slot;
+ 
+-	avp = (void *)vif->drv_priv;
++	avp->av_bcbuf = list_first_entry(&sc->beacon.bbuf, struct ath_buf, list);
++	list_del(&avp->av_bcbuf->list);
+ 
+-	/* Allocate a beacon descriptor if we haven't done so. */
+-	if (!avp->av_bcbuf) {
+-		/* Allocate beacon state for hostap/ibss.  We know
+-		 * a buffer is available. */
+-		avp->av_bcbuf = list_first_entry(&sc->beacon.bbuf,
+-						 struct ath_buf, list);
+-		list_del(&avp->av_bcbuf->list);
+-
+-		if (ath9k_uses_beacons(vif->type)) {
+-			int slot;
+-			/*
+-			 * Assign the vif to a beacon xmit slot. As
+-			 * above, this cannot fail to find one.
+-			 */
+-			avp->av_bslot = 0;
+-			for (slot = 0; slot < ATH_BCBUF; slot++)
+-				if (sc->beacon.bslot[slot] == NULL) {
+-					avp->av_bslot = slot;
+-					avp->is_bslot_active = false;
+-
+-					/* NB: keep looking for a double slot */
+-					if (slot == 0 || !sc->beacon.bslot[slot-1])
+-						break;
+-				}
+-			BUG_ON(sc->beacon.bslot[avp->av_bslot] != NULL);
+-			sc->beacon.bslot[avp->av_bslot] = vif;
+-			sc->nbcnvifs++;
++	for (slot = 0; slot < ATH_BCBUF; slot++) {
++		if (sc->beacon.bslot[slot] == NULL) {
++			avp->av_bslot = slot;
++			break;
+ 		}
+ 	}
+ 
+-	/* release the previous beacon frame, if it already exists. */
+-	bf = avp->av_bcbuf;
+-	if (bf->bf_mpdu != NULL) {
+-		skb = bf->bf_mpdu;
++	sc->beacon.bslot[avp->av_bslot] = vif;
++	sc->nbcnvifs++;
++
++	ath_dbg(common, CONFIG, "Added interface at beacon slot: %d\n",
++		avp->av_bslot);
++}
++
++void ath9k_beacon_remove_slot(struct ath_softc *sc, struct ieee80211_vif *vif)
++{
++	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
++	struct ath_vif *avp = (void *)vif->drv_priv;
++	struct ath_buf *bf = avp->av_bcbuf;
++
++	ath_dbg(common, CONFIG, "Removing interface at beacon slot: %d\n",
++		avp->av_bslot);
++
++	tasklet_disable(&sc->bcon_tasklet);
++
++	if (bf && bf->bf_mpdu) {
++		struct sk_buff *skb = bf->bf_mpdu;
+ 		dma_unmap_single(sc->dev, bf->bf_buf_addr,
+ 				 skb->len, DMA_TO_DEVICE);
+ 		dev_kfree_skb_any(skb);
+@@ -274,99 +255,74 @@ int ath_beacon_alloc(struct ath_softc *s
+ 		bf->bf_buf_addr = 0;
+ 	}
+ 
+-	/* NB: the beacon data buffer must be 32-bit aligned. */
+-	skb = ieee80211_beacon_get(sc->hw, vif);
+-	if (skb == NULL)
+-		return -ENOMEM;
+-
+-	tstamp = ((struct ieee80211_mgmt *)skb->data)->u.beacon.timestamp;
+-	sc->beacon.bc_tstamp = (u32) le64_to_cpu(tstamp);
+-	/* Calculate a TSF adjustment factor required for staggered beacons. */
+-	if (avp->av_bslot > 0) {
+-		u64 tsfadjust;
+-		int intval;
++	avp->av_bcbuf = NULL;
++	sc->beacon.bslot[avp->av_bslot] = NULL;
++	sc->nbcnvifs--;
++	list_add_tail(&bf->list, &sc->beacon.bbuf);
+ 
+-		intval = cur_conf->beacon_interval ? : ATH_DEFAULT_BINTVAL;
++	tasklet_enable(&sc->bcon_tasklet);
++}
+ 
+-		/*
+-		 * Calculate the TSF offset for this beacon slot, i.e., the
+-		 * number of usecs that need to be added to the timestamp field
+-		 * in Beacon and Probe Response frames. Beacon slot 0 is
+-		 * processed at the correct offset, so it does not require TSF
+-		 * adjustment. Other slots are adjusted to get the timestamp
+-		 * close to the TBTT for the BSS.
+-		 */
+-		tsfadjust = TU_TO_USEC(intval * avp->av_bslot) / ATH_BCBUF;
+-		avp->tsf_adjust = cpu_to_le64(tsfadjust);
++static int ath9k_beacon_choose_slot(struct ath_softc *sc)
++{
++	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
++	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
++	u16 intval;
++	u32 tsftu;
++	u64 tsf;
++	int slot;
+ 
+-		ath_dbg(common, BEACON,
+-			"stagger beacons, bslot %d intval %u tsfadjust %llu\n",
+-			avp->av_bslot, intval, (unsigned long long)tsfadjust);
++	if (sc->sc_ah->opmode != NL80211_IFTYPE_AP) {
++		ath_dbg(common, BEACON, "slot 0, tsf: %llu\n",
++			ath9k_hw_gettsf64(sc->sc_ah));
++		return 0;
++	}
+ 
+-		((struct ieee80211_mgmt *)skb->data)->u.beacon.timestamp =
+-			avp->tsf_adjust;
+-	} else
+-		avp->tsf_adjust = cpu_to_le64(0);
++	intval = cur_conf->beacon_interval ? : ATH_DEFAULT_BINTVAL;
++	tsf = ath9k_hw_gettsf64(sc->sc_ah);
++	tsf += TU_TO_USEC(sc->sc_ah->config.sw_beacon_response_time);
++	tsftu = TSF_TO_TU((tsf * ATH_BCBUF) >>32, tsf * ATH_BCBUF);
++	slot = (tsftu % (intval * ATH_BCBUF)) / intval;
+ 
+-	bf->bf_mpdu = skb;
+-	bf->bf_buf_addr = dma_map_single(sc->dev, skb->data,
+-					 skb->len, DMA_TO_DEVICE);
+-	if (unlikely(dma_mapping_error(sc->dev, bf->bf_buf_addr))) {
+-		dev_kfree_skb_any(skb);
+-		bf->bf_mpdu = NULL;
+-		bf->bf_buf_addr = 0;
+-		ath_err(common, "dma_mapping_error on beacon alloc\n");
+-		return -ENOMEM;
+-	}
+-	avp->is_bslot_active = true;
++	ath_dbg(common, BEACON, "slot: %d tsf: %llu tsftu: %u\n",
++		slot, tsf, tsftu / ATH_BCBUF);
+ 
+-	return 0;
++	return slot;
+ }
+ 
+-void ath_beacon_return(struct ath_softc *sc, struct ath_vif *avp)
++void ath9k_set_tsfadjust(struct ath_softc *sc, struct ieee80211_vif *vif)
+ {
+-	if (avp->av_bcbuf != NULL) {
+-		struct ath_buf *bf;
++	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
++	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
++	struct ath_vif *avp = (void *)vif->drv_priv;
++	u64 tsfadjust;
+ 
+-		avp->is_bslot_active = false;
+-		if (avp->av_bslot != -1) {
+-			sc->beacon.bslot[avp->av_bslot] = NULL;
+-			sc->nbcnvifs--;
+-			avp->av_bslot = -1;
+-		}
++	if (avp->av_bslot == 0)
++		return;
+ 
+-		bf = avp->av_bcbuf;
+-		if (bf->bf_mpdu != NULL) {
+-			struct sk_buff *skb = bf->bf_mpdu;
+-			dma_unmap_single(sc->dev, bf->bf_buf_addr,
+-					 skb->len, DMA_TO_DEVICE);
+-			dev_kfree_skb_any(skb);
+-			bf->bf_mpdu = NULL;
+-			bf->bf_buf_addr = 0;
+-		}
+-		list_add_tail(&bf->list, &sc->beacon.bbuf);
++	tsfadjust = cur_conf->beacon_interval * avp->av_bslot / ATH_BCBUF;
++	avp->tsf_adjust = cpu_to_le64(TU_TO_USEC(tsfadjust));
+ 
+-		avp->av_bcbuf = NULL;
+-	}
++	ath_dbg(common, CONFIG, "tsfadjust is: %llu for bslot: %d\n",
++		(unsigned long long)tsfadjust, avp->av_bslot);
+ }
+ 
+-void ath_beacon_tasklet(unsigned long data)
++void ath9k_beacon_tasklet(unsigned long data)
+ {
+ 	struct ath_softc *sc = (struct ath_softc *)data;
+-	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 	struct ath_buf *bf = NULL;
+ 	struct ieee80211_vif *vif;
+ 	bool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);
+ 	int slot;
+-	u32 bfaddr, bc = 0;
+ 
+-	if (work_pending(&sc->hw_reset_work)) {
++	if (test_bit(SC_OP_HW_RESET, &sc->sc_flags)) {
+ 		ath_dbg(common, RESET,
+ 			"reset work is pending, skip beaconing now\n");
+ 		return;
+ 	}
++
+ 	/*
+ 	 * Check if the previous beacon has gone out.  If
+ 	 * not don't try to post another, skip this period
+@@ -390,55 +346,25 @@ void ath_beacon_tasklet(unsigned long da
+ 		} else if (sc->beacon.bmisscnt >= BSTUCK_THRESH) {
+ 			ath_dbg(common, BSTUCK, "beacon is officially stuck\n");
+ 			sc->beacon.bmisscnt = 0;
+-			set_bit(SC_OP_TSF_RESET, &sc->sc_flags);
+-			ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++			ath9k_queue_reset(sc, RESET_TYPE_BEACON_STUCK);
+ 		}
+ 
+ 		return;
+ 	}
+ 
+-	/*
+-	 * Generate beacon frames. we are sending frames
+-	 * staggered so calculate the slot for this frame based
+-	 * on the tsf to safeguard against missing an swba.
+-	 */
+-
+-
+-	if (ah->opmode == NL80211_IFTYPE_AP) {
+-		u16 intval;
+-		u32 tsftu;
+-		u64 tsf;
+-
+-		intval = cur_conf->beacon_interval ? : ATH_DEFAULT_BINTVAL;
+-		tsf = ath9k_hw_gettsf64(ah);
+-		tsf += TU_TO_USEC(ah->config.sw_beacon_response_time);
+-		tsftu = TSF_TO_TU((tsf * ATH_BCBUF) >>32, tsf * ATH_BCBUF);
+-		slot = (tsftu % (intval * ATH_BCBUF)) / intval;
+-		vif = sc->beacon.bslot[slot];
+-
+-		ath_dbg(common, BEACON,
+-			"slot %d [tsf %llu tsftu %u intval %u] vif %p\n",
+-			slot, tsf, tsftu / ATH_BCBUF, intval, vif);
+-	} else {
+-		slot = 0;
+-		vif = sc->beacon.bslot[slot];
+-	}
++	slot = ath9k_beacon_choose_slot(sc);
++	vif = sc->beacon.bslot[slot];
+ 
++	if (!vif || !vif->bss_conf.enable_beacon)
++		return;
+ 
+-	bfaddr = 0;
+-	if (vif) {
+-		bf = ath_beacon_generate(sc->hw, vif);
+-		if (bf != NULL) {
+-			bfaddr = bf->bf_daddr;
+-			bc = 1;
+-		}
++	bf = ath9k_beacon_generate(sc->hw, vif);
++	WARN_ON(!bf);
+ 
+-		if (sc->beacon.bmisscnt != 0) {
+-			ath_dbg(common, BSTUCK,
+-				"resume beacon xmit after %u misses\n",
+-				sc->beacon.bmisscnt);
+-			sc->beacon.bmisscnt = 0;
+-		}
++	if (sc->beacon.bmisscnt != 0) {
++		ath_dbg(common, BSTUCK, "resume beacon xmit after %u misses\n",
++			sc->beacon.bmisscnt);
++		sc->beacon.bmisscnt = 0;
+ 	}
+ 
+ 	/*
+@@ -458,39 +384,37 @@ void ath_beacon_tasklet(unsigned long da
+ 	 *     set to ATH_BCBUF so this check is a noop.
+ 	 */
+ 	if (sc->beacon.updateslot == UPDATE) {
+-		sc->beacon.updateslot = COMMIT; /* commit next beacon */
++		sc->beacon.updateslot = COMMIT;
+ 		sc->beacon.slotupdate = slot;
+-	} else if (sc->beacon.updateslot == COMMIT && sc->beacon.slotupdate == slot) {
++	} else if (sc->beacon.updateslot == COMMIT &&
++		   sc->beacon.slotupdate == slot) {
+ 		ah->slottime = sc->beacon.slottime;
+ 		ath9k_hw_init_global_settings(ah);
+ 		sc->beacon.updateslot = OK;
+ 	}
+-	if (bfaddr != 0) {
++
++	if (bf) {
++		ath9k_reset_beacon_status(sc);
++
+ 		/* NB: cabq traffic should already be queued and primed */
+-		ath9k_hw_puttxbuf(ah, sc->beacon.beaconq, bfaddr);
++		ath9k_hw_puttxbuf(ah, sc->beacon.beaconq, bf->bf_daddr);
+ 
+ 		if (!edma)
+ 			ath9k_hw_txstart(ah, sc->beacon.beaconq);
+-
+-		sc->beacon.ast_be_xmit += bc;     /* XXX per-vif? */
+ 	}
+ }
+ 
+-static void ath9k_beacon_init(struct ath_softc *sc,
+-			      u32 next_beacon,
+-			      u32 beacon_period)
++static void ath9k_beacon_init(struct ath_softc *sc, u32 nexttbtt, u32 intval)
+ {
+-	if (test_bit(SC_OP_TSF_RESET, &sc->sc_flags)) {
+-		ath9k_ps_wakeup(sc);
+-		ath9k_hw_reset_tsf(sc->sc_ah);
+-	}
+-
+-	ath9k_hw_beaconinit(sc->sc_ah, next_beacon, beacon_period);
++	struct ath_hw *ah = sc->sc_ah;
+ 
+-	if (test_bit(SC_OP_TSF_RESET, &sc->sc_flags)) {
+-		ath9k_ps_restore(sc);
+-		clear_bit(SC_OP_TSF_RESET, &sc->sc_flags);
+-	}
++	ath9k_hw_disable_interrupts(ah);
++	ath9k_hw_reset_tsf(ah);
++	ath9k_beaconq_config(sc);
++	ath9k_hw_beaconinit(ah, nexttbtt, intval);
++	sc->beacon.bmisscnt = 0;
++	ath9k_hw_set_interrupts(ah);
++	ath9k_hw_enable_interrupts(ah);
+ }
+ 
+ /*
+@@ -498,32 +422,27 @@ static void ath9k_beacon_init(struct ath
+  * burst together.  For the former arrange for the SWBA to be delivered for each
+  * slot. Slots that are not occupied will generate nothing.
+  */
+-static void ath_beacon_config_ap(struct ath_softc *sc,
+-				 struct ath_beacon_config *conf)
++static void ath9k_beacon_config_ap(struct ath_softc *sc,
++				   struct ath_beacon_config *conf)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
++	struct ath_common *common = ath9k_hw_common(ah);
+ 	u32 nexttbtt, intval;
+ 
+ 	/* NB: the beacon interval is kept internally in TU's */
+ 	intval = TU_TO_USEC(conf->beacon_interval);
+-	intval /= ATH_BCBUF;    /* for staggered beacons */
++	intval /= ATH_BCBUF;
+ 	nexttbtt = intval;
+ 
+-	/*
+-	 * In AP mode we enable the beacon timers and SWBA interrupts to
+-	 * prepare beacon frames.
+-	 */
+-	ah->imask |= ATH9K_INT_SWBA;
+-	ath_beaconq_config(sc);
++	if (conf->enable_beacon)
++		ah->imask |= ATH9K_INT_SWBA;
++	else
++		ah->imask &= ~ATH9K_INT_SWBA;
+ 
+-	/* Set the computed AP beacon timers */
++	ath_dbg(common, BEACON, "AP nexttbtt: %u intval: %u conf_intval: %u\n",
++		nexttbtt, intval, conf->beacon_interval);
+ 
+-	ath9k_hw_disable_interrupts(ah);
+-	set_bit(SC_OP_TSF_RESET, &sc->sc_flags);
+ 	ath9k_beacon_init(sc, nexttbtt, intval);
+-	sc->beacon.bmisscnt = 0;
+-	ath9k_hw_set_interrupts(ah);
+-	ath9k_hw_enable_interrupts(ah);
+ }
+ 
+ /*
+@@ -534,8 +453,8 @@ static void ath_beacon_config_ap(struct 
+  * we'll receive a BMISS interrupt when we stop seeing beacons from the AP
+  * we've associated with.
+  */
+-static void ath_beacon_config_sta(struct ath_softc *sc,
+-				  struct ath_beacon_config *conf)
++static void ath9k_beacon_config_sta(struct ath_softc *sc,
++				    struct ath_beacon_config *conf)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+@@ -654,8 +573,8 @@ static void ath_beacon_config_sta(struct
+ 	ath9k_hw_enable_interrupts(ah);
+ }
+ 
+-static void ath_beacon_config_adhoc(struct ath_softc *sc,
+-				    struct ath_beacon_config *conf)
++static void ath9k_beacon_config_adhoc(struct ath_softc *sc,
++				      struct ath_beacon_config *conf)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+@@ -669,82 +588,53 @@ static void ath_beacon_config_adhoc(stru
+ 	tsf = roundup(ath9k_hw_gettsf32(ah) + TU_TO_USEC(FUDGE), intval);
+ 	nexttbtt = tsf + intval;
+ 
+-	ath_dbg(common, BEACON, "IBSS nexttbtt %u intval %u (%u)\n",
+-		nexttbtt, intval, conf->beacon_interval);
+-
+-	/*
+-	 * In IBSS mode enable the beacon timers but only enable SWBA interrupts
+-	 * if we need to manually prepare beacon frames.  Otherwise we use a
+-	 * self-linked tx descriptor and let the hardware deal with things.
+-	 */
+-	ah->imask |= ATH9K_INT_SWBA;
+-
+-	ath_beaconq_config(sc);
++	if (conf->enable_beacon)
++		ah->imask |= ATH9K_INT_SWBA;
++	else
++		ah->imask &= ~ATH9K_INT_SWBA;
+ 
+-	/* Set the computed ADHOC beacon timers */
++	ath_dbg(common, BEACON, "IBSS nexttbtt: %u intval: %u conf_intval: %u\n",
++		nexttbtt, intval, conf->beacon_interval);
+ 
+-	ath9k_hw_disable_interrupts(ah);
+ 	ath9k_beacon_init(sc, nexttbtt, intval);
+-	sc->beacon.bmisscnt = 0;
+-
+-	ath9k_hw_set_interrupts(ah);
+-	ath9k_hw_enable_interrupts(ah);
+ }
+ 
+-static bool ath9k_allow_beacon_config(struct ath_softc *sc,
+-				      struct ieee80211_vif *vif)
++bool ath9k_allow_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif)
+ {
+-	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+-	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+ 	struct ath_vif *avp = (void *)vif->drv_priv;
+ 
+-	/*
+-	 * Can not have different beacon interval on multiple
+-	 * AP interface case
+-	 */
+-	if ((sc->sc_ah->opmode == NL80211_IFTYPE_AP) &&
+-	    (sc->nbcnvifs > 1) &&
+-	    (vif->type == NL80211_IFTYPE_AP) &&
+-	    (cur_conf->beacon_interval != bss_conf->beacon_int)) {
+-		ath_dbg(common, CONFIG,
+-			"Changing beacon interval of multiple AP interfaces !\n");
+-		return false;
+-	}
+-	/*
+-	 * Can not configure station vif's beacon config
+-	 * while on AP opmode
+-	 */
+-	if ((sc->sc_ah->opmode == NL80211_IFTYPE_AP) &&
+-	    (vif->type != NL80211_IFTYPE_AP)) {
+-		ath_dbg(common, CONFIG,
+-			"STA vif's beacon not allowed on AP mode\n");
+-		return false;
++	if (sc->sc_ah->opmode == NL80211_IFTYPE_AP) {
++		if ((vif->type != NL80211_IFTYPE_AP) ||
++		    (sc->nbcnvifs > 1)) {
++			ath_dbg(common, CONFIG,
++				"An AP interface is already present !\n");
++			return false;
++		}
+ 	}
+-	/*
+-	 * Do not allow beacon config if HW was already configured
+-	 * with another STA vif
+-	 */
+-	if ((sc->sc_ah->opmode == NL80211_IFTYPE_STATION) &&
+-	    (vif->type == NL80211_IFTYPE_STATION) &&
+-	    test_bit(SC_OP_BEACONS, &sc->sc_flags) &&
+-	    !avp->primary_sta_vif) {
+-		ath_dbg(common, CONFIG,
+-			"Beacon already configured for a station interface\n");
+-		return false;
++
++	if (sc->sc_ah->opmode == NL80211_IFTYPE_STATION) {
++		if ((vif->type == NL80211_IFTYPE_STATION) &&
++		    test_bit(SC_OP_BEACONS, &sc->sc_flags) &&
++		    !avp->primary_sta_vif) {
++			ath_dbg(common, CONFIG,
++				"Beacon already configured for a station interface\n");
++			return false;
++		}
+ 	}
++
+ 	return true;
+ }
+ 
+-void ath_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif)
++static void ath9k_cache_beacon_config(struct ath_softc *sc,
++				      struct ieee80211_bss_conf *bss_conf)
+ {
++	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ 	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+-	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+ 
+-	if (!ath9k_allow_beacon_config(sc, vif))
+-		return;
++	ath_dbg(common, BEACON,
++		"Caching beacon data for BSS: %pM\n", bss_conf->bssid);
+ 
+-	/* Setup the beacon configuration parameters */
+ 	cur_conf->beacon_interval = bss_conf->beacon_int;
+ 	cur_conf->dtim_period = bss_conf->dtim_period;
+ 	cur_conf->listen_interval = 1;
+@@ -769,73 +659,59 @@ void ath_beacon_config(struct ath_softc 
+ 	if (cur_conf->dtim_period == 0)
+ 		cur_conf->dtim_period = 1;
+ 
+-	ath_set_beacon(sc);
+ }
+ 
+-static bool ath_has_valid_bslot(struct ath_softc *sc)
++void ath9k_beacon_config(struct ath_softc *sc, struct ieee80211_vif *vif,
++			 u32 changed)
+ {
+-	struct ath_vif *avp;
+-	int slot;
+-	bool found = false;
++	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
++	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+ 
+-	for (slot = 0; slot < ATH_BCBUF; slot++) {
+-		if (sc->beacon.bslot[slot]) {
+-			avp = (void *)sc->beacon.bslot[slot]->drv_priv;
+-			if (avp->is_bslot_active) {
+-				found = true;
+-				break;
+-			}
++	ath9k_cache_beacon_config(sc, bss_conf);
++
++	if (sc->sc_ah->opmode == NL80211_IFTYPE_STATION) {
++		ath9k_set_beacon(sc);
++		set_bit(SC_OP_BEACONS, &sc->sc_flags);
++	} else {
++		/*
++		 * Take care of multiple interfaces when
++		 * enabling/disabling SWBA.
++		 */
++		if (changed & BSS_CHANGED_BEACON_ENABLED) {
++			if (!bss_conf->enable_beacon &&
++			    (sc->nbcnvifs <= 1))
++				cur_conf->enable_beacon = false;
++			else if (bss_conf->enable_beacon)
++				cur_conf->enable_beacon = true;
+ 		}
++
++		ath9k_set_beacon(sc);
++
++		if (cur_conf->enable_beacon)
++			set_bit(SC_OP_BEACONS, &sc->sc_flags);
++		else
++			clear_bit(SC_OP_BEACONS, &sc->sc_flags);
+ 	}
+-	return found;
+ }
+ 
+-
+-void ath_set_beacon(struct ath_softc *sc)
++void ath9k_set_beacon(struct ath_softc *sc)
+ {
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+ 	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
+ 
+ 	switch (sc->sc_ah->opmode) {
+ 	case NL80211_IFTYPE_AP:
+-		if (ath_has_valid_bslot(sc))
+-			ath_beacon_config_ap(sc, cur_conf);
++		ath9k_beacon_config_ap(sc, cur_conf);
+ 		break;
+ 	case NL80211_IFTYPE_ADHOC:
+ 	case NL80211_IFTYPE_MESH_POINT:
+-		ath_beacon_config_adhoc(sc, cur_conf);
++		ath9k_beacon_config_adhoc(sc, cur_conf);
+ 		break;
+ 	case NL80211_IFTYPE_STATION:
+-		ath_beacon_config_sta(sc, cur_conf);
++		ath9k_beacon_config_sta(sc, cur_conf);
+ 		break;
+ 	default:
+ 		ath_dbg(common, CONFIG, "Unsupported beaconing mode\n");
+ 		return;
+ 	}
+-
+-	set_bit(SC_OP_BEACONS, &sc->sc_flags);
+-}
+-
+-void ath9k_set_beaconing_status(struct ath_softc *sc, bool status)
+-{
+-	struct ath_hw *ah = sc->sc_ah;
+-
+-	if (!ath_has_valid_bslot(sc)) {
+-		clear_bit(SC_OP_BEACONS, &sc->sc_flags);
+-		return;
+-	}
+-
+-	ath9k_ps_wakeup(sc);
+-	if (status) {
+-		/* Re-enable beaconing */
+-		ah->imask |= ATH9K_INT_SWBA;
+-		ath9k_hw_set_interrupts(ah);
+-	} else {
+-		/* Disable SWBA interrupt */
+-		ah->imask &= ~ATH9K_INT_SWBA;
+-		ath9k_hw_set_interrupts(ah);
+-		tasklet_kill(&sc->bcon_tasklet);
+-		ath9k_hw_stop_dma_queue(ah, sc->beacon.beaconq);
+-	}
+-	ath9k_ps_restore(sc);
+ }
+--- a/drivers/net/wireless/ath/ath9k/calib.h
++++ b/drivers/net/wireless/ath/ath9k/calib.h
+@@ -30,10 +30,10 @@ struct ar5416IniArray {
+ 	u32 ia_columns;
+ };
+ 
+-#define INIT_INI_ARRAY(iniarray, array, rows, columns) do {	\
++#define INIT_INI_ARRAY(iniarray, array) do {	\
+ 		(iniarray)->ia_array = (u32 *)(array);		\
+-		(iniarray)->ia_rows = (rows);			\
+-		(iniarray)->ia_columns = (columns);		\
++		(iniarray)->ia_rows = ARRAY_SIZE(array);	\
++		(iniarray)->ia_columns = ARRAY_SIZE(array[0]);	\
+ 	} while (0)
+ 
+ #define INI_RA(iniarray, row, column) \
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -206,10 +206,9 @@ static ssize_t write_file_disable_ani(st
+ 
+ 	if (disable_ani) {
+ 		clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-		del_timer_sync(&common->ani.timer);
++		ath_stop_ani(sc);
+ 	} else {
+-		set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-		ath_start_ani(common);
++		ath_check_ani(sc);
+ 	}
+ 
+ 	return count;
+@@ -1556,6 +1555,14 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 			    &fops_interrupt);
+ 	debugfs_create_file("xmit", S_IRUSR, sc->debug.debugfs_phy, sc,
+ 			    &fops_xmit);
++	debugfs_create_u32("qlen_bk", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			   &sc->tx.txq_max_pending[WME_AC_BK]);
++	debugfs_create_u32("qlen_be", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			   &sc->tx.txq_max_pending[WME_AC_BE]);
++	debugfs_create_u32("qlen_vi", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			   &sc->tx.txq_max_pending[WME_AC_VI]);
++	debugfs_create_u32("qlen_vo", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			   &sc->tx.txq_max_pending[WME_AC_VO]);
+ 	debugfs_create_file("stations", S_IRUSR, sc->debug.debugfs_phy, sc,
+ 			    &fops_stations);
+ 	debugfs_create_file("misc", S_IRUSR, sc->debug.debugfs_phy, sc,
+--- a/drivers/net/wireless/ath/ath9k/debug.h
++++ b/drivers/net/wireless/ath/ath9k/debug.h
+@@ -32,6 +32,19 @@ struct ath_buf;
+ #define RESET_STAT_INC(sc, type) do { } while (0)
+ #endif
+ 
++enum ath_reset_type {
++	RESET_TYPE_BB_HANG,
++	RESET_TYPE_BB_WATCHDOG,
++	RESET_TYPE_FATAL_INT,
++	RESET_TYPE_TX_ERROR,
++	RESET_TYPE_TX_HANG,
++	RESET_TYPE_PLL_HANG,
++	RESET_TYPE_MAC_HANG,
++	RESET_TYPE_BEACON_STUCK,
++	RESET_TYPE_MCI,
++	__RESET_TYPE_MAX
++};
++
+ #ifdef CONFIG_ATH9K_DEBUGFS
+ 
+ /**
+@@ -209,17 +222,6 @@ struct ath_rx_stats {
+ 	u32 rx_frags;
+ };
+ 
+-enum ath_reset_type {
+-	RESET_TYPE_BB_HANG,
+-	RESET_TYPE_BB_WATCHDOG,
+-	RESET_TYPE_FATAL_INT,
+-	RESET_TYPE_TX_ERROR,
+-	RESET_TYPE_TX_HANG,
+-	RESET_TYPE_PLL_HANG,
+-	RESET_TYPE_MAC_HANG,
+-	__RESET_TYPE_MAX
+-};
+-
+ struct ath_stats {
+ 	struct ath_interrupt_stats istats;
+ 	struct ath_tx_stats txstats[ATH9K_NUM_TX_QUEUES];
+--- a/drivers/net/wireless/ath/ath9k/eeprom.h
++++ b/drivers/net/wireless/ath/ath9k/eeprom.h
+@@ -241,16 +241,12 @@ enum eeprom_param {
+ 	EEP_TEMPSENSE_SLOPE,
+ 	EEP_TEMPSENSE_SLOPE_PAL_ON,
+ 	EEP_PWR_TABLE_OFFSET,
+-	EEP_DRIVE_STRENGTH,
+-	EEP_INTERNAL_REGULATOR,
+-	EEP_SWREG,
+ 	EEP_PAPRD,
+ 	EEP_MODAL_VER,
+ 	EEP_ANT_DIV_CTL1,
+ 	EEP_CHAIN_MASK_REDUCE,
+ 	EEP_ANTENNA_GAIN_2G,
+ 	EEP_ANTENNA_GAIN_5G,
+-	EEP_QUICK_DROP
+ };
+ 
+ enum ar5416_rates {
+--- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
++++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
+@@ -1111,7 +1111,7 @@ static int ath9k_htc_add_interface(struc
+ 
+ 	if ((priv->ah->opmode == NL80211_IFTYPE_AP) &&
+ 	    !test_bit(OP_ANI_RUNNING, &priv->op_flags)) {
+-		ath9k_hw_set_tsfadjust(priv->ah, 1);
++		ath9k_hw_set_tsfadjust(priv->ah, true);
+ 		ath9k_htc_start_ani(priv);
+ 	}
+ 
+@@ -1351,7 +1351,7 @@ static int ath9k_htc_conf_tx(struct ieee
+ 	qi.tqi_aifs = params->aifs;
+ 	qi.tqi_cwmin = params->cw_min;
+ 	qi.tqi_cwmax = params->cw_max;
+-	qi.tqi_burstTime = params->txop;
++	qi.tqi_burstTime = params->txop * 32;
+ 
+ 	qnum = get_hw_qnum(queue, priv->hwq_map);
+ 
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -671,10 +671,6 @@ static int __ath9k_hw_init(struct ath_hw
+ 	if (!AR_SREV_9300_20_OR_LATER(ah))
+ 		ah->ani_function &= ~ATH9K_ANI_MRC_CCK;
+ 
+-	/* disable ANI for 9340 */
+-	if (AR_SREV_9340(ah))
+-		ah->config.enable_ani = false;
+-
+ 	ath9k_hw_init_mode_regs(ah);
+ 
+ 	if (!ah->is_pciexpress)
+@@ -2916,9 +2912,9 @@ void ath9k_hw_reset_tsf(struct ath_hw *a
+ }
+ EXPORT_SYMBOL(ath9k_hw_reset_tsf);
  
- 		iqCorrNeg = 0;
---- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
-@@ -808,7 +808,8 @@ void ath9k_htc_ani_work(struct work_stru
+-void ath9k_hw_set_tsfadjust(struct ath_hw *ah, u32 setting)
++void ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set)
+ {
+-	if (setting)
++	if (set)
+ 		ah->misc_mode |= AR_PCU_TX_ADD_TSF;
+ 	else
+ 		ah->misc_mode &= ~AR_PCU_TX_ADD_TSF;
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -994,7 +994,7 @@ u32 ath9k_hw_gettsf32(struct ath_hw *ah)
+ u64 ath9k_hw_gettsf64(struct ath_hw *ah);
+ void ath9k_hw_settsf64(struct ath_hw *ah, u64 tsf64);
+ void ath9k_hw_reset_tsf(struct ath_hw *ah);
+-void ath9k_hw_set_tsfadjust(struct ath_hw *ah, u32 setting);
++void ath9k_hw_set_tsfadjust(struct ath_hw *ah, bool set);
+ void ath9k_hw_init_global_settings(struct ath_hw *ah);
+ u32 ar9003_get_pll_sqsum_dvc(struct ath_hw *ah);
+ void ath9k_hw_set11nmac2040(struct ath_hw *ah);
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -436,6 +436,7 @@ static int ath9k_init_queues(struct ath_
+ 	for (i = 0; i < WME_NUM_AC; i++) {
+ 		sc->tx.txq_map[i] = ath_txq_setup(sc, ATH9K_TX_QUEUE_DATA, i);
+ 		sc->tx.txq_map[i]->mac80211_qnum = i;
++		sc->tx.txq_max_pending[i] = ATH_MAX_QDEPTH;
  	}
- 
- 	/* Verify whether we must check ANI */
--	if ((timestamp - common->ani.checkani_timer) >= ATH_ANI_POLLINTERVAL) {
-+	if (ah->config.enable_ani &&
-+	    (timestamp - common->ani.checkani_timer) >= ATH_ANI_POLLINTERVAL) {
- 		aniflag = true;
- 		common->ani.checkani_timer = timestamp;
+ 	return 0;
+ }
+@@ -560,7 +561,7 @@ static int ath9k_init_softc(u16 devid, s
+ 	spin_lock_init(&sc->debug.samp_lock);
+ #endif
+ 	tasklet_init(&sc->intr_tq, ath9k_tasklet, (unsigned long)sc);
+-	tasklet_init(&sc->bcon_tasklet, ath_beacon_tasklet,
++	tasklet_init(&sc->bcon_tasklet, ath9k_beacon_tasklet,
+ 		     (unsigned long)sc);
+ 
+ 	INIT_WORK(&sc->hw_reset_work, ath_reset_work);
+--- a/drivers/net/wireless/ath/ath9k/link.c
++++ b/drivers/net/wireless/ath/ath9k/link.c
+@@ -50,8 +50,7 @@ void ath_tx_complete_poll_work(struct wo
+ 	if (needreset) {
+ 		ath_dbg(ath9k_hw_common(sc->sc_ah), RESET,
+ 			"tx hung, resetting the chip\n");
+-		RESET_STAT_INC(sc, RESET_TYPE_TX_HANG);
+-		ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++		ath9k_queue_reset(sc, RESET_TYPE_TX_HANG);
+ 		return;
  	}
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -504,7 +504,7 @@ static int ath9k_hw_post_init(struct ath
- 		return ecode;
+ 
+@@ -69,6 +68,7 @@ void ath_hw_check(struct work_struct *wo
+ 	unsigned long flags;
+ 	int busy;
+ 	u8 is_alive, nbeacon = 1;
++	enum ath_reset_type type;
+ 
+ 	ath9k_ps_wakeup(sc);
+ 	is_alive = ath9k_hw_check_alive(sc->sc_ah);
+@@ -78,7 +78,7 @@ void ath_hw_check(struct work_struct *wo
+ 	else if (!is_alive && AR_SREV_9300(sc->sc_ah)) {
+ 		ath_dbg(common, RESET,
+ 			"DCU stuck is detected. Schedule chip reset\n");
+-		RESET_STAT_INC(sc, RESET_TYPE_MAC_HANG);
++		type = RESET_TYPE_MAC_HANG;
+ 		goto sched_reset;
  	}
  
--	if (!AR_SREV_9100(ah) && !AR_SREV_9340(ah)) {
-+	if (ah->config.enable_ani) {
- 		ath9k_hw_ani_setup(ah);
- 		ath9k_hw_ani_init(ah);
+@@ -90,7 +90,7 @@ void ath_hw_check(struct work_struct *wo
+ 		busy, sc->hw_busy_count + 1);
+ 	if (busy >= 99) {
+ 		if (++sc->hw_busy_count >= 3) {
+-			RESET_STAT_INC(sc, RESET_TYPE_BB_HANG);
++			type = RESET_TYPE_BB_HANG;
+ 			goto sched_reset;
+ 		}
+ 	} else if (busy >= 0) {
+@@ -102,7 +102,7 @@ void ath_hw_check(struct work_struct *wo
+ 	goto out;
+ 
+ sched_reset:
+-	ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++	ath9k_queue_reset(sc, type);
+ out:
+ 	ath9k_ps_restore(sc);
+ }
+@@ -119,8 +119,7 @@ static bool ath_hw_pll_rx_hang_check(str
+ 		count++;
+ 		if (count == 3) {
+ 			ath_dbg(common, RESET, "PLL WAR, resetting the chip\n");
+-			RESET_STAT_INC(sc, RESET_TYPE_PLL_HANG);
+-			ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++			ath9k_queue_reset(sc, RESET_TYPE_PLL_HANG);
+ 			count = 0;
+ 			return true;
+ 		}
+@@ -432,26 +431,69 @@ set_timer:
  	}
-@@ -610,6 +610,10 @@ static int __ath9k_hw_init(struct ath_hw
- 	if (!AR_SREV_9300_20_OR_LATER(ah))
- 		ah->ani_function &= ~ATH9K_ANI_MRC_CCK;
+ }
  
-+	/* disable ANI for 9340 */
-+	if (AR_SREV_9340(ah))
-+		ah->config.enable_ani = false;
-+
- 	ath9k_hw_init_mode_regs(ah);
+-void ath_start_ani(struct ath_common *common)
++void ath_start_ani(struct ath_softc *sc)
+ {
+-	struct ath_hw *ah = common->ah;
++	struct ath_hw *ah = sc->sc_ah;
++	struct ath_common *common = ath9k_hw_common(ah);
+ 	unsigned long timestamp = jiffies_to_msecs(jiffies);
+-	struct ath_softc *sc = (struct ath_softc *) common->priv;
  
- 	if (!ah->is_pciexpress)
+-	if (!test_bit(SC_OP_ANI_RUN, &sc->sc_flags))
+-		return;
+-
+-	if (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL)
++	if (common->disable_ani ||
++	    !test_bit(SC_OP_ANI_RUN, &sc->sc_flags) ||
++	    (sc->hw->conf.flags & IEEE80211_CONF_OFFCHANNEL))
+ 		return;
+ 
+ 	common->ani.longcal_timer = timestamp;
+ 	common->ani.shortcal_timer = timestamp;
+ 	common->ani.checkani_timer = timestamp;
+ 
++	ath_dbg(common, ANI, "Starting ANI\n");
+ 	mod_timer(&common->ani.timer,
+ 		  jiffies + msecs_to_jiffies((u32)ah->config.ani_poll_interval));
+ }
+ 
++void ath_stop_ani(struct ath_softc *sc)
++{
++	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
++
++	ath_dbg(common, ANI, "Stopping ANI\n");
++	del_timer_sync(&common->ani.timer);
++}
++
++void ath_check_ani(struct ath_softc *sc)
++{
++	struct ath_hw *ah = sc->sc_ah;
++	struct ath_beacon_config *cur_conf = &sc->cur_beacon_conf;
++
++	/*
++	 * Check for the various conditions in which ANI has to
++	 * be stopped.
++	 */
++	if (ah->opmode == NL80211_IFTYPE_ADHOC) {
++		if (!cur_conf->enable_beacon)
++			goto stop_ani;
++	} else if (ah->opmode == NL80211_IFTYPE_AP) {
++		if (!cur_conf->enable_beacon) {
++			/*
++			 * Disable ANI only when there are no
++			 * associated stations.
++			 */
++			if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
++				goto stop_ani;
++		}
++	} else if (ah->opmode == NL80211_IFTYPE_STATION) {
++		if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
++			goto stop_ani;
++	}
++
++	set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
++	ath_start_ani(sc);
++	return;
++
++stop_ani:
++	clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
++	ath_stop_ani(sc);
++}
++
+ void ath_update_survey_nf(struct ath_softc *sc, int channel)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
 --- a/drivers/net/wireless/ath/ath9k/main.c
 +++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -118,7 +118,7 @@ void ath9k_ps_restore(struct ath_softc *
- 	if (--sc->ps_usecount != 0)
- 		goto unlock;
- 
--	if (sc->ps_idle)
-+	if (sc->ps_idle && (sc->ps_flags & PS_WAIT_FOR_TX_ACK))
- 		mode = ATH9K_PM_FULL_SLEEP;
- 	else if (sc->ps_enabled &&
- 		 !(sc->ps_flags & (PS_WAIT_FOR_BEACON |
-@@ -286,7 +286,7 @@ static bool ath_complete_reset(struct at
- 			ath_start_ani(common);
- 	}
- 
--	if (ath9k_hw_ops(ah)->antdiv_comb_conf_get && sc->ant_rx != 3) {
-+	if ((ah->caps.hw_caps & ATH9K_HW_CAP_ANT_DIV_COMB) && sc->ant_rx != 3) {
- 		struct ath_hw_antcomb_conf div_ant_conf;
- 		u8 lna_conf;
- 
-@@ -332,7 +332,8 @@ static int ath_reset_internal(struct ath
- 		hchan = ah->curchan;
- 	}
- 
--	if (fastcc && !ath9k_hw_check_alive(ah))
-+	if (fastcc && (ah->chip_fullsleep ||
-+	    !ath9k_hw_check_alive(ah)))
- 		fastcc = false;
- 
- 	if (!ath_prepare_reset(sc, retry_tx, flush))
-@@ -561,7 +562,6 @@ void ath_ani_calibrate(unsigned long dat
- 	/* Long calibration runs independently of short calibration. */
- 	if ((timestamp - common->ani.longcal_timer) >= long_cal_interval) {
- 		longcal = true;
--		ath_dbg(common, ATH_DBG_ANI, "longcal @%lu\n", jiffies);
- 		common->ani.longcal_timer = timestamp;
- 	}
- 
-@@ -569,8 +569,6 @@ void ath_ani_calibrate(unsigned long dat
- 	if (!common->ani.caldone) {
- 		if ((timestamp - common->ani.shortcal_timer) >= short_cal_interval) {
- 			shortcal = true;
--			ath_dbg(common, ATH_DBG_ANI,
--				"shortcal @%lu\n", jiffies);
- 			common->ani.shortcal_timer = timestamp;
- 			common->ani.resetcal_timer = timestamp;
- 		}
-@@ -584,8 +582,9 @@ void ath_ani_calibrate(unsigned long dat
+@@ -167,8 +167,6 @@ static void ath_cancel_work(struct ath_s
+ 
+ static void ath_restart_work(struct ath_softc *sc)
+ {
+-	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+-
+ 	ieee80211_queue_delayed_work(sc->hw, &sc->tx_complete_work, 0);
+ 
+ 	if (AR_SREV_9340(sc->sc_ah) || AR_SREV_9485(sc->sc_ah) ||
+@@ -177,21 +175,18 @@ static void ath_restart_work(struct ath_
+ 				     msecs_to_jiffies(ATH_PLL_WORK_INTERVAL));
+ 
+ 	ath_start_rx_poll(sc, 3);
+-
+-	if (!common->disable_ani)
+-		ath_start_ani(common);
++	ath_start_ani(sc);
+ }
+ 
+ static bool ath_prepare_reset(struct ath_softc *sc, bool retry_tx, bool flush)
+ {
+ 	struct ath_hw *ah = sc->sc_ah;
+-	struct ath_common *common = ath9k_hw_common(ah);
+ 	bool ret = true;
+ 
+ 	ieee80211_stop_queues(sc->hw);
+ 
+ 	sc->hw_busy_count = 0;
+-	del_timer_sync(&common->ani.timer);
++	ath_stop_ani(sc);
+ 	del_timer_sync(&sc->rx_poll_timer);
+ 
+ 	ath9k_debug_samp_bb_mac(sc);
+@@ -236,7 +231,7 @@ static bool ath_complete_reset(struct at
+ 		if (!test_bit(SC_OP_BEACONS, &sc->sc_flags))
+ 			goto work;
+ 
+-		ath_set_beacon(sc);
++		ath9k_set_beacon(sc);
+ 
+ 		if (ah->opmode == NL80211_IFTYPE_STATION &&
+ 		    test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
+@@ -365,6 +360,7 @@ void ath9k_tasklet(unsigned long data)
+ 	struct ath_softc *sc = (struct ath_softc *)data;
+ 	struct ath_hw *ah = sc->sc_ah;
+ 	struct ath_common *common = ath9k_hw_common(ah);
++	enum ath_reset_type type;
+ 	unsigned long flags;
+ 	u32 status = sc->intrstatus;
+ 	u32 rxmask;
+@@ -374,18 +370,13 @@ void ath9k_tasklet(unsigned long data)
+ 
+ 	if ((status & ATH9K_INT_FATAL) ||
+ 	    (status & ATH9K_INT_BB_WATCHDOG)) {
+-#ifdef CONFIG_ATH9K_DEBUGFS
+-		enum ath_reset_type type;
+ 
+ 		if (status & ATH9K_INT_FATAL)
+ 			type = RESET_TYPE_FATAL_INT;
+ 		else
+ 			type = RESET_TYPE_BB_WATCHDOG;
+ 
+-		RESET_STAT_INC(sc, type);
+-#endif
+-		set_bit(SC_OP_HW_RESET, &sc->sc_flags);
+-		ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++		ath9k_queue_reset(sc, type);
+ 		goto out;
  	}
  
- 	/* Verify whether we must check ANI */
--	if ((timestamp - common->ani.checkani_timer) >=
--	     ah->config.ani_poll_interval) {
-+	if (sc->sc_ah->config.enable_ani
-+	    && (timestamp - common->ani.checkani_timer) >=
-+	    ah->config.ani_poll_interval) {
- 		aniflag = true;
- 		common->ani.checkani_timer = timestamp;
- 	}
-@@ -605,6 +604,11 @@ void ath_ani_calibrate(unsigned long dat
- 						ah->rxchainmask, longcal);
- 	}
- 
-+	ath_dbg(common, ATH_DBG_ANI,
-+		"Calibration @%lu finished: %s %s %s, caldone: %s\n", jiffies,
-+		longcal ? "long" : "", shortcal ? "short" : "",
-+		aniflag ? "ani" : "", common->ani.caldone ? "true" : "false");
-+
- 	ath9k_ps_restore(sc);
+@@ -586,6 +577,15 @@ static int ath_reset(struct ath_softc *s
+ 	return r;
+ }
  
- set_timer:
-@@ -886,82 +890,6 @@ chip_reset:
- #undef SCHED_INTR
++void ath9k_queue_reset(struct ath_softc *sc, enum ath_reset_type type)
++{
++#ifdef CONFIG_ATH9K_DEBUGFS
++	RESET_STAT_INC(sc, type);
++#endif
++	set_bit(SC_OP_HW_RESET, &sc->sc_flags);
++	ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++}
++
+ void ath_reset_work(struct work_struct *work)
+ {
+ 	struct ath_softc *sc = container_of(work, struct ath_softc, hw_reset_work);
+@@ -852,16 +852,6 @@ bool ath9k_uses_beacons(int type)
+ 	}
  }
  
--static void ath_radio_enable(struct ath_softc *sc, struct ieee80211_hw *hw)
+-static void ath9k_reclaim_beacon(struct ath_softc *sc,
+-				 struct ieee80211_vif *vif)
 -{
--	struct ath_hw *ah = sc->sc_ah;
--	struct ath_common *common = ath9k_hw_common(ah);
--	struct ieee80211_channel *channel = hw->conf.channel;
--	int r;
--
--	ath9k_ps_wakeup(sc);
--	spin_lock_bh(&sc->sc_pcu_lock);
--	atomic_set(&ah->intr_ref_cnt, -1);
+-	struct ath_vif *avp = (void *)vif->drv_priv;
 -
--	ath9k_hw_configpcipowersave(ah, false);
--
--	if (!ah->curchan)
--		ah->curchan = ath9k_cmn_get_curchannel(sc->hw, ah);
--
--	r = ath9k_hw_reset(ah, ah->curchan, ah->caldata, false);
--	if (r) {
--		ath_err(common,
--			"Unable to reset channel (%u MHz), reset status %d\n",
--			channel->center_freq, r);
--	}
+-	ath9k_set_beaconing_status(sc, false);
+-	ath_beacon_return(sc, avp);
+-	ath9k_set_beaconing_status(sc, true);
+-}
 -
--	ath_complete_reset(sc, true);
+ static void ath9k_vif_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
+ {
+ 	struct ath9k_vif_iter_data *iter_data = data;
+@@ -929,18 +919,14 @@ static void ath9k_calculate_summary_stat
+ 
+ 	ath9k_calculate_iter_data(hw, vif, &iter_data);
+ 
+-	/* Set BSSID mask. */
+ 	memcpy(common->bssidmask, iter_data.mask, ETH_ALEN);
+ 	ath_hw_setbssidmask(common);
+ 
+-	/* Set op-mode & TSF */
+ 	if (iter_data.naps > 0) {
+-		ath9k_hw_set_tsfadjust(ah, 1);
+-		set_bit(SC_OP_TSF_RESET, &sc->sc_flags);
++		ath9k_hw_set_tsfadjust(ah, true);
+ 		ah->opmode = NL80211_IFTYPE_AP;
+ 	} else {
+-		ath9k_hw_set_tsfadjust(ah, 0);
+-		clear_bit(SC_OP_TSF_RESET, &sc->sc_flags);
++		ath9k_hw_set_tsfadjust(ah, false);
+ 
+ 		if (iter_data.nmeshes)
+ 			ah->opmode = NL80211_IFTYPE_MESH_POINT;
+@@ -952,45 +938,14 @@ static void ath9k_calculate_summary_stat
+ 			ah->opmode = NL80211_IFTYPE_STATION;
+ 	}
+ 
+-	/*
+-	 * Enable MIB interrupts when there are hardware phy counters.
+-	 */
++	ath9k_hw_setopmode(ah);
++
+ 	if ((iter_data.nstations + iter_data.nadhocs + iter_data.nmeshes) > 0)
+ 		ah->imask |= ATH9K_INT_TSFOOR;
+ 	else
+ 		ah->imask &= ~ATH9K_INT_TSFOOR;
+ 
+ 	ath9k_hw_set_interrupts(ah);
 -
--	/* Enable LED */
--	ath9k_hw_cfg_output(ah, ah->led_pin,
--			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
--	ath9k_hw_set_gpio(ah, ah->led_pin, 0);
+-	/* Set up ANI */
+-	if (iter_data.naps > 0) {
+-		sc->sc_ah->stats.avgbrssi = ATH_RSSI_DUMMY_MARKER;
 -
--	spin_unlock_bh(&sc->sc_pcu_lock);
+-		if (!common->disable_ani) {
+-			set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-			ath_start_ani(common);
+-		}
 -
--	ath9k_ps_restore(sc);
+-	} else {
+-		clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-		del_timer_sync(&common->ani.timer);
+-	}
 -}
 -
--void ath_radio_disable(struct ath_softc *sc, struct ieee80211_hw *hw)
+-/* Called with sc->mutex held, vif counts set up properly. */
+-static void ath9k_do_vif_add_setup(struct ieee80211_hw *hw,
+-				   struct ieee80211_vif *vif)
 -{
--	struct ath_hw *ah = sc->sc_ah;
--	struct ieee80211_channel *channel = hw->conf.channel;
--	int r;
--
--	ath9k_ps_wakeup(sc);
+-	struct ath_softc *sc = hw->priv;
 -
--	ath_cancel_work(sc);
+-	ath9k_calculate_summary_state(hw, vif);
 -
--	spin_lock_bh(&sc->sc_pcu_lock);
+-	if (ath9k_uses_beacons(vif->type)) {
+-		/* Reserve a beacon slot for the vif */
+-		ath9k_set_beaconing_status(sc, false);
+-		ath_beacon_alloc(sc, vif);
+-		ath9k_set_beaconing_status(sc, true);
+-	}
+ }
+ 
+ static int ath9k_add_interface(struct ieee80211_hw *hw,
+@@ -1032,7 +987,10 @@ static int ath9k_add_interface(struct ie
+ 
+ 	sc->nvifs++;
+ 
+-	ath9k_do_vif_add_setup(hw, vif);
++	ath9k_calculate_summary_state(hw, vif);
++	if (ath9k_uses_beacons(vif->type))
++		ath9k_beacon_assign_slot(sc, vif);
++
+ out:
+ 	mutex_unlock(&sc->mutex);
+ 	ath9k_ps_restore(sc);
+@@ -1049,6 +1007,7 @@ static int ath9k_change_interface(struct
+ 	int ret = 0;
+ 
+ 	ath_dbg(common, CONFIG, "Change Interface\n");
++
+ 	mutex_lock(&sc->mutex);
+ 	ath9k_ps_wakeup(sc);
+ 
+@@ -1061,15 +1020,16 @@ static int ath9k_change_interface(struct
+ 		}
+ 	}
+ 
+-	/* Clean up old vif stuff */
+ 	if (ath9k_uses_beacons(vif->type))
+-		ath9k_reclaim_beacon(sc, vif);
++		ath9k_beacon_remove_slot(sc, vif);
+ 
+-	/* Add new settings */
+ 	vif->type = new_type;
+ 	vif->p2p = p2p;
+ 
+-	ath9k_do_vif_add_setup(hw, vif);
++	ath9k_calculate_summary_state(hw, vif);
++	if (ath9k_uses_beacons(vif->type))
++		ath9k_beacon_assign_slot(sc, vif);
++
+ out:
+ 	ath9k_ps_restore(sc);
+ 	mutex_unlock(&sc->mutex);
+@@ -1089,9 +1049,8 @@ static void ath9k_remove_interface(struc
+ 
+ 	sc->nvifs--;
+ 
+-	/* Reclaim beacon resources */
+ 	if (ath9k_uses_beacons(vif->type))
+-		ath9k_reclaim_beacon(sc, vif);
++		ath9k_beacon_remove_slot(sc, vif);
+ 
+ 	ath9k_calculate_summary_state(hw, NULL);
+ 
+@@ -1388,21 +1347,18 @@ static int ath9k_conf_tx(struct ieee8021
+ 	qi.tqi_aifs = params->aifs;
+ 	qi.tqi_cwmin = params->cw_min;
+ 	qi.tqi_cwmax = params->cw_max;
+-	qi.tqi_burstTime = params->txop;
++	qi.tqi_burstTime = params->txop * 32;
+ 
+ 	ath_dbg(common, CONFIG,
+ 		"Configure tx [queue/halq] [%d/%d], aifs: %d, cw_min: %d, cw_max: %d, txop: %d\n",
+ 		queue, txq->axq_qnum, params->aifs, params->cw_min,
+ 		params->cw_max, params->txop);
+ 
++	ath_update_max_aggr_framelen(sc, queue, qi.tqi_burstTime);
+ 	ret = ath_txq_update(sc, txq->axq_qnum, &qi);
+ 	if (ret)
+ 		ath_err(common, "TXQ Update failed\n");
+ 
+-	if (sc->sc_ah->opmode == NL80211_IFTYPE_ADHOC)
+-		if (queue == WME_AC_BE && !ret)
+-			ath_beaconq_config(sc);
 -
+ 	mutex_unlock(&sc->mutex);
+ 	ath9k_ps_restore(sc);
+ 
+@@ -1471,85 +1427,36 @@ static int ath9k_set_key(struct ieee8021
+ 
+ 	return ret;
+ }
+-static void ath9k_bss_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
++
++static void ath9k_bss_assoc_iter(void *data, u8 *mac, struct ieee80211_vif *vif)
+ {
+ 	struct ath_softc *sc = data;
+ 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+-	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+ 	struct ath_vif *avp = (void *)vif->drv_priv;
++	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+ 	unsigned long flags;
 -	/*
--	 * Keep the LED on when the radio is disabled
--	 * during idle unassociated state.
+-	 * Skip iteration if primary station vif's bss info
+-	 * was not changed
 -	 */
--	if (!sc->ps_idle) {
--		ath9k_hw_set_gpio(ah, ah->led_pin, 1);
--		ath9k_hw_cfg_gpio_input(ah, ah->led_pin);
--	}
--
--	ath_prepare_reset(sc, false, true);
++
+ 	if (test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags))
+ 		return;
+ 
+ 	if (bss_conf->assoc) {
+ 		set_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags);
+ 		avp->primary_sta_vif = true;
++
+ 		memcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);
+ 		common->curaid = bss_conf->aid;
+ 		ath9k_hw_write_associd(sc->sc_ah);
+-		ath_dbg(common, CONFIG, "Bss Info ASSOC %d, bssid: %pM\n",
+-			bss_conf->aid, common->curbssid);
+-		ath_beacon_config(sc, vif);
+-		/*
+-		 * Request a re-configuration of Beacon related timers
+-		 * on the receipt of the first Beacon frame (i.e.,
+-		 * after time sync with the AP).
+-		 */
+-		spin_lock_irqsave(&sc->sc_pm_lock, flags);
+-		sc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;
+-		spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
+ 
+-		/* Reset rssi stats */
+ 		sc->last_rssi = ATH_RSSI_DUMMY_MARKER;
+ 		sc->sc_ah->stats.avgbrssi = ATH_RSSI_DUMMY_MARKER;
+ 
+-		ath_start_rx_poll(sc, 3);
 -
--	if (!ah->curchan)
--		ah->curchan = ath9k_cmn_get_curchannel(hw, ah);
+-		if (!common->disable_ani) {
+-			set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-			ath_start_ani(common);
+-		}
 -
--	r = ath9k_hw_reset(ah, ah->curchan, ah->caldata, false);
--	if (r) {
--		ath_err(ath9k_hw_common(sc->sc_ah),
--			"Unable to reset channel (%u MHz), reset status %d\n",
--			channel->center_freq, r);
 -	}
+-}
 -
--	ath9k_hw_phy_disable(ah);
+-static void ath9k_config_bss(struct ath_softc *sc, struct ieee80211_vif *vif)
+-{
+-	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
+-	struct ieee80211_bss_conf *bss_conf = &vif->bss_conf;
+-	struct ath_vif *avp = (void *)vif->drv_priv;
 -
--	ath9k_hw_configpcipowersave(ah, true);
+-	if (sc->sc_ah->opmode != NL80211_IFTYPE_STATION)
+-		return;
 -
--	spin_unlock_bh(&sc->sc_pcu_lock);
--	ath9k_ps_restore(sc);
--}
+-	/* Reconfigure bss info */
+-	if (avp->primary_sta_vif && !bss_conf->assoc) {
+-		ath_dbg(common, CONFIG, "Bss Info DISASSOC %d, bssid %pM\n",
+-			common->curaid, common->curbssid);
+-		clear_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags);
+-		clear_bit(SC_OP_BEACONS, &sc->sc_flags);
+-		avp->primary_sta_vif = false;
+-		memset(common->curbssid, 0, ETH_ALEN);
+-		common->curaid = 0;
+-	}
 -
- static int ath_reset(struct ath_softc *sc, bool retry_tx)
- {
- 	int r;
-@@ -1097,6 +1025,9 @@ static int ath9k_start(struct ieee80211_
- 	 * and then setup of the interrupt mask.
- 	 */
- 	spin_lock_bh(&sc->sc_pcu_lock);
-+
-+	atomic_set(&ah->intr_ref_cnt, -1);
-+
- 	r = ath9k_hw_reset(ah, init_channel, ah->caldata, false);
- 	if (r) {
- 		ath_err(common,
-@@ -1138,6 +1069,18 @@ static int ath9k_start(struct ieee80211_
- 		goto mutex_unlock;
- 	}
- 
-+	if (ah->led_pin >= 0) {
-+		ath9k_hw_cfg_output(ah, ah->led_pin,
-+				    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
-+		ath9k_hw_set_gpio(ah, ah->led_pin, 0);
-+	}
-+
-+	/*
-+	 * Reset key cache to sane defaults (all entries cleared) instead of
-+	 * semi-random values after suspend/resume.
-+	 */
-+	ath9k_cmn_init_crypto(sc->sc_ah);
-+
- 	spin_unlock_bh(&sc->sc_pcu_lock);
+-	ieee80211_iterate_active_interfaces_atomic(
+-			sc->hw, ath9k_bss_iter, sc);
++		spin_lock_irqsave(&sc->sc_pm_lock, flags);
++		sc->ps_flags |= PS_BEACON_SYNC | PS_WAIT_FOR_BEACON;
++		spin_unlock_irqrestore(&sc->sc_pm_lock, flags);
  
- 	if ((ah->btcoex_hw.scheme != ATH_BTCOEX_CFG_NONE) &&
-@@ -1183,6 +1126,13 @@ static void ath9k_tx(struct ieee80211_hw
- 		}
+-	/*
+-	 * None of station vifs are associated.
+-	 * Clear bssid & aid
+-	 */
+-	if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
+-		ath9k_hw_write_associd(sc->sc_ah);
+-		clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-		del_timer_sync(&common->ani.timer);
+-		del_timer_sync(&sc->rx_poll_timer);
+-		memset(&sc->caldata, 0, sizeof(sc->caldata));
++		ath_dbg(common, CONFIG,
++			"Primary Station interface: %pM, BSSID: %pM\n",
++			vif->addr, common->curbssid);
  	}
+ }
  
-+	/*
-+	 * Cannot tx while the hardware is in full sleep, it first needs a full
-+	 * chip reset to recover from that
-+	 */
-+	if (unlikely(sc->sc_ah->power_mode == ATH9K_PM_FULL_SLEEP))
-+		goto exit;
+@@ -1558,6 +1465,11 @@ static void ath9k_bss_info_changed(struc
+ 				   struct ieee80211_bss_conf *bss_conf,
+ 				   u32 changed)
+ {
++#define CHECK_ANI				\
++	(BSS_CHANGED_ASSOC |			\
++	 BSS_CHANGED_IBSS |			\
++	 BSS_CHANGED_BEACON_ENABLED)
 +
- 	if (unlikely(sc->sc_ah->power_mode != ATH9K_PM_AWAKE)) {
- 		/*
- 		 * We are using PS-Poll and mac80211 can request TX while in
-@@ -1229,6 +1179,7 @@ static void ath9k_stop(struct ieee80211_
  	struct ath_softc *sc = hw->priv;
  	struct ath_hw *ah = sc->sc_ah;
  	struct ath_common *common = ath9k_hw_common(ah);
-+	bool prev_idle;
- 
+@@ -1568,53 +1480,43 @@ static void ath9k_bss_info_changed(struc
  	mutex_lock(&sc->mutex);
  
-@@ -1259,35 +1210,45 @@ static void ath9k_stop(struct ieee80211_
- 	 * before setting the invalid flag. */
- 	ath9k_hw_disable_interrupts(ah);
- 
--	if (!(sc->sc_flags & SC_OP_INVALID)) {
--		ath_drain_all_txq(sc, false);
--		ath_stoprecv(sc);
--		ath9k_hw_phy_disable(ah);
--	} else
--		sc->rx.rxlink = NULL;
-+	spin_unlock_bh(&sc->sc_pcu_lock);
+ 	if (changed & BSS_CHANGED_ASSOC) {
+-		ath9k_config_bss(sc, vif);
++		ath_dbg(common, CONFIG, "BSSID %pM Changed ASSOC %d\n",
++			bss_conf->bssid, bss_conf->assoc);
+ 
+-		ath_dbg(common, CONFIG, "BSSID: %pM aid: 0x%x\n",
+-			common->curbssid, common->curaid);
++		/*
++		 * Do not do anything when the opmode is not STATION.
++		 */
++		if (ah->opmode == NL80211_IFTYPE_STATION) {
++			if (avp->primary_sta_vif && !bss_conf->assoc) {
++				clear_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags);
++				clear_bit(SC_OP_BEACONS, &sc->sc_flags);
++				avp->primary_sta_vif = false;
++			}
 +
-+	/* we can now sync irq and kill any running tasklets, since we already
-+	 * disabled interrupts and not holding a spin lock */
-+	synchronize_irq(sc->irq);
-+	tasklet_kill(&sc->intr_tq);
-+	tasklet_kill(&sc->bcon_tasklet);
-+
-+	prev_idle = sc->ps_idle;
-+	sc->ps_idle = true;
-+
-+	spin_lock_bh(&sc->sc_pcu_lock);
-+
-+	if (ah->led_pin >= 0) {
-+		ath9k_hw_set_gpio(ah, ah->led_pin, 1);
-+		ath9k_hw_cfg_gpio_input(ah, ah->led_pin);
-+	}
++			ieee80211_iterate_active_interfaces_atomic(sc->hw,
++						   ath9k_bss_assoc_iter, sc);
 +
-+	ath_prepare_reset(sc, false, true);
- 
- 	if (sc->rx.frag) {
- 		dev_kfree_skb_any(sc->rx.frag);
- 		sc->rx.frag = NULL;
- 	}
- 
--	/* disable HAL and put h/w to sleep */
--	ath9k_hw_disable(ah);
-+	if (!ah->curchan)
-+		ah->curchan = ath9k_cmn_get_curchannel(hw, ah);
- 
--	spin_unlock_bh(&sc->sc_pcu_lock);
-+	ath9k_hw_reset(ah, ah->curchan, ah->caldata, false);
-+	ath9k_hw_phy_disable(ah);
- 
--	/* we can now sync irq and kill any running tasklets, since we already
--	 * disabled interrupts and not holding a spin lock */
--	synchronize_irq(sc->irq);
--	tasklet_kill(&sc->intr_tq);
--	tasklet_kill(&sc->bcon_tasklet);
-+	ath9k_hw_configpcipowersave(ah, true);
++			if (!test_bit(SC_OP_PRIM_STA_VIF, &sc->sc_flags)) {
++				memset(common->curbssid, 0, ETH_ALEN);
++				common->curaid = 0;
++				ath9k_hw_write_associd(sc->sc_ah);
++			}
++		}
+ 	}
  
--	ath9k_ps_restore(sc);
-+	spin_unlock_bh(&sc->sc_pcu_lock);
+ 	if (changed & BSS_CHANGED_IBSS) {
+-		/* There can be only one vif available */
+ 		memcpy(common->curbssid, bss_conf->bssid, ETH_ALEN);
+ 		common->curaid = bss_conf->aid;
+ 		ath9k_hw_write_associd(sc->sc_ah);
+-
+-		if (bss_conf->ibss_joined) {
+-			sc->sc_ah->stats.avgbrssi = ATH_RSSI_DUMMY_MARKER;
+-
+-			if (!common->disable_ani) {
+-				set_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-				ath_start_ani(common);
+-			}
+-
+-		} else {
+-			clear_bit(SC_OP_ANI_RUN, &sc->sc_flags);
+-			del_timer_sync(&common->ani.timer);
+-			del_timer_sync(&sc->rx_poll_timer);
+-		}
+ 	}
  
--	sc->ps_idle = true;
--	ath_radio_disable(sc, hw);
-+	ath9k_ps_restore(sc);
+-	/*
+-	 * In case of AP mode, the HW TSF has to be reset
+-	 * when the beacon interval changes.
+-	 */
+-	if ((changed & BSS_CHANGED_BEACON_INT) &&
+-	    (vif->type == NL80211_IFTYPE_AP))
+-		set_bit(SC_OP_TSF_RESET, &sc->sc_flags);
+-
+-	/* Configure beaconing (AP, IBSS, MESH) */
+-	if (ath9k_uses_beacons(vif->type) &&
+-	    ((changed & BSS_CHANGED_BEACON) ||
+-	     (changed & BSS_CHANGED_BEACON_ENABLED) ||
+-	     (changed & BSS_CHANGED_BEACON_INT))) {
+-		ath9k_set_beaconing_status(sc, false);
+-		if (bss_conf->enable_beacon)
+-			ath_beacon_alloc(sc, vif);
+-		else
+-			avp->is_bslot_active = false;
+-		ath_beacon_config(sc, vif);
+-		ath9k_set_beaconing_status(sc, true);
++	if ((changed & BSS_CHANGED_BEACON) ||
++	    (changed & BSS_CHANGED_BEACON_ENABLED) ||
++	    (changed & BSS_CHANGED_BEACON_INT)) {
++		if (ah->opmode == NL80211_IFTYPE_AP)
++			ath9k_set_tsfadjust(sc, vif);
++		if (ath9k_allow_beacon_config(sc, vif))
++			ath9k_beacon_config(sc, vif, changed);
+ 	}
  
- 	sc->sc_flags |= SC_OP_INVALID;
-+	sc->ps_idle = prev_idle;
+ 	if (changed & BSS_CHANGED_ERP_SLOT) {
+@@ -1636,8 +1538,13 @@ static void ath9k_bss_info_changed(struc
+ 		}
+ 	}
  
++	if (changed & CHECK_ANI)
++		ath_check_ani(sc);
++
  	mutex_unlock(&sc->mutex);
+ 	ath9k_ps_restore(sc);
++
++#undef CHECK_ANI
+ }
  
-@@ -1627,8 +1588,9 @@ static int ath9k_config(struct ieee80211
- 	struct ath_hw *ah = sc->sc_ah;
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ieee80211_conf *conf = &hw->conf;
--	bool disable_radio = false;
-+	bool reset_channel = false;
+ static u64 ath9k_get_tsf(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+@@ -1866,10 +1773,11 @@ static int ath9k_tx_last_beacon(struct i
+ 	if (!vif)
+ 		return 0;
+ 
+-	avp = (void *)vif->drv_priv;
+-	if (!avp->is_bslot_active)
++	if (!vif->bss_conf.enable_beacon)
+ 		return 0;
  
-+	ath9k_ps_wakeup(sc);
- 	mutex_lock(&sc->mutex);
++	avp = (void *)vif->drv_priv;
++
+ 	if (!sc->beacon.tx_processed && !edma) {
+ 		tasklet_disable(&sc->bcon_tasklet);
  
- 	/*
-@@ -1639,13 +1601,14 @@ static int ath9k_config(struct ieee80211
- 	 */
- 	if (changed & IEEE80211_CONF_CHANGE_IDLE) {
- 		sc->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE);
--		if (!sc->ps_idle) {
--			ath_radio_enable(sc, hw);
--			ath_dbg(common, ATH_DBG_CONFIG,
--				"not-idle: enabling radio\n");
--		} else {
--			disable_radio = true;
--		}
-+		if (sc->ps_idle)
-+			ath_cancel_work(sc);
-+		else
-+			/*
-+			 * The chip needs a reset to properly wake up from
-+			 * full sleep
-+			 */
-+			reset_channel = ah->chip_fullsleep;
- 	}
+@@ -1923,12 +1831,29 @@ static u32 fill_chainmask(u32 cap, u32 n
+ 	return filled;
+ }
  
- 	/*
-@@ -1676,9 +1639,8 @@ static int ath9k_config(struct ieee80211
++static bool validate_antenna_mask(struct ath_hw *ah, u32 val)
++{
++	switch (val & 0x7) {
++	case 0x1:
++	case 0x3:
++	case 0x7:
++		return true;
++	case 0x2:
++		return (ah->caps.rx_chainmask == 1);
++	default:
++		return false;
++	}
++}
++
+ static int ath9k_set_antenna(struct ieee80211_hw *hw, u32 tx_ant, u32 rx_ant)
+ {
+ 	struct ath_softc *sc = hw->priv;
+ 	struct ath_hw *ah = sc->sc_ah;
+ 
+-	if (!rx_ant || !tx_ant)
++	if (ah->caps.rx_chainmask != 1)
++		rx_ant |= tx_ant;
++
++	if (!validate_antenna_mask(ah, rx_ant) || !tx_ant)
+ 		return -EINVAL;
+ 
+ 	sc->ant_rx = rx_ant;
+--- a/drivers/net/wireless/ath/ath9k/mci.c
++++ b/drivers/net/wireless/ath/ath9k/mci.c
+@@ -202,7 +202,7 @@ static void ath_mci_cal_msg(struct ath_s
+ 	case MCI_GPM_BT_CAL_REQ:
+ 		if (mci_hw->bt_state == MCI_BT_AWAKE) {
+ 			ar9003_mci_state(ah, MCI_STATE_SET_BT_CAL_START);
+-			ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
++			ath9k_queue_reset(sc, RESET_TYPE_MCI);
  		}
+ 		ath_dbg(common, MCI, "MCI State : %d\n", mci_hw->bt_state);
+ 		break;
+--- a/drivers/net/wireless/ath/ath9k/recv.c
++++ b/drivers/net/wireless/ath/ath9k/recv.c
+@@ -553,7 +553,7 @@ static void ath_rx_ps_beacon(struct ath_
+ 		sc->ps_flags &= ~PS_BEACON_SYNC;
+ 		ath_dbg(common, PS,
+ 			"Reconfigure Beacon timers based on timestamp from the AP\n");
+-		ath_set_beacon(sc);
++		ath9k_set_beacon(sc);
  	}
  
--	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
-+	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || reset_channel) {
- 		struct ieee80211_channel *curchan = hw->conf.channel;
--		struct ath9k_channel old_chan;
- 		int pos = curchan->hw_value;
- 		int old_pos = -1;
- 		unsigned long flags;
-@@ -1704,11 +1666,8 @@ static int ath9k_config(struct ieee80211
- 		 * Preserve the current channel values, before updating
- 		 * the same channel
- 		 */
--		if (old_pos == pos) {
--			memcpy(&old_chan, &sc->sc_ah->channels[pos],
--				sizeof(struct ath9k_channel));
--			ah->curchan = &old_chan;
--		}
-+		if (ah->curchan && (old_pos == pos))
-+			ath9k_hw_getnf(ah, ah->curchan);
+ 	if (ath_beacon_dtim_pending_cab(skb)) {
+@@ -1044,7 +1044,6 @@ int ath_rx_tasklet(struct ath_softc *sc,
+ 	struct ieee80211_hw *hw = sc->hw;
+ 	struct ieee80211_hdr *hdr;
+ 	int retval;
+-	bool decrypt_error = false;
+ 	struct ath_rx_status rs;
+ 	enum ath9k_rx_qtype qtype;
+ 	bool edma = !!(ah->caps.hw_caps & ATH9K_HW_CAP_EDMA);
+@@ -1066,6 +1065,7 @@ int ath_rx_tasklet(struct ath_softc *sc,
+ 	tsf_lower = tsf & 0xffffffff;
+ 
+ 	do {
++		bool decrypt_error = false;
+ 		/* If handling rx interrupt and flush is in progress => exit */
+ 		if (test_bit(SC_OP_RXFLUSH, &sc->sc_flags) && (flush == 0))
+ 			break;
+--- a/drivers/net/wireless/ath/ath9k/xmit.c
++++ b/drivers/net/wireless/ath/ath9k/xmit.c
+@@ -29,6 +29,8 @@
+ #define HT_LTF(_ns)             (4 * (_ns))
+ #define SYMBOL_TIME(_ns)        ((_ns) << 2) /* ns * 4 us */
+ #define SYMBOL_TIME_HALFGI(_ns) (((_ns) * 18 + 4) / 5)  /* ns * 3.6 us */
++#define TIME_SYMBOLS(t)         ((t) >> 2)
++#define TIME_SYMBOLS_HALFGI(t)  (((t) * 5 - 4) / 18)
+ #define NUM_SYMBOLS_PER_USEC(_usec) (_usec >> 2)
+ #define NUM_SYMBOLS_PER_USEC_HALFGI(_usec) (((_usec*5)-4)/18)
  
- 		ath9k_cmn_update_ichannel(&sc->sc_ah->channels[pos],
- 					  curchan, conf->channel_type);
-@@ -1752,18 +1711,12 @@ static int ath9k_config(struct ieee80211
- 		ath_dbg(common, ATH_DBG_CONFIG,
- 			"Set power: %d\n", conf->power_level);
- 		sc->config.txpowlimit = 2 * conf->power_level;
--		ath9k_ps_wakeup(sc);
- 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
- 				       sc->config.txpowlimit, &sc->curtxpow);
--		ath9k_ps_restore(sc);
+@@ -74,33 +76,6 @@ enum {
+ 	MCS_HT40_SGI,
+ };
+ 
+-static int ath_max_4ms_framelen[4][32] = {
+-	[MCS_HT20] = {
+-		3212,  6432,  9648,  12864,  19300,  25736,  28952,  32172,
+-		6424,  12852, 19280, 25708,  38568,  51424,  57852,  64280,
+-		9628,  19260, 28896, 38528,  57792,  65532,  65532,  65532,
+-		12828, 25656, 38488, 51320,  65532,  65532,  65532,  65532,
+-	},
+-	[MCS_HT20_SGI] = {
+-		3572,  7144,  10720,  14296,  21444,  28596,  32172,  35744,
+-		7140,  14284, 21428,  28568,  42856,  57144,  64288,  65532,
+-		10700, 21408, 32112,  42816,  64228,  65532,  65532,  65532,
+-		14256, 28516, 42780,  57040,  65532,  65532,  65532,  65532,
+-	},
+-	[MCS_HT40] = {
+-		6680,  13360,  20044,  26724,  40092,  53456,  60140,  65532,
+-		13348, 26700,  40052,  53400,  65532,  65532,  65532,  65532,
+-		20004, 40008,  60016,  65532,  65532,  65532,  65532,  65532,
+-		26644, 53292,  65532,  65532,  65532,  65532,  65532,  65532,
+-	},
+-	[MCS_HT40_SGI] = {
+-		7420,  14844,  22272,  29696,  44544,  59396,  65532,  65532,
+-		14832, 29668,  44504,  59340,  65532,  65532,  65532,  65532,
+-		22232, 44464,  65532,  65532,  65532,  65532,  65532,  65532,
+-		29616, 59232,  65532,  65532,  65532,  65532,  65532,  65532,
 -	}
+-};
 -
--	if (disable_radio) {
--		ath_dbg(common, ATH_DBG_CONFIG, "idle: disabling radio\n");
--		ath_radio_disable(sc, hw);
- 	}
+ /*********************/
+ /* Aggregation logic */
+ /*********************/
+@@ -614,10 +589,8 @@ static void ath_tx_complete_aggr(struct 
+ 
+ 	rcu_read_unlock();
+ 
+-	if (needreset) {
+-		RESET_STAT_INC(sc, RESET_TYPE_TX_ERROR);
+-		ieee80211_queue_work(sc->hw, &sc->hw_reset_work);
+-	}
++	if (needreset)
++		ath9k_queue_reset(sc, RESET_TYPE_TX_ERROR);
+ }
  
- 	mutex_unlock(&sc->mutex);
-+	ath9k_ps_restore(sc);
+ static bool ath_lookup_legacy(struct ath_buf *bf)
+@@ -650,6 +623,7 @@ static u32 ath_lookup_rate(struct ath_so
+ 	struct ieee80211_tx_rate *rates;
+ 	u32 max_4ms_framelen, frmlen;
+ 	u16 aggr_limit, bt_aggr_limit, legacy = 0;
++	int q = tid->ac->txq->mac80211_qnum;
+ 	int i;
  
- 	return 0;
+ 	skb = bf->bf_mpdu;
+@@ -658,8 +632,7 @@ static u32 ath_lookup_rate(struct ath_so
+ 
+ 	/*
+ 	 * Find the lowest frame length among the rate series that will have a
+-	 * 4ms transmit duration.
+-	 * TODO - TXOP limit needs to be considered.
++	 * 4ms (or TXOP limited) transmit duration.
+ 	 */
+ 	max_4ms_framelen = ATH_AMPDU_LIMIT_MAX;
+ 
+@@ -682,7 +655,7 @@ static u32 ath_lookup_rate(struct ath_so
+ 		if (rates[i].flags & IEEE80211_TX_RC_SHORT_GI)
+ 			modeidx++;
+ 
+-		frmlen = ath_max_4ms_framelen[modeidx][rates[i].idx];
++		frmlen = sc->tx.max_aggr_framelen[q][modeidx][rates[i].idx];
+ 		max_4ms_framelen = min(max_4ms_framelen, frmlen);
+ 	}
+ 
+@@ -929,6 +902,44 @@ static u32 ath_pkt_duration(struct ath_s
+ 	return duration;
  }
-@@ -2331,9 +2284,6 @@ static void ath9k_flush(struct ieee80211
+ 
++static int ath_max_framelen(int usec, int mcs, bool ht40, bool sgi)
++{
++	int streams = HT_RC_2_STREAMS(mcs);
++	int symbols, bits;
++	int bytes = 0;
++
++	symbols = sgi ? TIME_SYMBOLS_HALFGI(usec) : TIME_SYMBOLS(usec);
++	bits = symbols * bits_per_symbol[mcs % 8][ht40] * streams;
++	bits -= OFDM_PLCP_BITS;
++	bytes = bits / 8;
++	bytes -= L_STF + L_LTF + L_SIG + HT_SIG + HT_STF + HT_LTF(streams);
++	if (bytes > 65532)
++		bytes = 65532;
++
++	return bytes;
++}
++
++void ath_update_max_aggr_framelen(struct ath_softc *sc, int queue, int txop)
++{
++	u16 *cur_ht20, *cur_ht20_sgi, *cur_ht40, *cur_ht40_sgi;
++	int mcs;
++
++	/* 4ms is the default (and maximum) duration */
++	if (!txop || txop > 4096)
++		txop = 4096;
++
++	cur_ht20 = sc->tx.max_aggr_framelen[queue][MCS_HT20];
++	cur_ht20_sgi = sc->tx.max_aggr_framelen[queue][MCS_HT20_SGI];
++	cur_ht40 = sc->tx.max_aggr_framelen[queue][MCS_HT40];
++	cur_ht40_sgi = sc->tx.max_aggr_framelen[queue][MCS_HT40_SGI];
++	for (mcs = 0; mcs < 32; mcs++) {
++		cur_ht20[mcs] = ath_max_framelen(txop, mcs, false, false);
++		cur_ht20_sgi[mcs] = ath_max_framelen(txop, mcs, false, true);
++		cur_ht40[mcs] = ath_max_framelen(txop, mcs, true, false);
++		cur_ht40_sgi[mcs] = ath_max_framelen(txop, mcs, true, true);
++	}
++}
++
+ static void ath_buf_set_rate(struct ath_softc *sc, struct ath_buf *bf,
+ 			     struct ath_tx_info *info, int len)
+ {
+@@ -1586,7 +1597,8 @@ void ath_txq_schedule(struct ath_softc *
+ 	struct ath_atx_ac *ac, *ac_tmp, *last_ac;
+ 	struct ath_atx_tid *tid, *last_tid;
+ 
+-	if (work_pending(&sc->hw_reset_work) || list_empty(&txq->axq_acq) ||
++	if (test_bit(SC_OP_HW_RESET, &sc->sc_flags) ||
++	    list_empty(&txq->axq_acq) ||
+ 	    txq->axq_ampdu_depth >= ATH_AGGR_MIN_QDEPTH)
  		return;
- 	}
  
--	if (drop)
--		timeout = 1;
--
- 	for (j = 0; j < timeout; j++) {
- 		bool npend = false;
+@@ -1988,7 +2000,8 @@ int ath_tx_start(struct ieee80211_hw *hw
  
-@@ -2351,21 +2301,22 @@ static void ath9k_flush(struct ieee80211
+ 	ath_txq_lock(sc, txq);
+ 	if (txq == sc->tx.txq_map[q] &&
+-	    ++txq->pending_frames > ATH_MAX_QDEPTH && !txq->stopped) {
++	    ++txq->pending_frames > sc->tx.txq_max_pending[q] &&
++	    !txq->stopped) {
+ 		ieee80211_stop_queue(sc->hw, q);
+ 		txq->stopped = true;
+ 	}
+@@ -2047,7 +2060,8 @@ static void ath_tx_complete(struct ath_s
+ 		if (WARN_ON(--txq->pending_frames < 0))
+ 			txq->pending_frames = 0;
+ 
+-		if (txq->stopped && txq->pending_frames < ATH_MAX_QDEPTH) {
++		if (txq->stopped &&
++		    txq->pending_frames < sc->tx.txq_max_pending[q]) {
+ 			ieee80211_wake_queue(sc->hw, q);
+ 			txq->stopped = false;
  		}
+@@ -2191,7 +2205,7 @@ static void ath_tx_processq(struct ath_s
  
- 		if (!npend)
--		    goto out;
-+		    break;
- 	}
+ 	ath_txq_lock(sc, txq);
+ 	for (;;) {
+-		if (work_pending(&sc->hw_reset_work))
++		if (test_bit(SC_OP_HW_RESET, &sc->sc_flags))
+ 			break;
  
--	ath9k_ps_wakeup(sc);
--	spin_lock_bh(&sc->sc_pcu_lock);
--	drain_txq = ath_drain_all_txq(sc, false);
--	spin_unlock_bh(&sc->sc_pcu_lock);
-+	if (drop) {
-+		ath9k_ps_wakeup(sc);
-+		spin_lock_bh(&sc->sc_pcu_lock);
-+		drain_txq = ath_drain_all_txq(sc, false);
-+		spin_unlock_bh(&sc->sc_pcu_lock);
- 
--	if (!drain_txq)
--		ath_reset(sc, false);
-+		if (!drain_txq)
-+			ath_reset(sc, false);
+ 		if (list_empty(&txq->axq_q)) {
+@@ -2274,7 +2288,7 @@ void ath_tx_edma_tasklet(struct ath_soft
+ 	int status;
+ 
+ 	for (;;) {
+-		if (work_pending(&sc->hw_reset_work))
++		if (test_bit(SC_OP_HW_RESET, &sc->sc_flags))
+ 			break;
  
--	ath9k_ps_restore(sc);
--	ieee80211_wake_queues(hw);
-+		ath9k_ps_restore(sc);
-+		ieee80211_wake_queues(hw);
-+	}
+ 		status = ath9k_hw_txprocdesc(ah, NULL, (void *)&ts);
+--- a/drivers/net/wireless/b43/xmit.c
++++ b/drivers/net/wireless/b43/xmit.c
+@@ -663,7 +663,7 @@ void b43_rx(struct b43_wldev *dev, struc
+ 	u32 uninitialized_var(macstat);
+ 	u16 chanid;
+ 	u16 phytype;
+-	int padding;
++	int padding, rate_idx;
  
--out:
- 	ieee80211_queue_delayed_work(hw, &sc->tx_complete_work, 0);
- 	mutex_unlock(&sc->mutex);
- }
---- a/drivers/net/wireless/ath/ath9k/pci.c
-+++ b/drivers/net/wireless/ath/ath9k/pci.c
-@@ -307,12 +307,11 @@ static int ath_pci_suspend(struct device
- 	struct ieee80211_hw *hw = pci_get_drvdata(pdev);
- 	struct ath_softc *sc = hw->priv;
+ 	memset(&status, 0, sizeof(status));
  
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, 1);
--
- 	/* The device has to be moved to FULLSLEEP forcibly.
- 	 * Otherwise the chip never moved to full sleep,
- 	 * when no interface is up.
- 	 */
-+	ath9k_hw_disable(sc->sc_ah);
- 	ath9k_hw_setpower(sc->sc_ah, ATH9K_PM_FULL_SLEEP);
+@@ -766,16 +766,17 @@ void b43_rx(struct b43_wldev *dev, struc
+ 	}
  
- 	return 0;
-@@ -334,22 +333,6 @@ static int ath_pci_resume(struct device 
- 	if ((val & 0x0000ff00) != 0)
- 		pci_write_config_dword(pdev, 0x40, val & 0xffff00ff);
+ 	if (phystat0 & B43_RX_PHYST0_OFDM)
+-		status.rate_idx = b43_plcp_get_bitrate_idx_ofdm(plcp,
++		rate_idx = b43_plcp_get_bitrate_idx_ofdm(plcp,
+ 						phytype == B43_PHYTYPE_A);
+ 	else
+-		status.rate_idx = b43_plcp_get_bitrate_idx_cck(plcp);
+-	if (unlikely(status.rate_idx == -1)) {
++		rate_idx = b43_plcp_get_bitrate_idx_cck(plcp);
++	if (unlikely(rate_idx == -1)) {
+ 		/* PLCP seems to be corrupted.
+ 		 * Drop the frame, if we are not interested in corrupted frames. */
+ 		if (!(dev->wl->filter_flags & FIF_PLCPFAIL))
+ 			goto drop;
+ 	}
++	status.rate_idx = rate_idx;
+ 	status.antenna = !!(phystat0 & B43_RX_PHYST0_ANT);
  
--	ath9k_ps_wakeup(sc);
--	/* Enable LED */
--	ath9k_hw_cfg_output(sc->sc_ah, sc->sc_ah->led_pin,
--			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, 0);
--
--	  /*
--	   * Reset key cache to sane defaults (all entries cleared) instead of
--	   * semi-random values after suspend/resume.
--	   */
--	ath9k_cmn_init_crypto(sc->sc_ah);
--	ath9k_ps_restore(sc);
--
--	sc->ps_idle = true;
--	ath_radio_disable(sc, hw);
--
- 	return 0;
+ 	/*
+--- a/drivers/net/wireless/libertas/cfg.c
++++ b/drivers/net/wireless/libertas/cfg.c
+@@ -2182,13 +2182,15 @@ int lbs_reg_notifier(struct wiphy *wiphy
+ 		struct regulatory_request *request)
+ {
+ 	struct lbs_private *priv = wiphy_priv(wiphy);
+-	int ret;
++	int ret = 0;
+ 
+ 	lbs_deb_enter_args(LBS_DEB_CFG80211, "cfg80211 regulatory domain "
+ 			"callback for domain %c%c\n", request->alpha2[0],
+ 			request->alpha2[1]);
+ 
+-	ret = lbs_set_11d_domain_info(priv, request, wiphy->bands);
++	memcpy(priv->country_code, request->alpha2, sizeof(request->alpha2));
++	if (lbs_iface_active(priv))
++		ret = lbs_set_11d_domain_info(priv);
+ 
+ 	lbs_deb_leave(LBS_DEB_CFG80211);
+ 	return ret;
+--- a/drivers/net/wireless/libertas/cmd.c
++++ b/drivers/net/wireless/libertas/cmd.c
+@@ -733,15 +733,13 @@ int lbs_get_rssi(struct lbs_private *pri
+  *  to the firmware
+  *
+  *  @priv:	pointer to &struct lbs_private
+- *  @request:	cfg80211 regulatory request structure
+- *  @bands:	the device's supported bands and channels
+  *
+  *  returns:	0 on success, error code on failure
+ */
+-int lbs_set_11d_domain_info(struct lbs_private *priv,
+-			    struct regulatory_request *request,
+-			    struct ieee80211_supported_band **bands)
++int lbs_set_11d_domain_info(struct lbs_private *priv)
+ {
++	struct wiphy *wiphy = priv->wdev->wiphy;
++	struct ieee80211_supported_band **bands = wiphy->bands;
+ 	struct cmd_ds_802_11d_domain_info cmd;
+ 	struct mrvl_ie_domain_param_set *domain = &cmd.domain;
+ 	struct ieee80211_country_ie_triplet *t;
+@@ -752,21 +750,23 @@ int lbs_set_11d_domain_info(struct lbs_p
+ 	u8 first_channel = 0, next_chan = 0, max_pwr = 0;
+ 	u8 i, flag = 0;
+ 	size_t triplet_size;
+-	int ret;
++	int ret = 0;
+ 
+ 	lbs_deb_enter(LBS_DEB_11D);
++	if (!priv->country_code[0])
++		goto out;
+ 
+ 	memset(&cmd, 0, sizeof(cmd));
+ 	cmd.action = cpu_to_le16(CMD_ACT_SET);
+ 
+ 	lbs_deb_11d("Setting country code '%c%c'\n",
+-		    request->alpha2[0], request->alpha2[1]);
++		    priv->country_code[0], priv->country_code[1]);
+ 
+ 	domain->header.type = cpu_to_le16(TLV_TYPE_DOMAIN);
+ 
+ 	/* Set country code */
+-	domain->country_code[0] = request->alpha2[0];
+-	domain->country_code[1] = request->alpha2[1];
++	domain->country_code[0] = priv->country_code[0];
++	domain->country_code[1] = priv->country_code[1];
+ 	domain->country_code[2] = ' ';
+ 
+ 	/* Now set up the channel triplets; firmware is somewhat picky here
+@@ -848,6 +848,7 @@ int lbs_set_11d_domain_info(struct lbs_p
+ 
+ 	ret = lbs_cmd_with_response(priv, CMD_802_11D_DOMAIN_INFO, &cmd);
+ 
++out:
+ 	lbs_deb_leave_args(LBS_DEB_11D, "ret %d", ret);
+ 	return ret;
  }
+@@ -1019,9 +1020,9 @@ static void lbs_submit_command(struct lb
+ 	if (ret) {
+ 		netdev_info(priv->dev, "DNLD_CMD: hw_host_to_card failed: %d\n",
+ 			    ret);
+-		/* Let the timer kick in and retry, and potentially reset
+-		   the whole thing if the condition persists */
+-		timeo = HZ/4;
++		/* Reset dnld state machine, report failure */
++		priv->dnld_sent = DNLD_RES_RECEIVED;
++		lbs_complete_command(priv, cmdnode, ret);
+ 	}
  
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -1954,7 +1954,7 @@ static void ath_tx_complete(struct ath_s
- 		skb_pull(skb, padsize);
+ 	if (command == CMD_802_11_DEEP_SLEEP) {
+--- a/drivers/net/wireless/libertas/cmd.h
++++ b/drivers/net/wireless/libertas/cmd.h
+@@ -128,9 +128,7 @@ int lbs_set_monitor_mode(struct lbs_priv
+ 
+ int lbs_get_rssi(struct lbs_private *priv, s8 *snr, s8 *nf);
+ 
+-int lbs_set_11d_domain_info(struct lbs_private *priv,
+-			    struct regulatory_request *request,
+-			    struct ieee80211_supported_band **bands);
++int lbs_set_11d_domain_info(struct lbs_private *priv);
+ 
+ int lbs_get_reg(struct lbs_private *priv, u16 reg, u16 offset, u32 *value);
+ 
+--- a/drivers/net/wireless/libertas/dev.h
++++ b/drivers/net/wireless/libertas/dev.h
+@@ -49,6 +49,7 @@ struct lbs_private {
+ 	bool wiphy_registered;
+ 	struct cfg80211_scan_request *scan_req;
+ 	u8 assoc_bss[ETH_ALEN];
++	u8 country_code[IEEE80211_COUNTRY_STRING_LEN];
+ 	u8 disassoc_reason;
+ 
+ 	/* Mesh */
+--- a/drivers/net/wireless/libertas/if_usb.c
++++ b/drivers/net/wireless/libertas/if_usb.c
+@@ -311,7 +311,6 @@ static void if_usb_disconnect(struct usb
+ 	cardp->surprise_removed = 1;
+ 
+ 	if (priv) {
+-		priv->surpriseremoved = 1;
+ 		lbs_stop_card(priv);
+ 		lbs_remove_card(priv);
+ 	}
+--- a/drivers/net/wireless/libertas/main.c
++++ b/drivers/net/wireless/libertas/main.c
+@@ -154,6 +154,12 @@ int lbs_start_iface(struct lbs_private *
+ 		goto err;
  	}
  
--	if (sc->ps_flags & PS_WAIT_FOR_TX_ACK) {
-+	if ((sc->ps_flags & PS_WAIT_FOR_TX_ACK) && !txq->axq_depth) {
- 		sc->ps_flags &= ~PS_WAIT_FOR_TX_ACK;
- 		ath_dbg(common, ATH_DBG_PS,
- 			"Going back to sleep after having received TX status (0x%lx)\n",
---- a/include/linux/nl80211.h
-+++ b/include/linux/nl80211.h
-@@ -2785,9 +2785,11 @@ enum nl80211_ap_sme_features {
-  * @NL80211_FEATURE_SK_TX_STATUS: This driver supports reflecting back
-  *	TX status to the socket error queue when requested with the
-  *	socket option.
-+ * @NL80211_FEATURE_HT_IBSS: This driver supports IBSS with HT datarates.
-  */
- enum nl80211_feature_flags {
- 	NL80211_FEATURE_SK_TX_STATUS	= 1 << 0,
-+	NL80211_FEATURE_HT_IBSS		= 1 << 1,
- };
++	ret = lbs_set_11d_domain_info(priv);
++	if (ret) {
++		lbs_deb_net("set 11d domain info failed\n");
++		goto err;
++	}
++
+ 	lbs_update_channel(priv);
  
- /**
+ 	priv->iface_running = true;
 --- a/include/net/cfg80211.h
 +++ b/include/net/cfg80211.h
-@@ -1149,6 +1149,7 @@ struct cfg80211_ibss_params {
- 	u8 *ssid;
- 	u8 *bssid;
- 	struct ieee80211_channel *channel;
-+	enum nl80211_channel_type channel_type;
- 	u8 *ie;
- 	u8 ssid_len, ie_len;
- 	u16 beacon_interval;
-@@ -3270,6 +3271,16 @@ void cfg80211_report_obss_beacon(struct 
- 				 const u8 *frame, size_t len,
- 				 int freq, gfp_t gfp);
- 
-+/*
-+ * cfg80211_can_beacon_sec_chan - test if ht40 on extension channel can be used
-+ * @wiphy: the wiphy
-+ * @chan: main channel
-+ * @channel_type: HT mode
-+ */
-+int cfg80211_can_beacon_sec_chan(struct wiphy *wiphy,
-+				 struct ieee80211_channel *chan,
-+				 enum nl80211_channel_type channel_type);
-+
- /* Logging, debugging and troubleshooting/diagnostic helpers. */
+@@ -1504,8 +1504,6 @@ struct cfg80211_gtk_rekey_data {
+  *	interfaces are active this callback should reject the configuration.
+  *	If no interfaces are active or the device is down, the channel should
+  *	be stored for when a monitor interface becomes active.
+- * @set_monitor_enabled: Notify driver that there are only monitor
+- *	interfaces running.
+  *
+  * @scan: Request to do a scan. If returning zero, the scan request is given
+  *	the driver, and will be valid until passed to cfg80211_scan_done().
+@@ -1612,6 +1610,10 @@ struct cfg80211_gtk_rekey_data {
+  * @get_et_strings:  Ethtool API to get a set of strings to describe stats
+  *	and perhaps other supported types of ethtool data-sets.
+  *	See @ethtool_ops.get_strings
++ *
++ * @get_channel: Get the current operating channel for the virtual interface.
++ *	For monitor interfaces, it should return %NULL unless there's a single
++ *	current monitoring channel.
+  */
+ struct cfg80211_ops {
+ 	int	(*suspend)(struct wiphy *wiphy, struct cfg80211_wowlan *wow);
+@@ -1820,7 +1822,10 @@ struct cfg80211_ops {
+ 	void	(*get_et_strings)(struct wiphy *wiphy, struct net_device *dev,
+ 				  u32 sset, u8 *data);
+ 
+-	void (*set_monitor_enabled)(struct wiphy *wiphy, bool enabled);
++	struct ieee80211_channel *
++		(*get_channel)(struct wiphy *wiphy,
++			       struct wireless_dev *wdev,
++			       enum nl80211_channel_type *type);
+ };
  
- /* wiphy_printk helpers, similar to dev_printk */
+ /*
 --- a/net/mac80211/agg-rx.c
 +++ b/net/mac80211/agg-rx.c
-@@ -185,6 +185,10 @@ static void ieee80211_send_addba_resp(st
- 		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
- 	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
+@@ -203,6 +203,8 @@ static void ieee80211_send_addba_resp(st
  		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
-+	else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
-+		memcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);
+ 	else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
+ 		memcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);
 +	else if (sdata->vif.type == NL80211_IFTYPE_WDS)
 +		memcpy(mgmt->bssid, da, ETH_ALEN);
  
@@ -549,16 +3736,7 @@
  					  IEEE80211_STYPE_ACTION);
 --- a/net/mac80211/agg-tx.c
 +++ b/net/mac80211/agg-tx.c
-@@ -55,6 +55,8 @@
-  * @ampdu_action function will be called with the action
-  * %IEEE80211_AMPDU_TX_STOP. In this case, the call must not fail,
-  * and the driver must later call ieee80211_stop_tx_ba_cb_irqsafe().
-+ * Note that the sta can get destroyed before the BA tear down is
-+ * complete.
-  */
- 
- static void ieee80211_send_addba_request(struct ieee80211_sub_if_data *sdata,
-@@ -79,10 +81,13 @@ static void ieee80211_send_addba_request
+@@ -81,7 +81,8 @@ static void ieee80211_send_addba_request
  	memcpy(mgmt->sa, sdata->vif.addr, ETH_ALEN);
  	if (sdata->vif.type == NL80211_IFTYPE_AP ||
  	    sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||
@@ -568,186 +3746,57 @@
  		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
  	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
  		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
-+	else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
-+		memcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);
- 
- 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
- 					  IEEE80211_STYPE_ACTION);
-@@ -319,6 +324,38 @@ ieee80211_wake_queue_agg(struct ieee8021
- 	__release(agg_queue);
- }
- 
-+/*
-+ * splice packets from the STA's pending to the local pending,
-+ * requires a call to ieee80211_agg_splice_finish later
-+ */
-+static void __acquires(agg_queue)
-+ieee80211_agg_splice_packets(struct ieee80211_local *local,
-+			     struct tid_ampdu_tx *tid_tx, u16 tid)
-+{
-+	int queue = ieee80211_ac_from_tid(tid);
-+	unsigned long flags;
-+
-+	ieee80211_stop_queue_agg(local, tid);
-+
-+	if (WARN(!tid_tx, "TID %d gone but expected when splicing aggregates"
-+			  " from the pending queue\n", tid))
-+		return;
-+
-+	if (!skb_queue_empty(&tid_tx->pending)) {
-+		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
-+		/* copy over remaining packets */
-+		skb_queue_splice_tail_init(&tid_tx->pending,
-+					   &local->pending[queue]);
-+		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
-+	}
-+}
-+
-+static void __releases(agg_queue)
-+ieee80211_agg_splice_finish(struct ieee80211_local *local, u16 tid)
-+{
-+	ieee80211_wake_queue_agg(local, tid);
-+}
-+
- void ieee80211_tx_ba_session_handle_start(struct sta_info *sta, int tid)
- {
- 	struct tid_ampdu_tx *tid_tx;
-@@ -330,19 +367,17 @@ void ieee80211_tx_ba_session_handle_star
- 	tid_tx = rcu_dereference_protected_tid_tx(sta, tid);
- 
- 	/*
--	 * While we're asking the driver about the aggregation,
--	 * stop the AC queue so that we don't have to worry
--	 * about frames that came in while we were doing that,
--	 * which would require us to put them to the AC pending
--	 * afterwards which just makes the code more complex.
-+	 * Start queuing up packets for this aggregation session.
-+	 * We're going to release them once the driver is OK with
-+	 * that.
- 	 */
--	ieee80211_stop_queue_agg(local, tid);
--
- 	clear_bit(HT_AGG_STATE_WANT_START, &tid_tx->state);
- 
- 	/*
--	 * make sure no packets are being processed to get
--	 * valid starting sequence number
-+	 * Make sure no packets are being processed. This ensures that
-+	 * we have a valid starting sequence number and that in-flight
-+	 * packets have been flushed out and no packets for this TID
-+	 * will go into the driver during the ampdu_action call.
- 	 */
- 	synchronize_net();
- 
-@@ -356,10 +391,11 @@ void ieee80211_tx_ba_session_handle_star
- 					" tid %d\n", tid);
- #endif
- 		spin_lock_bh(&sta->lock);
-+		ieee80211_agg_splice_packets(local, tid_tx, tid);
- 		ieee80211_assign_tid_tx(sta, tid, NULL);
-+		ieee80211_agg_splice_finish(local, tid);
- 		spin_unlock_bh(&sta->lock);
- 
--		ieee80211_wake_queue_agg(local, tid);
- #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,40))
- 		kfree_rcu(tid_tx, rcu_head);
- #else
-@@ -368,9 +404,6 @@ void ieee80211_tx_ba_session_handle_star
- 		return;
- 	}
- 
--	/* we can take packets again now */
--	ieee80211_wake_queue_agg(local, tid);
--
- 	/* activate the timer for the recipient's addBA response */
- 	mod_timer(&tid_tx->addba_resp_timer, jiffies + ADDBA_RESP_INTERVAL);
- #ifdef CONFIG_MAC80211_HT_DEBUG
-@@ -437,7 +470,9 @@ int ieee80211_start_tx_ba_session(struct
- 	if (sdata->vif.type != NL80211_IFTYPE_STATION &&
+@@ -460,6 +461,7 @@ int ieee80211_start_tx_ba_session(struct
  	    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
  	    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
--	    sdata->vif.type != NL80211_IFTYPE_AP)
-+	    sdata->vif.type != NL80211_IFTYPE_AP &&
+ 	    sdata->vif.type != NL80211_IFTYPE_AP &&
 +	    sdata->vif.type != NL80211_IFTYPE_WDS &&
-+	    sdata->vif.type != NL80211_IFTYPE_ADHOC)
+ 	    sdata->vif.type != NL80211_IFTYPE_ADHOC)
  		return -EINVAL;
  
- 	if (test_sta_flag(sta, WLAN_STA_BLOCK_BA)) {
-@@ -448,6 +483,27 @@ int ieee80211_start_tx_ba_session(struct
- 		return -EINVAL;
- 	}
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -2982,14 +2982,14 @@ static int ieee80211_probe_client(struct
+ 	return 0;
+ }
  
-+	/*
-+	 * 802.11n-2009 11.5.1.1: If the initiating STA is an HT STA, is a
-+	 * member of an IBSS, and has no other existing Block Ack agreement
-+	 * with the recipient STA, then the initiating STA shall transmit a
-+	 * Probe Request frame to the recipient STA and shall not transmit an
-+	 * ADDBA Request frame unless it receives a Probe Response frame
-+	 * from the recipient within dot11ADDBAFailureTimeout.
-+	 *
-+	 * The probe request mechanism for ADDBA is currently not implemented,
-+	 * but we only build up Block Ack session with HT STAs. This information
-+	 * is set when we receive a bss info from a probe response or a beacon.
-+	 */
-+	if (sta->sdata->vif.type == NL80211_IFTYPE_ADHOC &&
-+	    !sta->sta.ht_cap.ht_supported) {
-+#ifdef CONFIG_MAC80211_HT_DEBUG
-+		printk(KERN_DEBUG "BA request denied - IBSS STA %pM"
-+		       "does not advertise HT support\n", pubsta->addr);
-+#endif /* CONFIG_MAC80211_HT_DEBUG */
-+		return -EINVAL;
-+	}
-+
- 	spin_lock_bh(&sta->lock);
+-static void ieee80211_set_monitor_enabled(struct wiphy *wiphy, bool enabled)
++static struct ieee80211_channel *
++ieee80211_cfg_get_channel(struct wiphy *wiphy, struct wireless_dev *wdev,
++			  enum nl80211_channel_type *type)
+ {
+ 	struct ieee80211_local *local = wiphy_priv(wiphy);
  
- 	/* we have tried too many times, receiver does not want A-MPDU */
-@@ -508,38 +564,6 @@ int ieee80211_start_tx_ba_session(struct
+-	if (enabled)
+-		WARN_ON(ieee80211_add_virtual_monitor(local));
+-	else
+-		ieee80211_del_virtual_monitor(local);
++	*type = local->_oper_channel_type;
++	return local->oper_channel;
  }
- EXPORT_SYMBOL(ieee80211_start_tx_ba_session);
  
--/*
-- * splice packets from the STA's pending to the local pending,
-- * requires a call to ieee80211_agg_splice_finish later
-- */
--static void __acquires(agg_queue)
--ieee80211_agg_splice_packets(struct ieee80211_local *local,
--			     struct tid_ampdu_tx *tid_tx, u16 tid)
--{
--	int queue = ieee80211_ac_from_tid(tid);
--	unsigned long flags;
--
--	ieee80211_stop_queue_agg(local, tid);
--
--	if (WARN(!tid_tx, "TID %d gone but expected when splicing aggregates"
--			  " from the pending queue\n", tid))
--		return;
--
--	if (!skb_queue_empty(&tid_tx->pending)) {
--		spin_lock_irqsave(&local->queue_stop_reason_lock, flags);
--		/* copy over remaining packets */
--		skb_queue_splice_tail_init(&tid_tx->pending,
--					   &local->pending[queue]);
--		spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
--	}
--}
--
--static void __releases(agg_queue)
--ieee80211_agg_splice_finish(struct ieee80211_local *local, u16 tid)
--{
--	ieee80211_wake_queue_agg(local, tid);
--}
--
- static void ieee80211_agg_tx_operational(struct ieee80211_local *local,
- 					 struct sta_info *sta, u16 tid)
- {
+ #ifdef CONFIG_PM
+@@ -3066,11 +3066,11 @@ struct cfg80211_ops mac80211_config_ops 
+ 	.tdls_mgmt = ieee80211_tdls_mgmt,
+ 	.probe_client = ieee80211_probe_client,
+ 	.set_noack_map = ieee80211_set_noack_map,
+-	.set_monitor_enabled = ieee80211_set_monitor_enabled,
+ #ifdef CONFIG_PM
+ 	.set_wakeup = ieee80211_set_wakeup,
+ #endif
+ 	.get_et_sset_count = ieee80211_get_et_sset_count,
+ 	.get_et_stats = ieee80211_get_et_stats,
+ 	.get_et_strings = ieee80211_get_et_strings,
++	.get_channel = ieee80211_cfg_get_channel,
+ };
 --- a/net/mac80211/debugfs_sta.c
 +++ b/net/mac80211/debugfs_sta.c
 @@ -63,11 +63,11 @@ static ssize_t sta_flags_read(struct fil
  	test_sta_flag(sta, WLAN_STA_##flg) ? #flg "\n" : ""
  
  	int res = scnprintf(buf, sizeof(buf),
--			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
-+			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
+-			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
++			    "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s",
  			    TEST(AUTH), TEST(ASSOC), TEST(PS_STA),
  			    TEST(PS_DRIVER), TEST(AUTHORIZED),
  			    TEST(SHORT_PREAMBLE),
@@ -755,222 +3804,41 @@
 +			    TEST(WME), TEST(CLEAR_PS_FILT),
  			    TEST(MFP), TEST(BLOCK_BA), TEST(PSPOLL),
  			    TEST(UAPSD), TEST(SP), TEST(TDLS_PEER),
- 			    TEST(TDLS_PEER_AUTH));
---- a/net/mac80211/ht.c
-+++ b/net/mac80211/ht.c
-@@ -47,7 +47,9 @@ void ieee80211_apply_htcap_overrides(str
- 	int i;
- 
- 	if (sdata->vif.type != NL80211_IFTYPE_STATION) {
--		WARN_ON_ONCE(sdata->vif.type != NL80211_IFTYPE_STATION);
-+		/* AP interfaces call this code when adding new stations,
-+		 * so just silently ignore non station interfaces.
-+		 */
- 		return;
- 	}
- 
-@@ -282,6 +284,8 @@ void ieee80211_send_delba(struct ieee802
- 		memcpy(mgmt->bssid, sdata->vif.addr, ETH_ALEN);
- 	else if (sdata->vif.type == NL80211_IFTYPE_STATION)
- 		memcpy(mgmt->bssid, sdata->u.mgd.bssid, ETH_ALEN);
-+	else if (sdata->vif.type == NL80211_IFTYPE_ADHOC)
-+		memcpy(mgmt->bssid, sdata->u.ibss.bssid, ETH_ALEN);
- 
- 	mgmt->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
- 					  IEEE80211_STYPE_ACTION);
---- a/net/mac80211/ibss.c
-+++ b/net/mac80211/ibss.c
-@@ -77,6 +77,7 @@ static void __ieee80211_sta_join_ibss(st
- 	struct cfg80211_bss *bss;
- 	u32 bss_change;
- 	u8 supp_rates[IEEE80211_MAX_SUPP_RATES];
-+	enum nl80211_channel_type channel_type;
- 
- 	lockdep_assert_held(&ifibss->mtx);
- 
-@@ -105,8 +106,16 @@ static void __ieee80211_sta_join_ibss(st
- 
- 	sdata->drop_unencrypted = capability & WLAN_CAPABILITY_PRIVACY ? 1 : 0;
- 
--	local->oper_channel = chan;
--	WARN_ON(!ieee80211_set_channel_type(local, sdata, NL80211_CHAN_NO_HT));
-+	channel_type = ifibss->channel_type;
-+	if (channel_type > NL80211_CHAN_HT20 &&
-+	    !cfg80211_can_beacon_sec_chan(local->hw.wiphy, chan, channel_type))
-+		channel_type = NL80211_CHAN_HT20;
-+	if (!ieee80211_set_channel_type(local, sdata, channel_type)) {
-+		/* can only fail due to HT40+/- mismatch */
-+		channel_type = NL80211_CHAN_HT20;
-+		WARN_ON(!ieee80211_set_channel_type(local, sdata,
-+						    NL80211_CHAN_HT20));
-+	}
- 	ieee80211_hw_config(local, IEEE80211_CONF_CHANGE_CHANNEL);
- 
- 	sband = local->hw.wiphy->bands[chan->band];
-@@ -172,6 +181,19 @@ static void __ieee80211_sta_join_ibss(st
- 		memcpy(skb_put(skb, ifibss->ie_len),
- 		       ifibss->ie, ifibss->ie_len);
- 
-+	/* add HT capability and information IEs */
-+	if (channel_type && sband->ht_cap.ht_supported) {
-+		pos = skb_put(skb, 4 +
-+				   sizeof(struct ieee80211_ht_cap) +
-+				   sizeof(struct ieee80211_ht_info));
-+		pos = ieee80211_ie_build_ht_cap(pos, &sband->ht_cap,
-+						sband->ht_cap.cap);
-+		pos = ieee80211_ie_build_ht_info(pos,
-+						 &sband->ht_cap,
-+						 chan,
-+						 channel_type);
-+	}
-+
- 	if (local->hw.queues >= 4) {
- 		pos = skb_put(skb, 9);
- 		*pos++ = WLAN_EID_VENDOR_SPECIFIC;
-@@ -195,6 +217,7 @@ static void __ieee80211_sta_join_ibss(st
- 	bss_change |= BSS_CHANGED_BEACON;
- 	bss_change |= BSS_CHANGED_BEACON_ENABLED;
- 	bss_change |= BSS_CHANGED_BASIC_RATES;
-+	bss_change |= BSS_CHANGED_HT;
- 	bss_change |= BSS_CHANGED_IBSS;
- 	sdata->vif.bss_conf.ibss_joined = true;
- 	ieee80211_bss_info_change_notify(sdata, bss_change);
-@@ -268,6 +291,8 @@ static void ieee80211_rx_bss_info(struct
- 	u64 beacon_timestamp, rx_timestamp;
- 	u32 supp_rates = 0;
- 	enum ieee80211_band band = rx_status->band;
-+	struct ieee80211_supported_band *sband = local->hw.wiphy->bands[band];
-+	bool rates_updated = false;
- 
- 	if (elems->ds_params && elems->ds_params_len == 1)
- 		freq = ieee80211_channel_to_frequency(elems->ds_params[0],
-@@ -307,7 +332,7 @@ static void ieee80211_rx_bss_info(struct
- 						prev_rates,
- 						sta->sta.supp_rates[band]);
- #endif
--					rate_control_rate_init(sta);
-+					rates_updated = true;
- 				}
- 			} else
- 				sta = ieee80211_ibss_add_sta(sdata, mgmt->bssid,
-@@ -318,6 +343,39 @@ static void ieee80211_rx_bss_info(struct
- 		if (sta && elems->wmm_info)
- 			set_sta_flag(sta, WLAN_STA_WME);
- 
-+		if (sta && elems->ht_info_elem && elems->ht_cap_elem &&
-+		    sdata->u.ibss.channel_type != NL80211_CHAN_NO_HT) {
-+			/* we both use HT */
-+			struct ieee80211_sta_ht_cap sta_ht_cap_new;
-+			enum nl80211_channel_type channel_type =
-+				ieee80211_ht_info_to_channel_type(
-+							elems->ht_info_elem);
-+
-+			ieee80211_ht_cap_ie_to_sta_ht_cap(sdata, sband,
-+							  elems->ht_cap_elem,
-+							  &sta_ht_cap_new);
-+
-+			/*
-+			 * fall back to HT20 if we don't use or use
-+			 * the other extension channel
-+			 */
-+			if (!(channel_type == NL80211_CHAN_HT40MINUS ||
-+			      channel_type == NL80211_CHAN_HT40PLUS) ||
-+			    channel_type != sdata->u.ibss.channel_type)
-+				sta_ht_cap_new.cap &=
-+					~IEEE80211_HT_CAP_SUP_WIDTH_20_40;
-+
-+			if (memcmp(&sta->sta.ht_cap, &sta_ht_cap_new,
-+				   sizeof(sta_ht_cap_new))) {
-+				memcpy(&sta->sta.ht_cap, &sta_ht_cap_new,
-+				       sizeof(sta_ht_cap_new));
-+				rates_updated = true;
-+			}
-+		}
-+
-+		if (sta && rates_updated)
-+			rate_control_rate_init(sta);
-+
- 		rcu_read_unlock();
- 	}
- 
-@@ -896,12 +954,18 @@ int ieee80211_ibss_join(struct ieee80211
- 			struct cfg80211_ibss_params *params)
- {
- 	struct sk_buff *skb;
-+	u32 changed = 0;
- 
- 	skb = dev_alloc_skb(sdata->local->hw.extra_tx_headroom +
--			    36 /* bitrates */ +
--			    34 /* SSID */ +
--			    3  /* DS params */ +
--			    4  /* IBSS params */ +
-+			    sizeof(struct ieee80211_hdr_3addr) +
-+			    12 /* struct ieee80211_mgmt.u.beacon */ +
-+			    2 + IEEE80211_MAX_SSID_LEN /* max SSID */ +
-+			    2 + 8 /* max Supported Rates */ +
-+			    3 /* max DS params */ +
-+			    4 /* IBSS params */ +
-+			    2 + (IEEE80211_MAX_SUPP_RATES - 8) +
-+			    2 + sizeof(struct ieee80211_ht_cap) +
-+			    2 + sizeof(struct ieee80211_ht_info) +
- 			    params->ie_len);
- 	if (!skb)
- 		return -ENOMEM;
-@@ -922,13 +986,15 @@ int ieee80211_ibss_join(struct ieee80211
- 	sdata->vif.bss_conf.beacon_int = params->beacon_interval;
- 
- 	sdata->u.ibss.channel = params->channel;
-+	sdata->u.ibss.channel_type = params->channel_type;
- 	sdata->u.ibss.fixed_channel = params->channel_fixed;
- 
- 	/* fix ourselves to that channel now already */
- 	if (params->channel_fixed) {
- 		sdata->local->oper_channel = params->channel;
--		WARN_ON(!ieee80211_set_channel_type(sdata->local, sdata,
--						    NL80211_CHAN_NO_HT));
-+		if (!ieee80211_set_channel_type(sdata->local, sdata,
-+					       params->channel_type))
-+			return -EINVAL;
- 	}
- 
- 	if (params->ie) {
-@@ -951,6 +1017,23 @@ int ieee80211_ibss_join(struct ieee80211
- 	ieee80211_recalc_idle(sdata->local);
- 	mutex_unlock(&sdata->local->mtx);
- 
-+	/*
-+	 * 802.11n-2009 9.13.3.1: In an IBSS, the HT Protection field is
-+	 * reserved, but an HT STA shall protect HT transmissions as though
-+	 * the HT Protection field were set to non-HT mixed mode.
-+	 *
-+	 * In an IBSS, the RIFS Mode field of the HT Operation element is
-+	 * also reserved, but an HT STA shall operate as though this field
-+	 * were set to 1.
-+	 */
-+
-+	sdata->vif.bss_conf.ht_operation_mode |=
-+		  IEEE80211_HT_OP_MODE_PROTECTION_NONHT_MIXED
-+		| IEEE80211_HT_PARAM_RIFS_MODE;
-+
-+	changed |= BSS_CHANGED_HT;
-+	ieee80211_bss_info_change_notify(sdata, changed);
-+
- 	ieee80211_queue_work(&sdata->local->hw, &sdata->work);
- 
- 	return 0;
+ 			    TEST(TDLS_PEER_AUTH), TEST(4ADDR_EVENT),
 --- a/net/mac80211/ieee80211_i.h
 +++ b/net/mac80211/ieee80211_i.h
-@@ -474,6 +474,7 @@ struct ieee80211_if_ibss {
- 	u8 ssid_len, ie_len;
- 	u8 *ie;
- 	struct ieee80211_channel *channel;
-+	enum nl80211_channel_type channel_type;
- 
- 	unsigned long ibss_join_req;
- 	/* probe response/beacon for IBSS */
+@@ -1496,10 +1496,6 @@ int ieee80211_add_srates_ie(struct ieee8
+ int ieee80211_add_ext_srates_ie(struct ieee80211_sub_if_data *sdata,
+ 				struct sk_buff *skb, bool need_basic);
+ 
+-/* virtual monitor */
+-int ieee80211_add_virtual_monitor(struct ieee80211_local *local);
+-void ieee80211_del_virtual_monitor(struct ieee80211_local *local);
+-
+ /* channel management */
+ enum ieee80211_chan_mode {
+ 	CHAN_MODE_UNDEFINED,
 --- a/net/mac80211/iface.c
 +++ b/net/mac80211/iface.c
-@@ -178,7 +178,6 @@ static int ieee80211_do_open(struct net_
+@@ -331,7 +331,7 @@ static void ieee80211_set_default_queues
+ 	sdata->vif.cab_queue = IEEE80211_INVAL_HW_QUEUE;
+ }
+ 
+-int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
++static int ieee80211_add_virtual_monitor(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 	int ret = 0;
+@@ -377,7 +377,7 @@ int ieee80211_add_virtual_monitor(struct
+ 	return ret;
+ }
+ 
+-void ieee80211_del_virtual_monitor(struct ieee80211_local *local)
++static void ieee80211_del_virtual_monitor(struct ieee80211_local *local)
+ {
+ 	struct ieee80211_sub_if_data *sdata;
+ 
+@@ -410,7 +410,6 @@ static int ieee80211_do_open(struct net_
  {
  	struct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);
  	struct ieee80211_local *local = sdata->local;
@@ -978,7 +3846,29 @@
  	u32 changed = 0;
  	int res;
  	u32 hw_reconf_flags = 0;
-@@ -309,27 +308,6 @@ static int ieee80211_do_open(struct net_
+@@ -497,6 +496,12 @@ static int ieee80211_do_open(struct net_
+ 			break;
+ 		}
+ 
++		if (local->monitors == 0 && local->open_count == 0) {
++			res = ieee80211_add_virtual_monitor(local);
++			if (res)
++				goto err_stop;
++		}
++
+ 		/* must be before the call to ieee80211_configure_filter */
+ 		local->monitors++;
+ 		if (local->monitors == 1) {
+@@ -511,6 +516,8 @@ static int ieee80211_do_open(struct net_
+ 		break;
+ 	default:
+ 		if (coming_up) {
++			ieee80211_del_virtual_monitor(local);
++
+ 			res = drv_add_interface(local, sdata);
+ 			if (res)
+ 				goto err_stop;
+@@ -548,28 +555,6 @@ static int ieee80211_do_open(struct net_
  
  	set_bit(SDATA_STATE_RUNNING, &sdata->state);
  
@@ -991,8 +3881,9 @@
 -			goto err_del_interface;
 -		}
 -
--		/* no atomic bitop required since STA is not live yet */
--		set_sta_flag(sta, WLAN_STA_AUTHORIZED);
+-		sta_info_pre_move_state(sta, IEEE80211_STA_AUTH);
+-		sta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);
+-		sta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);
 -
 -		res = sta_info_insert(sta);
 -		if (res) {
@@ -1006,17 +3897,25 @@
  	/*
  	 * set_multicast_list will be invoked by the networking core
  	 * which will check whether any increments here were done in
-@@ -356,8 +334,7 @@ static int ieee80211_do_open(struct net_
- 	netif_tx_start_all_queues(dev);
+@@ -750,6 +735,7 @@ static void ieee80211_do_stop(struct iee
+ 		if (local->monitors == 0) {
+ 			local->hw.conf.flags &= ~IEEE80211_CONF_MONITOR;
+ 			hw_reconf_flags |= IEEE80211_CONF_CHANGE_MONITOR;
++			ieee80211_del_virtual_monitor(local);
+ 		}
  
- 	return 0;
-- err_del_interface:
--	drv_remove_interface(local, sdata);
+ 		ieee80211_adjust_monitor_flags(sdata, -1);
+@@ -823,6 +809,9 @@ static void ieee80211_do_stop(struct iee
+ 		}
+ 	}
+ 	spin_unlock_irqrestore(&local->queue_stop_reason_lock, flags);
 +
-  err_stop:
- 	if (!local->open_count)
- 		drv_stop(local);
-@@ -719,6 +696,70 @@ static void ieee80211_if_setup(struct ne
++	if (local->monitors == local->open_count && local->monitors > 0)
++		ieee80211_add_virtual_monitor(local);
+ }
+ 
+ static int ieee80211_stop(struct net_device *dev)
+@@ -959,6 +948,72 @@ static void ieee80211_if_setup(struct ne
  	dev->destructor = free_netdev;
  }
  
@@ -1049,7 +3948,7 @@
 +	ieee802_11_parse_elems(mgmt->u.probe_resp.variable,
 +			       skb->len - baselen, &elems);
 +
-+	rates = ieee80211_sta_get_rates(local, &elems, band);
++	rates = ieee80211_sta_get_rates(local, &elems, band, NULL);
 +
 +	rcu_read_lock();
 +
@@ -1076,7 +3975,9 @@
 +		set_sta_flag(sta, WLAN_STA_WME);
 +
 +	if (new) {
-+		set_sta_flag(sta, WLAN_STA_AUTHORIZED);
++		sta_info_pre_move_state(sta, IEEE80211_STA_AUTH);
++		sta_info_pre_move_state(sta, IEEE80211_STA_ASSOC);
++		sta_info_pre_move_state(sta, IEEE80211_STA_AUTHORIZED);
 +		rate_control_rate_init(sta);
 +		sta_info_insert_rcu(sta);
 +	}
@@ -1087,7 +3988,7 @@
  static void ieee80211_iface_work(struct work_struct *work)
  {
  	struct ieee80211_sub_if_data *sdata =
-@@ -823,6 +864,9 @@ static void ieee80211_iface_work(struct 
+@@ -1063,6 +1118,9 @@ static void ieee80211_iface_work(struct 
  				break;
  			ieee80211_mesh_rx_queued_mgmt(sdata, skb);
  			break;
@@ -1097,32 +3998,48 @@
  		default:
  			WARN(1, "frame for unexpected interface type");
  			break;
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -574,7 +574,8 @@ struct ieee80211_hw *ieee80211_alloc_hw(
- 			WIPHY_FLAG_OFFCHAN_TX |
- 			WIPHY_FLAG_HAS_REMAIN_ON_CHANNEL;
- 
--	wiphy->features = NL80211_FEATURE_SK_TX_STATUS;
-+	wiphy->features = NL80211_FEATURE_SK_TX_STATUS |
-+			  NL80211_FEATURE_HT_IBSS;
+--- a/net/mac80211/offchannel.c
++++ b/net/mac80211/offchannel.c
+@@ -324,6 +324,7 @@ void ieee80211_sw_roc_work(struct work_s
+ 		container_of(work, struct ieee80211_roc_work, work.work);
+ 	struct ieee80211_sub_if_data *sdata = roc->sdata;
+ 	struct ieee80211_local *local = sdata->local;
++	bool started;
+ 
+ 	mutex_lock(&local->mtx);
+ 
+@@ -366,9 +367,10 @@ void ieee80211_sw_roc_work(struct work_s
+ 		/* finish this ROC */
+  finish:
+ 		list_del(&roc->list);
++		started = roc->started;
+ 		ieee80211_roc_notify_destroy(roc);
+ 
+-		if (roc->started) {
++		if (started) {
+ 			drv_flush(local, false);
+ 
+ 			local->tmp_channel = NULL;
+@@ -379,7 +381,7 @@ void ieee80211_sw_roc_work(struct work_s
+ 
+ 		ieee80211_recalc_idle(local);
+ 
+-		if (roc->started)
++		if (started)
+ 			ieee80211_start_next_roc(local);
+ 	}
  
- 	if (!ops->set_key)
- 		wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
 --- a/net/mac80211/rx.c
 +++ b/net/mac80211/rx.c
-@@ -2237,7 +2237,9 @@ ieee80211_rx_h_action(struct ieee80211_r
- 		if (sdata->vif.type != NL80211_IFTYPE_STATION &&
+@@ -2239,6 +2239,7 @@ ieee80211_rx_h_action(struct ieee80211_r
  		    sdata->vif.type != NL80211_IFTYPE_MESH_POINT &&
  		    sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&
--		    sdata->vif.type != NL80211_IFTYPE_AP)
-+		    sdata->vif.type != NL80211_IFTYPE_AP &&
+ 		    sdata->vif.type != NL80211_IFTYPE_AP &&
 +		    sdata->vif.type != NL80211_IFTYPE_WDS &&
-+		    sdata->vif.type != NL80211_IFTYPE_ADHOC)
+ 		    sdata->vif.type != NL80211_IFTYPE_ADHOC)
  			break;
  
- 		/* verify action_code is present */
-@@ -2452,13 +2454,14 @@ ieee80211_rx_h_mgmt(struct ieee80211_rx_
+@@ -2456,14 +2457,15 @@ ieee80211_rx_h_mgmt(struct ieee80211_rx_
  
  	if (!ieee80211_vif_is_mesh(&sdata->vif) &&
  	    sdata->vif.type != NL80211_IFTYPE_ADHOC &&
@@ -1132,39 +4049,21 @@
  		return RX_DROP_MONITOR;
  
  	switch (stype) {
+ 	case cpu_to_le16(IEEE80211_STYPE_AUTH):
  	case cpu_to_le16(IEEE80211_STYPE_BEACON):
  	case cpu_to_le16(IEEE80211_STYPE_PROBE_RESP):
 -		/* process for all: mesh, mlme, ibss */
 +		/* process for all: mesh, mlme, ibss, wds */
  		break;
- 	case cpu_to_le16(IEEE80211_STYPE_DEAUTH):
- 	case cpu_to_le16(IEEE80211_STYPE_DISASSOC):
-@@ -2796,19 +2799,32 @@ static int prepare_for_handlers(struct i
- 				return 0;
- 		} else if (!ieee80211_bssid_match(bssid,
- 					sdata->vif.addr)) {
-+			/*
-+			 * Accept public action frames even when the
-+			 * BSSID doesn't match, this is used for P2P
-+			 * and location updates. Note that mac80211
-+			 * itself never looks at these frames.
-+			 */
- 			if (!(status->rx_flags & IEEE80211_RX_IN_SCAN) &&
--			    !ieee80211_is_beacon(hdr->frame_control) &&
--			    !(ieee80211_is_action(hdr->frame_control) &&
--			      sdata->vif.p2p))
-+			    ieee80211_is_public_action(hdr, skb->len))
-+				return 1;
-+			if (!(status->rx_flags & IEEE80211_RX_IN_SCAN) &&
-+			    !ieee80211_is_beacon(hdr->frame_control))
- 				return 0;
- 			status->rx_flags &= ~IEEE80211_RX_RA_MATCH;
+ 	case cpu_to_le16(IEEE80211_STYPE_ASSOC_RESP):
+ 	case cpu_to_le16(IEEE80211_STYPE_REASSOC_RESP):
+@@ -2788,10 +2790,16 @@ static int prepare_for_handlers(struct i
  		}
  		break;
  	case NL80211_IFTYPE_WDS:
 -		if (bssid || !ieee80211_is_data(hdr->frame_control))
 -			return 0;
- 		if (compare_ether_addr(sdata->u.wds.remote_addr, hdr->addr2))
+ 		if (!ether_addr_equal(sdata->u.wds.remote_addr, hdr->addr2))
  			return 0;
 +
 +		if (ieee80211_is_data(hdr->frame_control) ||
@@ -1179,7 +4078,7 @@
  		/* should never get here */
 --- a/net/mac80211/sta_info.h
 +++ b/net/mac80211/sta_info.h
-@@ -31,7 +31,6 @@
+@@ -32,7 +32,6 @@
   * @WLAN_STA_SHORT_PREAMBLE: Station is capable of receiving short-preamble
   *	frames.
   * @WLAN_STA_WME: Station is a QoS-STA.
@@ -1187,7 +4086,7 @@
   * @WLAN_STA_CLEAR_PS_FILT: Clear PS filter in hardware (using the
   *	IEEE80211_TX_CTL_CLEAR_PS_FILT control flag) when the next
   *	frame to this station is transmitted.
-@@ -60,7 +59,6 @@ enum ieee80211_sta_info_flags {
+@@ -64,7 +63,6 @@ enum ieee80211_sta_info_flags {
  	WLAN_STA_AUTHORIZED,
  	WLAN_STA_SHORT_PREAMBLE,
  	WLAN_STA_WME,
@@ -1195,197 +4094,341 @@
  	WLAN_STA_CLEAR_PS_FILT,
  	WLAN_STA_MFP,
  	WLAN_STA_BLOCK_BA,
---- a/net/mac80211/util.c
-+++ b/net/mac80211/util.c
-@@ -1612,6 +1612,11 @@ u8 *ieee80211_ie_build_ht_info(u8 *pos,
- 	}
- 	if (ht_cap->cap & IEEE80211_HT_CAP_SUP_WIDTH_20_40)
- 		ht_info->ht_param |= IEEE80211_HT_PARAM_CHAN_WIDTH_ANY;
-+
-+	/*
-+	 * Note: According to 802.11n-2009 9.13.3.1, HT Protection field and
-+	 * RIFS Mode are reserved in IBSS mode, therefore keep them at 0
-+	 */
- 	ht_info->operation_mode = 0x0000;
- 	ht_info->stbc_param = 0x0000;
- 
 --- a/net/wireless/chan.c
 +++ b/net/wireless/chan.c
-@@ -6,6 +6,7 @@
-  * Copyright 2009	Johannes Berg <johannes@sipsolutions.net>
-  */
+@@ -82,7 +82,6 @@ int cfg80211_set_monitor_channel(struct 
+ 				 int freq, enum nl80211_channel_type chantype)
+ {
+ 	struct ieee80211_channel *chan;
+-	int err;
  
-+#include <linux/export.h>
- #include <net/cfg80211.h>
- #include "core.h"
- 
-@@ -44,9 +45,9 @@ rdev_freq_to_chan(struct cfg80211_regist
- 	return chan;
- }
- 
--static bool can_beacon_sec_chan(struct wiphy *wiphy,
--				struct ieee80211_channel *chan,
--				enum nl80211_channel_type channel_type)
-+int cfg80211_can_beacon_sec_chan(struct wiphy *wiphy,
-+				  struct ieee80211_channel *chan,
-+				  enum nl80211_channel_type channel_type)
- {
- 	struct ieee80211_channel *sec_chan;
- 	int diff;
-@@ -75,6 +76,7 @@ static bool can_beacon_sec_chan(struct w
+ 	if (!rdev->ops->set_monitor_channel)
+ 		return -EOPNOTSUPP;
+@@ -93,13 +92,7 @@ int cfg80211_set_monitor_channel(struct 
+ 	if (!chan)
+ 		return -EINVAL;
  
- 	return true;
+-	err = rdev->ops->set_monitor_channel(&rdev->wiphy, chan, chantype);
+-	if (!err) {
+-		rdev->monitor_channel = chan;
+-		rdev->monitor_channel_type = chantype;
+-	}
+-
+-	return err;
++	return rdev->ops->set_monitor_channel(&rdev->wiphy, chan, chantype);
  }
-+EXPORT_SYMBOL(cfg80211_can_beacon_sec_chan);
  
- int cfg80211_set_freq(struct cfg80211_registered_device *rdev,
- 		      struct wireless_dev *wdev, int freq,
-@@ -109,8 +111,8 @@ int cfg80211_set_freq(struct cfg80211_re
- 		switch (channel_type) {
- 		case NL80211_CHAN_HT40PLUS:
- 		case NL80211_CHAN_HT40MINUS:
--			if (!can_beacon_sec_chan(&rdev->wiphy, chan,
--						 channel_type)) {
-+			if (!cfg80211_can_beacon_sec_chan(&rdev->wiphy, chan,
-+							  channel_type)) {
- 				printk(KERN_DEBUG
- 				       "cfg80211: Secondary channel not "
- 				       "allowed to initiate communication\n");
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -4684,13 +4684,41 @@ static int nl80211_join_ibss(struct sk_b
- 		ibss.ie_len = nla_len(info->attrs[NL80211_ATTR_IE]);
- 	}
+ void
+@@ -134,9 +127,16 @@ cfg80211_get_chan_state(struct wireless_
+ 		break;
+ 	case NL80211_IFTYPE_AP:
+ 	case NL80211_IFTYPE_P2P_GO:
++		if (wdev->beacon_interval) {
++			*chan = wdev->channel;
++			*chanmode = CHAN_MODE_SHARED;
++		}
++		return;
+ 	case NL80211_IFTYPE_MESH_POINT:
+-		*chan = wdev->channel;
+-		*chanmode = CHAN_MODE_SHARED;
++		if (wdev->mesh_id_len) {
++			*chan = wdev->channel;
++			*chanmode = CHAN_MODE_SHARED;
++		}
+ 		return;
+ 	case NL80211_IFTYPE_MONITOR:
+ 	case NL80211_IFTYPE_AP_VLAN:
+--- a/net/wireless/core.c
++++ b/net/wireless/core.c
+@@ -747,60 +747,14 @@ static struct device_type wiphy_type = {
+ };
+ #endif
  
--	ibss.channel = ieee80211_get_channel(wiphy,
--		nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]));
-+	if (info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]) {
-+		enum nl80211_channel_type channel_type;
-+
-+		channel_type = nla_get_u32(
-+				info->attrs[NL80211_ATTR_WIPHY_CHANNEL_TYPE]);
-+		if (channel_type != NL80211_CHAN_NO_HT &&
-+		    channel_type != NL80211_CHAN_HT20 &&
-+		    channel_type != NL80211_CHAN_HT40MINUS &&
-+		    channel_type != NL80211_CHAN_HT40PLUS)
-+			return -EINVAL;
-+
-+		if (channel_type != NL80211_CHAN_NO_HT &&
-+		    !(wiphy->features & NL80211_FEATURE_HT_IBSS))
-+			return -EINVAL;
-+
-+		ibss.channel_type = channel_type;
-+	} else {
-+		ibss.channel_type = NL80211_CHAN_NO_HT;
-+	}
-+
-+	ibss.channel = rdev_freq_to_chan(rdev,
-+		nla_get_u32(info->attrs[NL80211_ATTR_WIPHY_FREQ]),
-+		ibss.channel_type);
- 	if (!ibss.channel ||
- 	    ibss.channel->flags & IEEE80211_CHAN_NO_IBSS ||
- 	    ibss.channel->flags & IEEE80211_CHAN_DISABLED)
- 		return -EINVAL;
+-static struct ieee80211_channel *
+-cfg80211_get_any_chan(struct cfg80211_registered_device *rdev)
+-{
+-	struct ieee80211_supported_band *sband;
+-	int i;
+-
+-	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
+-		sband = rdev->wiphy.bands[i];
+-		if (sband && sband->n_channels > 0)
+-			return &sband->channels[0];
+-	}
+-
+-	return NULL;
+-}
+-
+-static void cfg80211_init_mon_chan(struct cfg80211_registered_device *rdev)
+-{
+-	struct ieee80211_channel *chan;
+-
+-	chan = cfg80211_get_any_chan(rdev);
+-	if (WARN_ON(!chan))
+-		return;
+-
+-	mutex_lock(&rdev->devlist_mtx);
+-	WARN_ON(cfg80211_set_monitor_channel(rdev, chan->center_freq,
+-					     NL80211_CHAN_NO_HT));
+-	mutex_unlock(&rdev->devlist_mtx);
+-}
+-
+ void cfg80211_update_iface_num(struct cfg80211_registered_device *rdev,
+ 			       enum nl80211_iftype iftype, int num)
+ {
+-	bool has_monitors_only_old = cfg80211_has_monitors_only(rdev);
+-	bool has_monitors_only_new;
+-
+ 	ASSERT_RTNL();
  
-+	/* Both channels should be able to initiate communication */
-+	if ((ibss.channel_type == NL80211_CHAN_HT40PLUS ||
-+	     ibss.channel_type == NL80211_CHAN_HT40MINUS) &&
-+	    !cfg80211_can_beacon_sec_chan(&rdev->wiphy, ibss.channel,
-+					  ibss.channel_type))
-+		return -EINVAL;
-+
- 	ibss.channel_fixed = !!info->attrs[NL80211_ATTR_FREQ_FIXED];
- 	ibss.privacy = !!info->attrs[NL80211_ATTR_PRIVACY];
- 
---- a/include/linux/ieee80211.h
-+++ b/include/linux/ieee80211.h
-@@ -1695,6 +1695,23 @@ static inline bool ieee80211_is_robust_m
+ 	rdev->num_running_ifaces += num;
+ 	if (iftype == NL80211_IFTYPE_MONITOR)
+ 		rdev->num_running_monitor_ifaces += num;
+-
+-	has_monitors_only_new = cfg80211_has_monitors_only(rdev);
+-	if (has_monitors_only_new != has_monitors_only_old) {
+-		if (rdev->ops->set_monitor_enabled)
+-			rdev->ops->set_monitor_enabled(&rdev->wiphy,
+-						       has_monitors_only_new);
+-
+-		if (!has_monitors_only_new) {
+-			rdev->monitor_channel = NULL;
+-			rdev->monitor_channel_type = NL80211_CHAN_NO_HT;
+-		} else {
+-			cfg80211_init_mon_chan(rdev);
+-		}
+-	}
  }
  
- /**
-+ * ieee80211_is_public_action - check if frame is a public action frame
-+ * @hdr: the frame
-+ * @len: length of the frame
-+ */
-+static inline bool ieee80211_is_public_action(struct ieee80211_hdr *hdr,
-+					      size_t len)
-+{
-+	struct ieee80211_mgmt *mgmt = (void *)hdr;
-+
-+	if (len < 25)
-+		return false;
-+	if (!ieee80211_is_action(hdr->frame_control))
-+		return false;
-+	return mgmt->u.action.category == WLAN_CATEGORY_PUBLIC;
-+}
+ static int cfg80211_netdev_notifier_call(struct notifier_block *nb,
+@@ -932,6 +886,7 @@ static int cfg80211_netdev_notifier_call
+ 			mutex_unlock(&rdev->devlist_mtx);
+ 			dev_put(dev);
+ 		}
++		cfg80211_update_iface_num(rdev, wdev->iftype, 1);
+ 		cfg80211_lock_rdev(rdev);
+ 		mutex_lock(&rdev->devlist_mtx);
+ 		wdev_lock(wdev);
+@@ -1026,7 +981,6 @@ static int cfg80211_netdev_notifier_call
+ 		mutex_unlock(&rdev->devlist_mtx);
+ 		if (ret)
+ 			return notifier_from_errno(ret);
+-		cfg80211_update_iface_num(rdev, wdev->iftype, 1);
+ 		break;
+ 	}
+ 
+--- a/net/wireless/core.h
++++ b/net/wireless/core.h
+@@ -61,9 +61,6 @@ struct cfg80211_registered_device {
+ 	int num_running_ifaces;
+ 	int num_running_monitor_ifaces;
+ 
+-	struct ieee80211_channel *monitor_channel;
+-	enum nl80211_channel_type monitor_channel_type;
+-
+ 	/* BSSes/scanning */
+ 	spinlock_t bss_lock;
+ 	struct list_head bss_list;
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -1759,11 +1759,17 @@ static int nl80211_send_iface(struct sk_
+ 			(cfg80211_rdev_list_generation << 2)))
+ 		goto nla_put_failure;
+ 
+-	if (rdev->monitor_channel) {
+-		if (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,
+-				rdev->monitor_channel->center_freq) ||
+-		    nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
+-				rdev->monitor_channel_type))
++	if (rdev->ops->get_channel) {
++		struct ieee80211_channel *chan;
++		enum nl80211_channel_type channel_type;
 +
-+/**
-  * ieee80211_fhss_chan_to_freq - get channel frequency
-  * @channel: the FHSS channel
-  *
---- a/net/mac80211/tx.c
-+++ b/net/mac80211/tx.c
-@@ -1332,8 +1332,11 @@ static int invoke_tx_handlers(struct iee
- 	if (!(tx->local->hw.flags & IEEE80211_HW_HAS_RATE_CONTROL))
- 		CALL_TXH(ieee80211_tx_h_rate_ctrl);
- 
--	if (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION))
-+	if (unlikely(info->flags & IEEE80211_TX_INTFL_RETRANSMISSION)) {
-+		__skb_queue_tail(&tx->skbs, tx->skb);
-+		tx->skb = NULL;
- 		goto txh_done;
-+	}
++		chan = rdev->ops->get_channel(&rdev->wiphy, wdev,
++					      &channel_type);
++		if (chan &&
++		    (nla_put_u32(msg, NL80211_ATTR_WIPHY_FREQ,
++				 chan->center_freq) ||
++		     nla_put_u32(msg, NL80211_ATTR_WIPHY_CHANNEL_TYPE,
++				 channel_type)))
+ 			goto nla_put_failure;
+ 	}
  
- 	CALL_TXH(ieee80211_tx_h_michael_mic_add);
- 	CALL_TXH(ieee80211_tx_h_sequence);
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -851,6 +851,7 @@ static int __must_check __sta_info_destr
- 	struct ieee80211_sub_if_data *sdata;
- 	unsigned long flags;
- 	int ret, i, ac;
-+	struct tid_ampdu_tx *tid_tx;
+--- a/net/wireless/wext-compat.c
++++ b/net/wireless/wext-compat.c
+@@ -827,6 +827,8 @@ static int cfg80211_wext_giwfreq(struct 
+ {
+ 	struct wireless_dev *wdev = dev->ieee80211_ptr;
+ 	struct cfg80211_registered_device *rdev = wiphy_to_dev(wdev->wiphy);
++	struct ieee80211_channel *chan;
++	enum nl80211_channel_type channel_type;
  
- 	might_sleep();
+ 	switch (wdev->iftype) {
+ 	case NL80211_IFTYPE_STATION:
+@@ -834,10 +836,13 @@ static int cfg80211_wext_giwfreq(struct 
+ 	case NL80211_IFTYPE_ADHOC:
+ 		return cfg80211_ibss_wext_giwfreq(dev, info, freq, extra);
+ 	case NL80211_IFTYPE_MONITOR:
+-		if (!rdev->monitor_channel)
++		if (!rdev->ops->get_channel)
+ 			return -EINVAL;
+ 
+-		freq->m = rdev->monitor_channel->center_freq;
++		chan = rdev->ops->get_channel(wdev->wiphy, wdev, &channel_type);
++		if (!chan)
++			return -EINVAL;
++		freq->m = chan->center_freq;
+ 		freq->e = 6;
+ 		return 0;
+ 	default:
+--- a/drivers/net/wireless/ath/ath5k/ath5k.h
++++ b/drivers/net/wireless/ath/ath5k/ath5k.h
+@@ -1331,7 +1331,6 @@ struct ath5k_hw {
+ 	unsigned int		nexttbtt;	/* next beacon time in TU */
+ 	struct ath5k_txq	*cabq;		/* content after beacon */
+ 
+-	int			power_level;	/* Requested tx power in dBm */
+ 	bool			assoc;		/* associate state */
+ 	bool			enable_beacon;	/* true if beacons are on */
+ 
+@@ -1425,6 +1424,7 @@ struct ath5k_hw {
+ 		/* Value in dB units */
+ 		s16		txp_cck_ofdm_pwr_delta;
+ 		bool		txp_setup;
++		int		txp_requested;	/* Requested tx power in dBm */
+ 	} ah_txpower;
+ 
+ 	struct ath5k_nfcal_hist ah_nfcal_hist;
+--- a/drivers/net/wireless/ath/ath5k/base.c
++++ b/drivers/net/wireless/ath/ath5k/base.c
+@@ -325,6 +325,8 @@ ath5k_setup_channels(struct ath5k_hw *ah
+ 		if (!ath5k_is_standard_channel(ch, band))
+ 			continue;
  
-@@ -949,6 +950,30 @@ static int __must_check __sta_info_destr
++		channels[count].max_power = AR5K_TUNE_MAX_TXPOWER/2;
++
+ 		count++;
  	}
- #endif
  
-+	/* There could be some memory leaks because of ampdu tx pending queue
-+	 * not being freed before destroying the station info.
-+	 *
-+	 * Make sure that such queues are purged before freeing the station
-+	 * info.
-+	 * TODO: We have to somehow postpone the full destruction
-+	 * until the aggregation stop completes. Refer
-+	 * http://thread.gmane.org/gmane.linux.kernel.wireless.general/81936
-+	 */
-+	for (i = 0; i < STA_TID_NUM; i++) {
-+		if (!sta->ampdu_mlme.tid_tx[i])
-+			continue;
-+		tid_tx = sta->ampdu_mlme.tid_tx[i];
-+		if (skb_queue_len(&tid_tx->pending)) {
-+#ifdef CONFIG_MAC80211_HT_DEBUG
-+			wiphy_debug(local->hw.wiphy, "TX A-MPDU  purging %d "
-+				"packets for tid=%d\n",
-+				skb_queue_len(&tid_tx->pending), i);
-+#endif /* CONFIG_MAC80211_HT_DEBUG */
-+			__skb_queue_purge(&tid_tx->pending);
-+		}
-+		kfree_rcu(tid_tx, rcu_head);
-+	}
-+
- 	__sta_info_free(local, sta);
+@@ -725,7 +727,7 @@ ath5k_txbuf_setup(struct ath5k_hw *ah, s
+ 	ret = ah->ah_setup_tx_desc(ah, ds, pktlen,
+ 		ieee80211_get_hdrlen_from_skb(skb), padsize,
+ 		get_hw_packet_type(skb),
+-		(ah->power_level * 2),
++		(ah->ah_txpower.txp_requested * 2),
+ 		hw_rate,
+ 		info->control.rates[0].count, keyidx, ah->ah_tx_ant, flags,
+ 		cts_rate, duration);
+@@ -1780,7 +1782,8 @@ ath5k_beacon_setup(struct ath5k_hw *ah, 
+ 	ds->ds_data = bf->skbaddr;
+ 	ret = ah->ah_setup_tx_desc(ah, ds, skb->len,
+ 			ieee80211_get_hdrlen_from_skb(skb), padsize,
+-			AR5K_PKT_TYPE_BEACON, (ah->power_level * 2),
++			AR5K_PKT_TYPE_BEACON,
++			(ah->ah_txpower.txp_requested * 2),
+ 			ieee80211_get_tx_rate(ah->hw, info)->hw_value,
+ 			1, AR5K_TXKEYIX_INVALID,
+ 			antenna, flags, 0, 0);
+--- a/drivers/net/wireless/ath/ath5k/phy.c
++++ b/drivers/net/wireless/ath/ath5k/phy.c
+@@ -3518,6 +3518,7 @@ ath5k_setup_rate_powertable(struct ath5k
+ {
+ 	unsigned int i;
+ 	u16 *rates;
++	s16 rate_idx_scaled = 0;
+ 
+ 	/* max_pwr is power level we got from driver/user in 0.5dB
+ 	 * units, switch to 0.25dB units so we can compare */
+@@ -3564,20 +3565,32 @@ ath5k_setup_rate_powertable(struct ath5k
+ 		for (i = 8; i <= 15; i++)
+ 			rates[i] -= ah->ah_txpower.txp_cck_ofdm_gainf_delta;
  
- 	return 0;
---- a/drivers/net/wireless/ath/ath9k/calib.c
-+++ b/drivers/net/wireless/ath/ath9k/calib.c
-@@ -402,6 +402,7 @@ bool ath9k_hw_getnf(struct ath_hw *ah, s
- 	ah->noise = ath9k_hw_getchan_noise(ah, chan);
- 	return true;
++	/* Save min/max and current tx power for this channel
++	 * in 0.25dB units.
++	 *
++	 * Note: We use rates[0] for current tx power because
++	 * it covers most of the rates, in most cases. It's our
++	 * tx power limit and what the user expects to see. */
++	ah->ah_txpower.txp_min_pwr = 2 * rates[7];
++	ah->ah_txpower.txp_cur_pwr = 2 * rates[0];
++
++	/* Set max txpower for correct OFDM operation on all rates
++	 * -that is the txpower for 54Mbit-, it's used for the PAPD
++	 * gain probe and it's in 0.5dB units */
++	ah->ah_txpower.txp_ofdm = rates[7];
++
+ 	/* Now that we have all rates setup use table offset to
+ 	 * match the power range set by user with the power indices
+ 	 * on PCDAC/PDADC table */
+ 	for (i = 0; i < 16; i++) {
+-		rates[i] += ah->ah_txpower.txp_offset;
++		rate_idx_scaled = rates[i] + ah->ah_txpower.txp_offset;
+ 		/* Don't get out of bounds */
+-		if (rates[i] > 63)
+-			rates[i] = 63;
++		if (rate_idx_scaled > 63)
++			rate_idx_scaled = 63;
++		if (rate_idx_scaled < 0)
++			rate_idx_scaled = 0;
++		rates[i] = rate_idx_scaled;
+ 	}
+-
+-	/* Min/max in 0.25dB units */
+-	ah->ah_txpower.txp_min_pwr = 2 * rates[7];
+-	ah->ah_txpower.txp_cur_pwr = 2 * rates[0];
+-	ah->ah_txpower.txp_ofdm = rates[7];
  }
-+EXPORT_SYMBOL(ath9k_hw_getnf);
  
- void ath9k_init_nfcal_hist_buffer(struct ath_hw *ah,
- 				  struct ath9k_channel *chan)
+ 
+@@ -3641,10 +3654,17 @@ ath5k_hw_txpower(struct ath5k_hw *ah, st
+ 	if (!ah->ah_txpower.txp_setup ||
+ 	    (channel->hw_value != curr_channel->hw_value) ||
+ 	    (channel->center_freq != curr_channel->center_freq)) {
+-		/* Reset TX power values */
++		/* Reset TX power values but preserve requested
++		 * tx power from above */
++		int requested_txpower = ah->ah_txpower.txp_requested;
++
+ 		memset(&ah->ah_txpower, 0, sizeof(ah->ah_txpower));
++
++		/* Restore TPC setting and requested tx power */
+ 		ah->ah_txpower.txp_tpc = AR5K_TUNE_TPC_TXPOWER;
+ 
++		ah->ah_txpower.txp_requested = requested_txpower;
++
+ 		/* Calculate the powertable */
+ 		ret = ath5k_setup_channel_powertable(ah, channel,
+ 							ee_mode, type);
+@@ -3791,8 +3811,9 @@ ath5k_hw_phy_init(struct ath5k_hw *ah, s
+ 	 * RF buffer settings on 5211/5212+ so that we
+ 	 * properly set curve indices.
+ 	 */
+-	ret = ath5k_hw_txpower(ah, channel, ah->ah_txpower.txp_cur_pwr ?
+-			ah->ah_txpower.txp_cur_pwr / 2 : AR5K_TUNE_MAX_TXPOWER);
++	ret = ath5k_hw_txpower(ah, channel, ah->ah_txpower.txp_requested ?
++					ah->ah_txpower.txp_requested * 2 :
++					AR5K_TUNE_MAX_TXPOWER);
+ 	if (ret)
+ 		return ret;
+ 
+--- a/drivers/net/wireless/ath/ath5k/eeprom.c
++++ b/drivers/net/wireless/ath/ath5k/eeprom.c
+@@ -1484,7 +1484,7 @@ ath5k_eeprom_read_target_rate_pwr_info(s
+ 	case AR5K_EEPROM_MODE_11A:
+ 		offset += AR5K_EEPROM_TARGET_PWR_OFF_11A(ee->ee_version);
+ 		rate_pcal_info = ee->ee_rate_tpwr_a;
+-		ee->ee_rate_target_pwr_num[mode] = AR5K_EEPROM_N_5GHZ_CHAN;
++		ee->ee_rate_target_pwr_num[mode] = AR5K_EEPROM_N_5GHZ_RATE_CHAN;
+ 		break;
+ 	case AR5K_EEPROM_MODE_11B:
+ 		offset += AR5K_EEPROM_TARGET_PWR_OFF_11B(ee->ee_version);
+--- a/drivers/net/wireless/ath/ath5k/eeprom.h
++++ b/drivers/net/wireless/ath/ath5k/eeprom.h
+@@ -182,6 +182,7 @@
+ #define AR5K_EEPROM_EEP_DELTA		10
+ #define AR5K_EEPROM_N_MODES		3
+ #define AR5K_EEPROM_N_5GHZ_CHAN		10
++#define AR5K_EEPROM_N_5GHZ_RATE_CHAN	8
+ #define AR5K_EEPROM_N_2GHZ_CHAN		3
+ #define AR5K_EEPROM_N_2GHZ_CHAN_2413	4
+ #define	AR5K_EEPROM_N_2GHZ_CHAN_MAX	4
diff '--exclude=.svn' -Nur package/mac80211/patches/400-ath_move_debug_code.patch ../openwrt-trunk/package/mac80211/patches/400-ath_move_debug_code.patch
--- package/mac80211/patches/400-ath_move_debug_code.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/400-ath_move_debug_code.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,17 +1,18 @@
 --- a/drivers/net/wireless/ath/Makefile
 +++ b/drivers/net/wireless/ath/Makefile
-@@ -8,6 +8,5 @@ obj-$(CONFIG_ATH_COMMON)	+= ath.o
+@@ -8,7 +8,7 @@ obj-$(CONFIG_ATH_COMMON)	+= ath.o
  ath-objs :=	main.o \
  		regd.o \
  		hw.o \
 -		key.o
--
--ath-$(CONFIG_ATH_DEBUG) += debug.o
 +		key.o \
 +		debug.o
+ 
+-ath-$(CONFIG_ATH_DEBUG) += debug.o
+ ccflags-y += -D__CHECK_ENDIAN__
 --- a/drivers/net/wireless/ath/ath.h
 +++ b/drivers/net/wireless/ath/ath.h
-@@ -272,13 +272,6 @@ void ath_dbg(struct ath_common *common, 
+@@ -280,13 +280,6 @@ void _ath_dbg(struct ath_common *common,
  #endif /* CONFIG_ATH_DEBUG */
  
  /** Returns string describing opmode, or NULL if unknown mode. */
diff '--exclude=.svn' -Nur package/mac80211/patches/401-ath9k_blink_default.patch ../openwrt-trunk/package/mac80211/patches/401-ath9k_blink_default.patch
--- package/mac80211/patches/401-ath9k_blink_default.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/401-ath9k_blink_default.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,11 @@
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -40,7 +40,7 @@ int ath9k_modparam_nohwcrypt;
+ module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
+ MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
+ 
+-int led_blink;
++int led_blink = 1;
+ module_param_named(blink, led_blink, int, 0444);
+ MODULE_PARM_DESC(blink, "Enable LED blink on activity");
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/401-ath9k-dont-register-leds-on-ar9100.patch ../openwrt-trunk/package/mac80211/patches/401-ath9k-dont-register-leds-on-ar9100.patch
--- package/mac80211/patches/401-ath9k-dont-register-leds-on-ar9100.patch	2012-08-17 15:40:46.481971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/401-ath9k-dont-register-leds-on-ar9100.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,12 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -41,6 +41,9 @@ void ath_init_leds(struct ath_softc *sc)
- {
- 	int ret;
- 
-+	if (AR_SREV_9100(sc->sc_ah))
-+		return;
-+
- 	if (sc->sc_ah->led_pin < 0) {
- 		if (AR_SREV_9287(sc->sc_ah))
- 			sc->sc_ah->led_pin = ATH_LED_PIN_9287;
diff '--exclude=.svn' -Nur package/mac80211/patches/402-ath9k_blink_default.patch ../openwrt-trunk/package/mac80211/patches/402-ath9k_blink_default.patch
--- package/mac80211/patches/402-ath9k_blink_default.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/402-ath9k_blink_default.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -36,7 +36,7 @@ int ath9k_modparam_nohwcrypt;
- module_param_named(nohwcrypt, ath9k_modparam_nohwcrypt, int, 0444);
- MODULE_PARM_DESC(nohwcrypt, "Disable hardware encryption");
- 
--int led_blink;
-+int led_blink = 1;
- module_param_named(blink, led_blink, int, 0444);
- MODULE_PARM_DESC(blink, "Enable LED blink on activity");
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch ../openwrt-trunk/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch
--- package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/402-ath9k-fix-invalid-mac-address-handling.patch	2012-08-18 14:47:33.105458002 +0200
@@ -0,0 +1,29 @@
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -17,6 +17,7 @@
+ #include <linux/io.h>
+ #include <linux/slab.h>
+ #include <linux/module.h>
++#include <linux/etherdevice.h>
+ #include <asm/unaligned.h>
+ 
+ #include "hw.h"
+@@ -526,8 +527,16 @@ static int ath9k_hw_init_macaddr(struct 
+ 		common->macaddr[2 * i] = eeval >> 8;
+ 		common->macaddr[2 * i + 1] = eeval & 0xff;
+ 	}
+-	if (sum == 0 || sum == 0xffff * 3)
+-		return -EADDRNOTAVAIL;
++	if (!is_valid_ether_addr(common->macaddr)) {
++		ath_err(common,
++			"eeprom contains invalid mac address: %pM\n",
++			common->macaddr);
++
++		random_ether_addr(common->macaddr);
++		ath_err(common,
++			"random mac address will be used: %pM\n",
++			common->macaddr);
++	}
+ 
+ 	return 0;
+ }
diff '--exclude=.svn' -Nur package/mac80211/patches/403-ath9k-fix-invalid-mac-address-handling.patch ../openwrt-trunk/package/mac80211/patches/403-ath9k-fix-invalid-mac-address-handling.patch
--- package/mac80211/patches/403-ath9k-fix-invalid-mac-address-handling.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/403-ath9k-fix-invalid-mac-address-handling.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,29 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -17,6 +17,7 @@
- #include <linux/io.h>
- #include <linux/slab.h>
- #include <linux/module.h>
-+#include <linux/etherdevice.h>
- #include <asm/unaligned.h>
- 
- #include "hw.h"
-@@ -465,8 +466,16 @@ static int ath9k_hw_init_macaddr(struct 
- 		common->macaddr[2 * i] = eeval >> 8;
- 		common->macaddr[2 * i + 1] = eeval & 0xff;
- 	}
--	if (sum == 0 || sum == 0xffff * 3)
--		return -EADDRNOTAVAIL;
-+	if (!is_valid_ether_addr(common->macaddr)) {
-+		ath_err(common,
-+			"eeprom contains invalid mac address: %pM\n",
-+			common->macaddr);
-+
-+		random_ether_addr(common->macaddr);
-+		ath_err(common,
-+			"random mac address will be used: %pM\n",
-+			common->macaddr);
-+	}
- 
- 	return 0;
- }
diff '--exclude=.svn' -Nur package/mac80211/patches/403-ath_regd_optional.patch ../openwrt-trunk/package/mac80211/patches/403-ath_regd_optional.patch
--- package/mac80211/patches/403-ath_regd_optional.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/403-ath_regd_optional.patch	2012-08-18 14:47:33.105458002 +0200
@@ -0,0 +1,46 @@
+--- a/drivers/net/wireless/ath/regd.c
++++ b/drivers/net/wireless/ath/regd.c
+@@ -200,6 +200,10 @@ ath_reg_apply_beaconing_flags(struct wip
+ 	u32 bandwidth = 0;
+ 	int r;
+ 
++#ifdef ATH_USER_REGD
++	return;
++#endif
++
+ 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
+ 
+ 		if (!wiphy->bands[band])
+@@ -259,6 +263,10 @@ ath_reg_apply_active_scan_flags(struct w
+ 	u32 bandwidth = 0;
+ 	int r;
+ 
++#ifdef ATH_USER_REGD
++	return;
++#endif
++
+ 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
+ 	if (!sband)
+ 		return;
+@@ -308,6 +316,10 @@ static void ath_reg_apply_radar_flags(st
+ 	struct ieee80211_channel *ch;
+ 	unsigned int i;
+ 
++#ifdef ATH_USER_REGD
++	return;
++#endif
++
+ 	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
+ 		return;
+ 
+@@ -514,6 +526,10 @@ ath_regd_init_wiphy(struct ath_regulator
+ {
+ 	const struct ieee80211_regdomain *regd;
+ 
++#ifdef ATH_USER_REGD
++	return 0;
++#endif
++
+ 	wiphy->reg_notifier = reg_notifier;
+ 	wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/404-ath_regd_optional.patch ../openwrt-trunk/package/mac80211/patches/404-ath_regd_optional.patch
--- package/mac80211/patches/404-ath_regd_optional.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/404-ath_regd_optional.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,46 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -194,6 +194,10 @@ ath_reg_apply_beaconing_flags(struct wip
- 	u32 bandwidth = 0;
- 	int r;
- 
-+#ifdef ATH_USER_REGD
-+	return;
-+#endif
-+
- 	for (band = 0; band < IEEE80211_NUM_BANDS; band++) {
- 
- 		if (!wiphy->bands[band])
-@@ -253,6 +257,10 @@ ath_reg_apply_active_scan_flags(struct w
- 	u32 bandwidth = 0;
- 	int r;
- 
-+#ifdef ATH_USER_REGD
-+	return;
-+#endif
-+
- 	sband = wiphy->bands[IEEE80211_BAND_2GHZ];
- 	if (!sband)
- 		return;
-@@ -302,6 +310,10 @@ static void ath_reg_apply_radar_flags(st
- 	struct ieee80211_channel *ch;
- 	unsigned int i;
- 
-+#ifdef ATH_USER_REGD
-+	return;
-+#endif
-+
- 	if (!wiphy->bands[IEEE80211_BAND_5GHZ])
- 		return;
- 
-@@ -469,6 +481,10 @@ ath_regd_init_wiphy(struct ath_regulator
- {
- 	const struct ieee80211_regdomain *regd;
- 
-+#ifdef ATH_USER_REGD
-+	return 0;
-+#endif
-+
- 	wiphy->reg_notifier = reg_notifier;
- 	wiphy->flags |= WIPHY_FLAG_STRICT_REGULATORY;
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/404-world_regd_fixup.patch ../openwrt-trunk/package/mac80211/patches/404-world_regd_fixup.patch
--- package/mac80211/patches/404-world_regd_fixup.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/404-world_regd_fixup.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,84 @@
+--- a/drivers/net/wireless/ath/regd.c
++++ b/drivers/net/wireless/ath/regd.c
+@@ -44,7 +44,8 @@ static int __ath_regd_init(struct ath_re
+ 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
+ 
+ /* We allow IBSS on these on a case by case basis by regulatory domain */
+-#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 40, 0, 30,\
++#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5250, 40, 0, 30, 0), \
++				REG_RULE(5250, 5350+10, 40, 0, 30,\
+ 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+ #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 40, 0, 30,\
+ 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
+@@ -62,57 +63,56 @@ static int __ath_regd_init(struct ath_re
+ #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
+ 				ATH9K_5GHZ_5725_5850
+ 
++#define REGD_RULES(...) \
++	.reg_rules = { __VA_ARGS__ }, \
++	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
++
+ /* Can be used for:
+  * 0x60, 0x61, 0x62 */
+ static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
+-	.n_reg_rules = 5,
+ 	.alpha2 =  "99",
+-	.reg_rules = {
++	REGD_RULES(
+ 		ATH9K_2GHZ_ALL,
+ 		ATH9K_5GHZ_ALL,
+-	}
++	)
+ };
+ 
+ /* Can be used by 0x63 and 0x65 */
+ static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
+-	.n_reg_rules = 4,
+ 	.alpha2 =  "99",
+-	.reg_rules = {
++	REGD_RULES(
+ 		ATH9K_2GHZ_CH01_11,
+ 		ATH9K_2GHZ_CH12_13,
+ 		ATH9K_5GHZ_NO_MIDBAND,
+-	}
++	)
+ };
+ 
+ /* Can be used by 0x64 only */
+ static const struct ieee80211_regdomain ath_world_regdom_64 = {
+-	.n_reg_rules = 3,
+ 	.alpha2 =  "99",
+-	.reg_rules = {
++	REGD_RULES(
+ 		ATH9K_2GHZ_CH01_11,
+ 		ATH9K_5GHZ_NO_MIDBAND,
+-	}
++	)
+ };
+ 
+ /* Can be used by 0x66 and 0x69 */
+ static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
+-	.n_reg_rules = 3,
+ 	.alpha2 =  "99",
+-	.reg_rules = {
++	REGD_RULES(
+ 		ATH9K_2GHZ_CH01_11,
+ 		ATH9K_5GHZ_ALL,
+-	}
++	)
+ };
+ 
+ /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
+ static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
+-	.n_reg_rules = 4,
+ 	.alpha2 =  "99",
+-	.reg_rules = {
++	REGD_RULES(
+ 		ATH9K_2GHZ_CH01_11,
+ 		ATH9K_2GHZ_CH12_13,
+ 		ATH9K_5GHZ_ALL,
+-	}
++	)
+ };
+ 
+ static inline bool is_wwr_sku(u16 regd)
diff '--exclude=.svn' -Nur package/mac80211/patches/405-regd_no_assoc_hints.patch ../openwrt-trunk/package/mac80211/patches/405-regd_no_assoc_hints.patch
--- package/mac80211/patches/405-regd_no_assoc_hints.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/405-regd_no_assoc_hints.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,20 @@
+--- a/net/wireless/reg.c
++++ b/net/wireless/reg.c
+@@ -1702,6 +1702,8 @@ void regulatory_hint_11d(struct wiphy *w
+ 	enum environment_cap env = ENVIRON_ANY;
+ 	struct regulatory_request *request;
+ 
++	return;
++
+ 	mutex_lock(&reg_mutex);
+ 
+ 	if (unlikely(!last_request))
+@@ -1937,6 +1939,8 @@ static void restore_regulatory_settings(
+ 
+ void regulatory_hint_disconnect(void)
+ {
++	return;
++
+ 	REG_DBG_PRINT("All devices are disconnected, going to "
+ 		      "restore regulatory settings\n");
+ 	restore_regulatory_settings(false);
diff '--exclude=.svn' -Nur package/mac80211/patches/405-world_regd_fixup.patch ../openwrt-trunk/package/mac80211/patches/405-world_regd_fixup.patch
--- package/mac80211/patches/405-world_regd_fixup.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/405-world_regd_fixup.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,84 +0,0 @@
---- a/drivers/net/wireless/ath/regd.c
-+++ b/drivers/net/wireless/ath/regd.c
-@@ -38,7 +38,8 @@
- 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_OFDM)
- 
- /* We allow IBSS on these on a case by case basis by regulatory domain */
--#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 40, 0, 30,\
-+#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5250, 40, 0, 30, 0), \
-+				REG_RULE(5250, 5350+10, 40, 0, 30,\
- 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
- #define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 40, 0, 30,\
- 				NL80211_RRF_PASSIVE_SCAN | NL80211_RRF_NO_IBSS)
-@@ -56,57 +57,56 @@
- #define ATH9K_5GHZ_NO_MIDBAND	ATH9K_5GHZ_5150_5350, \
- 				ATH9K_5GHZ_5725_5850
- 
-+#define REGD_RULES(...) \
-+	.reg_rules = { __VA_ARGS__ }, \
-+	.n_reg_rules = ARRAY_SIZE(((struct ieee80211_reg_rule[]) { __VA_ARGS__ }))
-+
- /* Can be used for:
-  * 0x60, 0x61, 0x62 */
- static const struct ieee80211_regdomain ath_world_regdom_60_61_62 = {
--	.n_reg_rules = 5,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_ALL,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x63 and 0x65 */
- static const struct ieee80211_regdomain ath_world_regdom_63_65 = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x64 only */
- static const struct ieee80211_regdomain ath_world_regdom_64 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_NO_MIDBAND,
--	}
-+	)
- };
- 
- /* Can be used by 0x66 and 0x69 */
- static const struct ieee80211_regdomain ath_world_regdom_66_69 = {
--	.n_reg_rules = 3,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- /* Can be used by 0x67, 0x68, 0x6A and 0x6C */
- static const struct ieee80211_regdomain ath_world_regdom_67_68_6A_6C = {
--	.n_reg_rules = 4,
- 	.alpha2 =  "99",
--	.reg_rules = {
-+	REGD_RULES(
- 		ATH9K_2GHZ_CH01_11,
- 		ATH9K_2GHZ_CH12_13,
- 		ATH9K_5GHZ_ALL,
--	}
-+	)
- };
- 
- static inline bool is_wwr_sku(u16 regd)
diff '--exclude=.svn' -Nur package/mac80211/patches/406-ath_regd_us.patch ../openwrt-trunk/package/mac80211/patches/406-ath_regd_us.patch
--- package/mac80211/patches/406-ath_regd_us.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/406-ath_regd_us.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,26 @@
+--- a/drivers/net/wireless/ath/regd_common.h
++++ b/drivers/net/wireless/ath/regd_common.h
+@@ -32,6 +32,7 @@ enum EnumRd {
+ 	FCC2_WORLD = 0x21,
+ 	FCC2_ETSIC = 0x22,
+ 	FCC6_WORLD = 0x23,
++	FCC3_FCCA_2 = 0x2A,
+ 	FRANCE_RES = 0x31,
+ 	FCC3_FCCA = 0x3A,
+ 	FCC3_WORLD = 0x3B,
+@@ -167,6 +168,7 @@ static struct reg_dmn_pair_mapping regDo
+ 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
+ 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
+ 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
++	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
+ 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
+ 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
+ 	{FCC5_FCCA, CTL_FCC, CTL_FCC},
+@@ -463,6 +465,7 @@ static struct country_code_to_enum_rd al
+ 	{CTRY_UAE, NULL1_WORLD, "AE"},
+ 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
+ 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
++	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
+ 	/* This "PS" is for US public safety actually... to support this we
+ 	 * would need to assign new special alpha2 to CRDA db as with the world
+ 	 * regdomain and use another alpha2 */
diff '--exclude=.svn' -Nur package/mac80211/patches/406-regd_no_assoc_hints.patch ../openwrt-trunk/package/mac80211/patches/406-regd_no_assoc_hints.patch
--- package/mac80211/patches/406-regd_no_assoc_hints.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/406-regd_no_assoc_hints.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,20 +0,0 @@
---- a/net/wireless/reg.c
-+++ b/net/wireless/reg.c
-@@ -1672,6 +1672,8 @@ void regulatory_hint_11d(struct wiphy *w
- 	enum environment_cap env = ENVIRON_ANY;
- 	struct regulatory_request *request;
- 
-+	return;
-+
- 	mutex_lock(&reg_mutex);
- 
- 	if (unlikely(!last_request))
-@@ -1878,6 +1880,8 @@ static void restore_regulatory_settings(
- 
- void regulatory_hint_disconnect(void)
- {
-+	return;
-+
- 	REG_DBG_PRINT("All devices are disconnected, going to "
- 		      "restore regulatory settings\n");
- 	restore_regulatory_settings(false);
diff '--exclude=.svn' -Nur package/mac80211/patches/407-ath_regd_us.patch ../openwrt-trunk/package/mac80211/patches/407-ath_regd_us.patch
--- package/mac80211/patches/407-ath_regd_us.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/407-ath_regd_us.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,26 +0,0 @@
---- a/drivers/net/wireless/ath/regd_common.h
-+++ b/drivers/net/wireless/ath/regd_common.h
-@@ -32,6 +32,7 @@ enum EnumRd {
- 	FCC2_WORLD = 0x21,
- 	FCC2_ETSIC = 0x22,
- 	FCC6_WORLD = 0x23,
-+	FCC3_FCCA_2 = 0x2A,
- 	FRANCE_RES = 0x31,
- 	FCC3_FCCA = 0x3A,
- 	FCC3_WORLD = 0x3B,
-@@ -167,6 +168,7 @@ static struct reg_dmn_pair_mapping regDo
- 	{FCC2_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC2_ETSIC, CTL_FCC, CTL_ETSI},
- 	{FCC3_FCCA, CTL_FCC, CTL_FCC},
-+	{FCC3_FCCA_2, CTL_FCC, CTL_FCC},
- 	{FCC3_WORLD, CTL_FCC, CTL_ETSI},
- 	{FCC4_FCCA, CTL_FCC, CTL_FCC},
- 	{FCC5_FCCA, CTL_FCC, CTL_FCC},
-@@ -463,6 +465,7 @@ static struct country_code_to_enum_rd al
- 	{CTRY_UAE, NULL1_WORLD, "AE"},
- 	{CTRY_UNITED_KINGDOM, ETSI1_WORLD, "GB"},
- 	{CTRY_UNITED_STATES, FCC3_FCCA, "US"},
-+	{CTRY_UNITED_STATES, FCC3_FCCA_2, "US"},
- 	/* This "PS" is for US public safety actually... to support this we
- 	 * would need to assign new special alpha2 to CRDA db as with the world
- 	 * regdomain and use another alpha2 */
diff '--exclude=.svn' -Nur package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch ../openwrt-trunk/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch
--- package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/410-ath9k_allow_adhoc_and_ap.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,34 +1,10 @@
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1458,15 +1458,6 @@ static int ath9k_add_interface(struct ie
- 		}
- 	}
- 
--	if ((ah->opmode == NL80211_IFTYPE_ADHOC) ||
--	    ((vif->type == NL80211_IFTYPE_ADHOC) &&
--	     sc->nvifs > 0)) {
--		ath_err(common, "Cannot create ADHOC interface when other"
--			" interfaces already exist.\n");
--		ret = -EINVAL;
--		goto out;
--	}
--
- 	ath_dbg(common, ATH_DBG_CONFIG,
- 		"Attach a VIF of type: %d\n", vif->type);
- 
-@@ -1492,15 +1483,6 @@ static int ath9k_change_interface(struct
- 	mutex_lock(&sc->mutex);
- 	ath9k_ps_wakeup(sc);
- 
--	/* See if new interface type is valid. */
--	if ((new_type == NL80211_IFTYPE_ADHOC) &&
--	    (sc->nvifs > 1)) {
--		ath_err(common, "When using ADHOC, it must be the only"
--			" interface.\n");
--		ret = -EINVAL;
--		goto out;
--	}
--
- 	if (ath9k_uses_beacons(new_type) &&
- 	    !ath9k_uses_beacons(vif->type)) {
- 		if (sc->nbcnvifs >= ATH_BCBUF) {
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -667,6 +667,7 @@ static const struct ieee80211_iface_limi
+ #ifdef CONFIG_MAC80211_MESH
+ 				 BIT(NL80211_IFTYPE_MESH_POINT) |
+ #endif
++				 BIT(NL80211_IFTYPE_ADHOC) |
+ 				 BIT(NL80211_IFTYPE_AP) |
+ 				 BIT(NL80211_IFTYPE_P2P_GO) },
+ };
diff '--exclude=.svn' -Nur package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch ../openwrt-trunk/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch
--- package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch	2012-08-17 15:40:46.481971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/411-ath5k_allow_adhoc_and_ap.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/ath/ath5k/mac80211-ops.c
 +++ b/drivers/net/wireless/ath/ath5k/mac80211-ops.c
-@@ -83,13 +83,8 @@ ath5k_add_interface(struct ieee80211_hw 
+@@ -88,13 +88,8 @@ ath5k_add_interface(struct ieee80211_hw 
  		goto end;
  	}
  
@@ -18,21 +18,29 @@
  		goto end;
 --- a/drivers/net/wireless/ath/ath5k/base.c
 +++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -1867,7 +1867,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
- 		ah->bmisscount = 0;
+@@ -1878,7 +1878,7 @@ ath5k_beacon_send(struct ath5k_hw *ah)
  	}
  
--	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs > 1) ||
-+	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs + ah->num_adhoc_vifs > 1) ||
+ 	if ((ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs +
+-			ah->num_mesh_vifs > 1) ||
++			ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) ||
  			ah->opmode == NL80211_IFTYPE_MESH_POINT) {
  		u64 tsf = ath5k_hw_get_tsf64(ah);
  		u32 tsftu = TSF_TO_TU(tsf);
-@@ -1952,7 +1952,7 @@ ath5k_beacon_update_timers(struct ath5k_
- 	u64 hw_tsf;
+@@ -1964,7 +1964,7 @@ ath5k_beacon_update_timers(struct ath5k_
  
  	intval = ah->bintval & AR5K_BEACON_PERIOD;
--	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs > 1) {
-+	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs + ah->num_adhoc_vifs > 1) {
+ 	if (ah->opmode == NL80211_IFTYPE_AP && ah->num_ap_vifs
+-		+ ah->num_mesh_vifs > 1) {
++		+ ah->num_adhoc_vifs + ah->num_mesh_vifs > 1) {
  		intval /= ATH_BCBUF;	/* staggered multi-bss beacons */
  		if (intval < 15)
  			ATH5K_WARN(ah, "intval %u is too low, min 15\n",
+@@ -2429,6 +2429,7 @@ static const struct ieee80211_iface_limi
+ #ifdef CONFIG_MAC80211_MESH
+ 				 BIT(NL80211_IFTYPE_MESH_POINT) |
+ #endif
++				 BIT(NL80211_IFTYPE_ADHOC) |
+ 				 BIT(NL80211_IFTYPE_AP) },
+ };
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch ../openwrt-trunk/package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch
--- package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/412-mac80211_allow_adhoc_and_ap.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,20 @@
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -787,17 +787,11 @@ int ieee80211_register_hw(struct ieee802
+ 	 */
+ 	for (i = 0; i < hw->wiphy->n_iface_combinations; i++) {
+ 		const struct ieee80211_iface_combination *c;
+-		int j;
+ 
+ 		c = &hw->wiphy->iface_combinations[i];
+ 
+ 		if (c->num_different_channels > 1)
+ 			return -EINVAL;
+-
+-		for (j = 0; j < c->n_limits; j++)
+-			if ((c->limits[j].types & BIT(NL80211_IFTYPE_ADHOC)) &&
+-			    c->limits[j].max > 1)
+-				return -EINVAL;
+ 	}
+ 
+ #ifndef CONFIG_MAC80211_MESH
diff '--exclude=.svn' -Nur package/mac80211/patches/420-ath5k_disable_fast_cc.patch ../openwrt-trunk/package/mac80211/patches/420-ath5k_disable_fast_cc.patch
--- package/mac80211/patches/420-ath5k_disable_fast_cc.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/420-ath5k_disable_fast_cc.patch	2012-08-18 14:47:33.105458002 +0200
@@ -0,0 +1,18 @@
+--- a/drivers/net/wireless/ath/ath5k/reset.c
++++ b/drivers/net/wireless/ath/ath5k/reset.c
+@@ -1156,6 +1156,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
+ 	tsf_lo = 0;
+ 	mode = 0;
+ 
++#if 0
+ 	/*
+ 	 * Sanity check for fast flag
+ 	 * Fast channel change only available
+@@ -1163,6 +1164,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
+ 	 */
+ 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
+ 	(ah->ah_radio != AR5K_RF5413))
++#endif
+ 		fast = false;
+ 
+ 	/* Disable sleep clock operation
diff '--exclude=.svn' -Nur package/mac80211/patches/430-add_ath5k_platform.patch ../openwrt-trunk/package/mac80211/patches/430-add_ath5k_platform.patch
--- package/mac80211/patches/430-add_ath5k_platform.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/430-add_ath5k_platform.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,33 @@
+--- /dev/null
++++ b/include/linux/ath5k_platform.h
+@@ -0,0 +1,30 @@
++/*
++ * Copyright (c) 2008 Atheros Communications Inc.
++ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
++ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
++ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
++ *
++ * Permission to use, copy, modify, and/or distribute this software for any
++ * purpose with or without fee is hereby granted, provided that the above
++ * copyright notice and this permission notice appear in all copies.
++ *
++ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
++ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
++ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
++ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
++ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
++ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ */
++
++#ifndef _LINUX_ATH5K_PLATFORM_H
++#define _LINUX_ATH5K_PLATFORM_H
++
++#define ATH5K_PLAT_EEP_MAX_WORDS	2048
++
++struct ath5k_platform_data {
++	u16 *eeprom_data;
++	u8 *macaddr;
++};
++
++#endif /* _LINUX_ATH5K_PLATFORM_H */
diff '--exclude=.svn' -Nur package/mac80211/patches/430-ath5k_disable_fast_cc.patch ../openwrt-trunk/package/mac80211/patches/430-ath5k_disable_fast_cc.patch
--- package/mac80211/patches/430-ath5k_disable_fast_cc.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/430-ath5k_disable_fast_cc.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,18 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/reset.c
-+++ b/drivers/net/wireless/ath/ath5k/reset.c
-@@ -1152,6 +1152,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	tsf_lo = 0;
- 	mode = 0;
- 
-+#if 0
- 	/*
- 	 * Sanity check for fast flag
- 	 * Fast channel change only available
-@@ -1159,6 +1160,7 @@ ath5k_hw_reset(struct ath5k_hw *ah, enum
- 	 */
- 	if (fast && (ah->ah_radio != AR5K_RF2413) &&
- 	(ah->ah_radio != AR5K_RF5413))
-+#endif
- 		fast = 0;
- 
- 	/* Disable sleep clock operation
diff '--exclude=.svn' -Nur package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch ../openwrt-trunk/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch
--- package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/431-add_platform_eeprom_support_to_ath5k.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,56 @@
+--- a/drivers/net/wireless/ath/ath5k/pci.c
++++ b/drivers/net/wireless/ath/ath5k/pci.c
+@@ -23,6 +23,7 @@
+ #include <linux/pci-aspm.h>
+ #include <linux/etherdevice.h>
+ #include <linux/module.h>
++#include <linux/ath5k_platform.h>
+ #include "../ath.h"
+ #include "ath5k.h"
+ #include "debug.h"
+@@ -74,7 +75,7 @@ static void ath5k_pci_read_cachesize(str
+ }
+ 
+ /*
+- * Read from eeprom
++ * Read from eeprom or platform_data
+  */
+ static bool
+ ath5k_pci_eeprom_read(struct ath_common *common, u32 offset, u16 *data)
+@@ -82,6 +83,19 @@ ath5k_pci_eeprom_read(struct ath_common 
+ 	struct ath5k_hw *ah = (struct ath5k_hw *) common->ah;
+ 	u32 status, timeout;
+ 
++	struct ath5k_platform_data *pdata = NULL;
++	
++	if (ah->pdev)
++		pdata = ah->pdev->dev.platform_data;
++
++	if (pdata && pdata->eeprom_data && pdata->eeprom_data[61] == AR5K_EEPROM_MAGIC_VALUE) {
++		if (offset >= ATH5K_PLAT_EEP_MAX_WORDS) 
++			return false;
++		
++		*data = pdata->eeprom_data[offset];
++		return true;
++	}
++
+ 	/*
+ 	 * Initialize EEPROM access
+ 	 */
+@@ -125,6 +139,16 @@ static int ath5k_pci_eeprom_read_mac(str
+ 	u16 data;
+ 	int octet;
+ 
++	struct ath5k_platform_data *pdata = NULL;
++
++	if (ah->pdev)
++		pdata = ah->pdev->dev.platform_data;
++
++	if (pdata && pdata->macaddr) {
++		memcpy(mac, pdata->macaddr, ETH_ALEN);
++		return 0;
++	}
++
+ 	AR5K_EEPROM_READ(0x20, data);
+ 
+ 	for (offset = 0x1f, octet = 0, total = 0; offset >= 0x1d; offset--) {
diff '--exclude=.svn' -Nur package/mac80211/patches/432-ath5k_add_pciids.patch ../openwrt-trunk/package/mac80211/patches/432-ath5k_add_pciids.patch
--- package/mac80211/patches/432-ath5k_add_pciids.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/432-ath5k_add_pciids.patch	2012-08-18 14:47:33.105458002 +0200
@@ -0,0 +1,11 @@
+--- a/drivers/net/wireless/ath/ath5k/pci.c
++++ b/drivers/net/wireless/ath/ath5k/pci.c
+@@ -50,6 +50,8 @@ static DEFINE_PCI_DEVICE_TABLE(ath5k_pci
+ 	{ PCI_VDEVICE(ATHEROS, 0x001b) }, /* 5413 Eagle */
+ 	{ PCI_VDEVICE(ATHEROS, 0x001c) }, /* PCI-E cards */
+ 	{ PCI_VDEVICE(ATHEROS, 0x001d) }, /* 2417 Nala */
++	{ PCI_VDEVICE(ATHEROS, 0xff16) }, /* 2413,2414 sx76x on lantiq_danube */
++	{ PCI_VDEVICE(ATHEROS, 0xff1a) }, /* 2417 arv45xx on lantiq_danube */
+ 	{ PCI_VDEVICE(ATHEROS, 0xff1b) }, /* AR5BXB63 */
+ 	{ 0 }
+ };
diff '--exclude=.svn' -Nur package/mac80211/patches/440-ath5k_calibrate_no_queue_stop.patch ../openwrt-trunk/package/mac80211/patches/440-ath5k_calibrate_no_queue_stop.patch
--- package/mac80211/patches/440-ath5k_calibrate_no_queue_stop.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/440-ath5k_calibrate_no_queue_stop.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,31 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/base.c
-+++ b/drivers/net/wireless/ath/ath5k/base.c
-@@ -2330,15 +2330,6 @@ ath5k_calibrate_work(struct work_struct 
- 					"got new rfgain, resetting\n");
- 			ieee80211_queue_work(ah->hw, &ah->reset_work);
- 		}
--
--		/* TODO: On full calibration we should stop TX here,
--		 * so that it doesn't interfere (mostly due to gain_f
--		 * calibration that messes with tx packets -see phy.c).
--		 *
--		 * NOTE: Stopping the queues from above is not enough
--		 * to stop TX but saves us from disconecting (at least
--		 * we don't lose packets). */
--		ieee80211_stop_queues(ah->hw);
- 	} else
- 		ah->ah_cal_mask |= AR5K_CALIBRATION_SHORT;
- 
-@@ -2353,10 +2344,9 @@ ath5k_calibrate_work(struct work_struct 
- 				ah->curchan->center_freq));
- 
- 	/* Clear calibration flags */
--	if (ah->ah_cal_mask & AR5K_CALIBRATION_FULL) {
--		ieee80211_wake_queues(ah->hw);
-+	if (ah->ah_cal_mask & AR5K_CALIBRATION_FULL)
- 		ah->ah_cal_mask &= ~AR5K_CALIBRATION_FULL;
--	} else if (ah->ah_cal_mask & AR5K_CALIBRATION_SHORT)
-+	else if (ah->ah_cal_mask & AR5K_CALIBRATION_SHORT)
- 		ah->ah_cal_mask &= ~AR5K_CALIBRATION_SHORT;
- }
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch ../openwrt-trunk/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch
--- package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/440-ath5k_channel_bw_debugfs.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,113 @@
+This adds a bwmode debugfs file which can be used to set alternate
+channel operating bandwidths.  Only tested with AR5413 and only at
+5 and 20 mhz channels.
+
+Signed-off-by: Pat Erley <pat-lkml at erley.org>
+---
+Other devices will need to be added to the switch in  write_file_bwmode
+
+drivers/net/wireless/ath/ath5k/debug.c |   86 ++++++++++++++++++++++++++++++++
+ 1 files changed, 86 insertions(+), 0 deletions(-)
+
+--- a/drivers/net/wireless/ath/ath5k/debug.c
++++ b/drivers/net/wireless/ath/ath5k/debug.c
+@@ -812,6 +812,89 @@ static const struct file_operations fops
+ 	.llseek = default_llseek,
+ };
+ 
++/* debugfs: bwmode */
++
++static ssize_t read_file_bwmode(struct file *file, char __user *user_buf,
++				   size_t count, loff_t *ppos)
++{
++	struct ath5k_hw *ah = file->private_data;
++	char buf[15];
++	unsigned int len = 0;
++
++	int cur_ah_bwmode = ah->ah_bwmode;
++
++#define print_selected(MODE, LABEL) \
++	if (cur_ah_bwmode == MODE) \
++		len += snprintf(buf+len, sizeof(buf)-len, "[%s]", LABEL); \
++	else \
++		len += snprintf(buf+len, sizeof(buf)-len, "%s", LABEL); \
++	len += snprintf(buf+len, sizeof(buf)-len, " ");
++
++	print_selected(AR5K_BWMODE_5MHZ, "5");
++	print_selected(AR5K_BWMODE_10MHZ, "10");
++	print_selected(AR5K_BWMODE_DEFAULT, "20");
++	print_selected(AR5K_BWMODE_40MHZ, "40");
++#undef print_selected
++
++	len += snprintf(buf+len, sizeof(buf)-len, "\n");
++
++	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
++}
++
++static ssize_t write_file_bwmode(struct file *file,
++				 const char __user *userbuf,
++				 size_t count, loff_t *ppos)
++{
++	struct ath5k_hw *ah = file->private_data;
++	char buf[3];
++	int bw = 20;
++	int tobwmode = AR5K_BWMODE_DEFAULT;
++
++	if (copy_from_user(buf, userbuf, min(count, sizeof(buf))))
++		return -EFAULT;
++
++	/* TODO: Add check for active interface */
++
++	if(strncmp(buf, "5", 1) == 0 ) {
++		tobwmode = AR5K_BWMODE_5MHZ;
++		bw = 5;
++	} else if ( strncmp(buf, "10", 2) == 0 ) {
++		tobwmode = AR5K_BWMODE_10MHZ;
++		bw = 10;
++	} else if ( strncmp(buf, "20", 2) == 0 ) {
++		tobwmode = AR5K_BWMODE_DEFAULT;
++		bw = 20;
++	} else if ( strncmp(buf, "40", 2) == 0 ) {
++		tobwmode = AR5K_BWMODE_40MHZ;
++		bw = 40;
++	} else
++		return -EINVAL;
++
++	ATH5K_INFO(ah, "Changing to %imhz channel width[%i]\n",
++		bw, tobwmode);
++
++	switch (ah->ah_radio) {
++		/* TODO: only define radios that actually support 5/10mhz channels */
++		case AR5K_RF5413: case AR5K_RF5110: case AR5K_RF5111: case AR5K_RF5112: case AR5K_RF2413: case AR5K_RF2316: case AR5K_RF2317: case AR5K_RF2425:
++			if(ah->ah_bwmode != tobwmode) {
++				mutex_lock(&ah->lock);
++				ah->ah_bwmode = tobwmode;
++				mutex_unlock(&ah->lock);
++			}
++			break;
++		default:
++			return -EOPNOTSUPP;
++	}
++	return count;
++}
++
++static const struct file_operations fops_bwmode = {
++	.read = read_file_bwmode,
++	.write = write_file_bwmode,
++	.open = simple_open,
++	.owner = THIS_MODULE,
++	.llseek = default_llseek,
++};
+ 
+ /* debugfs: queues etc */
+ 
+@@ -903,6 +986,9 @@ ath5k_debug_init_device(struct ath5k_hw 
+ 	debugfs_create_file("beacon", S_IWUSR | S_IRUSR, phydir, ah,
+ 			    &fops_beacon);
+ 
++	debugfs_create_file("bwmode", S_IWUSR | S_IRUSR, phydir, ah,
++			    &fops_bwmode);
++
+ 	debugfs_create_file("reset", S_IWUSR, phydir, ah, &fops_reset);
+ 
+ 	debugfs_create_file("antenna", S_IWUSR | S_IRUSR, phydir, ah,
diff '--exclude=.svn' -Nur package/mac80211/patches/441-ath5k_no_agc_recalibration.patch ../openwrt-trunk/package/mac80211/patches/441-ath5k_no_agc_recalibration.patch
--- package/mac80211/patches/441-ath5k_no_agc_recalibration.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/441-ath5k_no_agc_recalibration.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,42 +0,0 @@
---- a/drivers/net/wireless/ath/ath5k/phy.c
-+++ b/drivers/net/wireless/ath/ath5k/phy.c
-@@ -1871,31 +1871,15 @@ ath5k_hw_phy_calibrate(struct ath5k_hw *
- 		ret = 0;
- 	}
- 
--	/* On full calibration do an AGC calibration and
--	 * request a PAPD probe for gainf calibration if
--	 * needed */
--	if (ah->ah_cal_mask & AR5K_CALIBRATION_FULL) {
-+	/* On full calibration request a PAPD probe for
-+	 * gainf calibration if needed */
-+	if ((ah->ah_cal_mask & AR5K_CALIBRATION_FULL) &&
-+	    (ah->ah_radio == AR5K_RF5111 ||
-+	     ah->ah_radio == AR5K_RF5112) &&
-+	    channel->hw_value != AR5K_MODE_11B)
-+		ath5k_hw_request_rfgain_probe(ah);
- 
--		AR5K_REG_ENABLE_BITS(ah, AR5K_PHY_AGCCTL,
--					AR5K_PHY_AGCCTL_CAL);
--
--		ret = ath5k_hw_register_timeout(ah, AR5K_PHY_AGCCTL,
--			AR5K_PHY_AGCCTL_CAL | AR5K_PHY_AGCCTL_NF,
--			0, false);
--		if (ret) {
--			ATH5K_ERR(ah,
--				"gain calibration timeout (%uMHz)\n",
--				channel->center_freq);
--		}
--
--		if ((ah->ah_radio == AR5K_RF5111 ||
--			ah->ah_radio == AR5K_RF5112)
--			&& (channel->hw_value != AR5K_MODE_11B))
--			ath5k_hw_request_rfgain_probe(ah);
--	}
--
--	/* Update noise floor
--	 * XXX: Only do this after AGC calibration */
-+	/* Update noise floor */
- 	if (!(ah->ah_cal_mask & AR5K_CALIBRATION_NF))
- 		ath5k_hw_update_noise_floor(ah);
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/450-add-ath5k-platform.patch ../openwrt-trunk/package/mac80211/patches/450-add-ath5k-platform.patch
--- package/mac80211/patches/450-add-ath5k-platform.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/450-add-ath5k-platform.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,33 +0,0 @@
---- /dev/null
-+++ b/include/linux/ath5k_platform.h
-@@ -0,0 +1,30 @@
-+/*
-+ * Copyright (c) 2008 Atheros Communications Inc.
-+ * Copyright (c) 2009 Gabor Juhos <juhosg@openwrt.org>
-+ * Copyright (c) 2009 Imre Kaloz <kaloz@openwrt.org>
-+ * Copyright (c) 2010 Daniel Golle <daniel.golle@gmail.com>
-+ *
-+ * Permission to use, copy, modify, and/or distribute this software for any
-+ * purpose with or without fee is hereby granted, provided that the above
-+ * copyright notice and this permission notice appear in all copies.
-+ *
-+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
-+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
-+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
-+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
-+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-+ */
-+
-+#ifndef _LINUX_ATH5K_PLATFORM_H
-+#define _LINUX_ATH5K_PLATFORM_H
-+
-+#define ATH5K_PLAT_EEP_MAX_WORDS	2048
-+
-+struct ath5k_platform_data {
-+	u16 *eeprom_data;
-+	u8 *macaddr;
-+};
-+
-+#endif /* _LINUX_ATH5K_PLATFORM_H */
diff '--exclude=.svn' -Nur package/mac80211/patches/500-ath9k_eeprom_debugfs.patch ../openwrt-trunk/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch
--- package/mac80211/patches/500-ath9k_eeprom_debugfs.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/500-ath9k_eeprom_debugfs.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,8 +1,8 @@
 --- a/drivers/net/wireless/ath/ath9k/debug.c
 +++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1616,6 +1616,53 @@ static const struct file_operations fops
- };
+@@ -1532,6 +1532,53 @@ static const struct file_operations fops
  
+ #endif
  
 +static ssize_t read_file_eeprom(struct file *file, char __user *user_buf,
 +			     size_t count, loff_t *ppos)
@@ -47,20 +47,19 @@
 +
 +static const struct file_operations fops_eeprom = {
 +	.read = read_file_eeprom,
-+	.open = ath9k_debugfs_open,
++	.open = simple_open,
 +	.owner = THIS_MODULE
 +};
 +
  int ath9k_init_debug(struct ath_hw *ah)
  {
  	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1674,6 +1721,9 @@ int ath9k_init_debug(struct ath_hw *ah)
+@@ -1603,5 +1650,8 @@ int ath9k_init_debug(struct ath_hw *ah)
  	debugfs_create_u32("gpio_val", S_IRUSR | S_IWUSR,
  			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_val);
  
 +	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
 +			    &fops_eeprom);
 +
- 	sc->debug.regidx = 0;
- 	memset(&sc->debug.bb_mac_samp, 0, sizeof(sc->debug.bb_mac_samp));
- 	sc->debug.sampidx = 0;
+ 	return 0;
+ }
diff '--exclude=.svn' -Nur package/mac80211/patches/501-ath9k-eeprom_endianess.patch ../openwrt-trunk/package/mac80211/patches/501-ath9k-eeprom_endianess.patch
--- package/mac80211/patches/501-ath9k-eeprom_endianess.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/501-ath9k-eeprom_endianess.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,102 @@
+--- a/drivers/net/wireless/ath/ath9k/eeprom_def.c
++++ b/drivers/net/wireless/ath/ath9k/eeprom_def.c
+@@ -267,7 +267,7 @@ static int ath9k_hw_def_check_eeprom(str
+ 	struct ar5416_eeprom_def *eep =
+ 		(struct ar5416_eeprom_def *) &ah->eeprom.def;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-	u16 *eepdata, temp, magic, magic2;
++	u16 *eepdata, temp, magic;
+ 	u32 sum = 0, el;
+ 	bool need_swap = false;
+ 	int i, addr, size;
+@@ -277,27 +277,16 @@ static int ath9k_hw_def_check_eeprom(str
+ 		return false;
+ 	}
+ 
+-	if (!ath9k_hw_use_flash(ah)) {
+-		ath_dbg(common, EEPROM, "Read Magic = 0x%04X\n", magic);
+-
+-		if (magic != AR5416_EEPROM_MAGIC) {
+-			magic2 = swab16(magic);
+-
+-			if (magic2 == AR5416_EEPROM_MAGIC) {
+-				size = sizeof(struct ar5416_eeprom_def);
+-				need_swap = true;
+-				eepdata = (u16 *) (&ah->eeprom);
+-
+-				for (addr = 0; addr < size / sizeof(u16); addr++) {
+-					temp = swab16(*eepdata);
+-					*eepdata = temp;
+-					eepdata++;
+-				}
+-			} else {
+-				ath_err(common,
+-					"Invalid EEPROM Magic. Endianness mismatch.\n");
+-				return -EINVAL;
+-			}
++	if (swab16(magic) == AR5416_EEPROM_MAGIC &&
++	    !(ah->ah_flags & AH_NO_EEP_SWAP)) {
++		size = sizeof(struct ar5416_eeprom_def);
++		need_swap = true;
++		eepdata = (u16 *) (&ah->eeprom);
++
++		for (addr = 0; addr < size / sizeof(u16); addr++) {
++			temp = swab16(*eepdata);
++			*eepdata = temp;
++			eepdata++;
+ 		}
+ 	}
+ 
+--- a/drivers/net/wireless/ath/ath9k/eeprom_4k.c
++++ b/drivers/net/wireless/ath/ath9k/eeprom_4k.c
+@@ -196,7 +196,7 @@ static int ath9k_hw_4k_check_eeprom(stru
+ 	int i, addr;
+ 
+ 
+-	if (!ath9k_hw_use_flash(ah)) {
++	if (!(ah->ah_flags & AH_NO_EEP_SWAP)) {
+ 		if (!ath9k_hw_nvram_read(common, AR5416_EEPROM_MAGIC_OFFSET,
+ 					 &magic)) {
+ 			ath_err(common, "Reading Magic # failed\n");
+--- a/drivers/net/wireless/ath/ath9k/eeprom_9287.c
++++ b/drivers/net/wireless/ath/ath9k/eeprom_9287.c
+@@ -189,7 +189,7 @@ static int ath9k_hw_ar9287_check_eeprom(
+ 	struct ar9287_eeprom *eep = &ah->eeprom.map9287;
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 
+-	if (!ath9k_hw_use_flash(ah)) {
++	if (!(ah->ah_flags & AH_NO_EEP_SWAP)) {
+ 		if (!ath9k_hw_nvram_read(common, AR5416_EEPROM_MAGIC_OFFSET,
+ 					 &magic)) {
+ 			ath_err(common, "Reading Magic # failed\n");
+--- a/drivers/net/wireless/ath/ath9k/hw.h
++++ b/drivers/net/wireless/ath/ath9k/hw.h
+@@ -703,6 +703,7 @@ enum ath_cal_list {
+ #define AH_USE_EEPROM   0x1
+ #define AH_UNPLUGGED    0x2 /* The card has been physically removed. */
+ #define AH_FASTCC       0x4
++#define AH_NO_EEP_SWAP  0x8 /* Do not swap EEPROM data */
+ 
+ struct ath_hw {
+ 	struct ath_ops reg_ops;
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -537,6 +537,8 @@ static int ath9k_init_softc(u16 devid, s
+ 		ah->is_clk_25mhz = pdata->is_clk_25mhz;
+ 		ah->get_mac_revision = pdata->get_mac_revision;
+ 		ah->external_reset = pdata->external_reset;
++		if (!pdata->endian_check)
++			ah->ah_flags |= AH_NO_EEP_SWAP;
+ 	}
+ 
+ 	common = ath9k_hw_common(ah);
+--- a/include/linux/ath9k_platform.h
++++ b/include/linux/ath9k_platform.h
+@@ -29,6 +29,7 @@ struct ath9k_platform_data {
+ 	u32 gpio_mask;
+ 	u32 gpio_val;
+ 
++	bool endian_check;
+ 	bool is_clk_25mhz;
+ 	int (*get_mac_revision)(void);
+ 	int (*external_reset)(void);
diff '--exclude=.svn' -Nur package/mac80211/patches/502-ath9k_ahb_init.patch ../openwrt-trunk/package/mac80211/patches/502-ath9k_ahb_init.patch
--- package/mac80211/patches/502-ath9k_ahb_init.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/502-ath9k_ahb_init.patch	2012-08-18 14:47:33.105458002 +0200
@@ -0,0 +1,32 @@
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -926,23 +926,23 @@ static int __init ath9k_init(void)
+ 		goto err_out;
+ 	}
+ 
+-	error = ath_pci_init();
++	error = ath_ahb_init();
+ 	if (error < 0) {
+-		pr_err("No PCI devices found, driver not installed\n");
+ 		error = -ENODEV;
+ 		goto err_rate_unregister;
+ 	}
+ 
+-	error = ath_ahb_init();
++	error = ath_pci_init();
+ 	if (error < 0) {
++		pr_err("No PCI devices found, driver not installed\n");
+ 		error = -ENODEV;
+-		goto err_pci_exit;
++		goto err_ahb_exit;
+ 	}
+ 
+ 	return 0;
+ 
+- err_pci_exit:
+-	ath_pci_exit();
++ err_ahb_exit:
++	ath_ahb_exit();
+ 
+  err_rate_unregister:
+ 	ath_rate_control_unregister();
diff '--exclude=.svn' -Nur package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch ../openwrt-trunk/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch
--- package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch	2012-08-17 15:40:46.501971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/510-ath9k_intr_mitigation_tweak.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,7 +1,7 @@
 --- a/drivers/net/wireless/ath/ath9k/hw.c
 +++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1795,8 +1795,8 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 	REG_WRITE(ah, AR_OBS, 8);
+@@ -1952,8 +1952,8 @@ int ath9k_hw_reset(struct ath_hw *ah, st
+ 		REG_WRITE(ah, AR_OBS, 8);
  
  	if (ah->config.rx_intr_mitigation) {
 -		REG_RMW_FIELD(ah, AR_RIMT, AR_RIMT_LAST, 500);
diff '--exclude=.svn' -Nur package/mac80211/patches/511-ath9k_increase_bcbuf.patch ../openwrt-trunk/package/mac80211/patches/511-ath9k_increase_bcbuf.patch
--- package/mac80211/patches/511-ath9k_increase_bcbuf.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/511-ath9k_increase_bcbuf.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -366,7 +366,7 @@ struct ath_vif {
-  * number of beacon intervals, the game's up.
-  */
- #define BSTUCK_THRESH           	9
--#define	ATH_BCBUF               	4
-+#define	ATH_BCBUF               	8
- #define ATH_DEFAULT_BINTVAL     	100 /* TU */
- #define ATH_DEFAULT_BMISS_LIMIT 	10
- #define IEEE80211_MS_TO_TU(x)           (((x) * 1000) / 1024)
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -388,8 +388,8 @@ static void ath9k_hw_init_config(struct 
- {
- 	int i;
- 
--	ah->config.dma_beacon_response_time = 2;
--	ah->config.sw_beacon_response_time = 10;
-+	ah->config.dma_beacon_response_time = 1;
-+	ah->config.sw_beacon_response_time = 6;
- 	ah->config.additional_swba_backoff = 0;
- 	ah->config.ack_6mb = 0x0;
- 	ah->config.cwm_ignore_extcca = 0;
diff '--exclude=.svn' -Nur package/mac80211/patches/511-ath9k_reduce_rxbuf.patch ../openwrt-trunk/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch
--- package/mac80211/patches/511-ath9k_reduce_rxbuf.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/511-ath9k_reduce_rxbuf.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,11 @@
+--- a/drivers/net/wireless/ath/ath9k/ath9k.h
++++ b/drivers/net/wireless/ath/ath9k/ath9k.h
+@@ -122,7 +122,7 @@ void ath_descdma_cleanup(struct ath_soft
+ /* RX / TX */
+ /***********/
+ 
+-#define ATH_RXBUF               512
++#define ATH_RXBUF               256
+ #define ATH_TXBUF               512
+ #define ATH_TXBUF_RESERVE       5
+ #define ATH_MAX_QDEPTH          (ATH_TXBUF / 4 - ATH_TXBUF_RESERVE)
diff '--exclude=.svn' -Nur package/mac80211/patches/512-ath9k_channelbw_debugfs.patch ../openwrt-trunk/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch
--- package/mac80211/patches/512-ath9k_channelbw_debugfs.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/512-ath9k_channelbw_debugfs.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,128 @@
+--- a/drivers/net/wireless/ath/ath9k/ath9k.h
++++ b/drivers/net/wireless/ath/ath9k/ath9k.h
+@@ -658,6 +658,7 @@ struct ath_softc {
+ 	struct ieee80211_hw *hw;
+ 	struct device *dev;
+ 
++	u32 chan_bw;
+ 	struct survey_info *cur_survey;
+ 	struct survey_info survey[ATH9K_NUM_CHANNELS];
+ 
+@@ -733,6 +734,7 @@ struct ath_softc {
+ #endif
+ };
+ 
++int ath9k_config(struct ieee80211_hw *hw, u32 changed);
+ void ath9k_tasklet(unsigned long data);
+ int ath_cabq_update(struct ath_softc *);
+ 
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -1579,6 +1579,50 @@ static const struct file_operations fops
+ 	.owner = THIS_MODULE
+ };
+ 
++
++static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
++			     size_t count, loff_t *ppos)
++{
++	struct ath_softc *sc = file->private_data;
++	char buf[32];
++	unsigned int len;
++
++	len = sprintf(buf, "0x%08x\n", sc->chan_bw);
++	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
++}
++
++static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
++			     size_t count, loff_t *ppos)
++{
++	struct ath_softc *sc = file->private_data;
++	unsigned long chan_bw;
++	char buf[32];
++	ssize_t len;
++
++	len = min(count, sizeof(buf) - 1);
++	if (copy_from_user(buf, user_buf, len))
++		return -EFAULT;
++
++	buf[len] = '\0';
++	if (strict_strtoul(buf, 0, &chan_bw))
++		return -EINVAL;
++
++	sc->chan_bw = chan_bw;
++	if (!(sc->sc_flags & SC_OP_INVALID))
++		ath9k_config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
++
++	return count;
++}
++
++static const struct file_operations fops_chanbw = {
++	.read = read_file_chan_bw,
++	.write = write_file_chan_bw,
++	.open = simple_open,
++	.owner = THIS_MODULE,
++	.llseek = default_llseek,
++};
++
++
+ int ath9k_init_debug(struct ath_hw *ah)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+@@ -1653,5 +1697,8 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
+ 			    &fops_eeprom);
+ 
++	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
++			    sc, &fops_chanbw);
++
+ 	return 0;
+ }
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -1095,7 +1095,7 @@ static void ath9k_disable_ps(struct ath_
+ 	ath_dbg(common, PS, "PowerSave disabled\n");
+ }
+ 
+-static int ath9k_config(struct ieee80211_hw *hw, u32 changed)
++int ath9k_config(struct ieee80211_hw *hw, u32 changed)
+ {
+ 	struct ath_softc *sc = hw->priv;
+ 	struct ath_hw *ah = sc->sc_ah;
+@@ -1149,9 +1149,11 @@ static int ath9k_config(struct ieee80211
+ 
+ 	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || reset_channel) {
+ 		struct ieee80211_channel *curchan = hw->conf.channel;
++		struct ath9k_channel *hchan;
+ 		int pos = curchan->hw_value;
+ 		int old_pos = -1;
+ 		unsigned long flags;
++		u32 oldflags;
+ 
+ 		if (ah->curchan)
+ 			old_pos = ah->curchan - &ah->channels[0];
+@@ -1194,7 +1196,23 @@ static int ath9k_config(struct ieee80211
+ 			memset(&sc->survey[pos], 0, sizeof(struct survey_info));
+ 		}
+ 
+-		if (ath_set_channel(sc, hw, &sc->sc_ah->channels[pos]) < 0) {
++		hchan = &sc->sc_ah->channels[pos];
++		oldflags = hchan->channelFlags;
++		switch (sc->chan_bw) {
++		case 5:
++			hchan->channelFlags &= ~CHANNEL_HALF;
++			hchan->channelFlags |= CHANNEL_QUARTER;
++			break;
++		case 10:
++			hchan->channelFlags &= ~CHANNEL_QUARTER;
++			hchan->channelFlags |= CHANNEL_HALF;
++			break;
++		default:
++			hchan->channelFlags &= ~(CHANNEL_HALF | CHANNEL_QUARTER);
++			break;
++		}
++
++		if (ath_set_channel(sc, hw, hchan) < 0) {
+ 			ath_err(common, "Unable to set channel\n");
+ 			mutex_unlock(&sc->mutex);
+ 			ath9k_ps_restore(sc);
diff '--exclude=.svn' -Nur package/mac80211/patches/512-ath9k_reduce_rxbuf.patch ../openwrt-trunk/package/mac80211/patches/512-ath9k_reduce_rxbuf.patch
--- package/mac80211/patches/512-ath9k_reduce_rxbuf.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/512-ath9k_reduce_rxbuf.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -121,7 +121,7 @@ void ath_descdma_cleanup(struct ath_soft
- /* RX / TX */
- /***********/
- 
--#define ATH_RXBUF               512
-+#define ATH_RXBUF               128
- #define ATH_TXBUF               512
- #define ATH_TXBUF_RESERVE       5
- #define ATH_MAX_QDEPTH          (ATH_TXBUF / 4 - ATH_TXBUF_RESERVE)
diff '--exclude=.svn' -Nur package/mac80211/patches/513-ath9k_channelbw_debugfs.patch ../openwrt-trunk/package/mac80211/patches/513-ath9k_channelbw_debugfs.patch
--- package/mac80211/patches/513-ath9k_channelbw_debugfs.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/513-ath9k_channelbw_debugfs.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,142 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -591,6 +591,7 @@ struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
- 
-+	u32 chan_bw;
- 	int chan_idx;
- 	int chan_is_ht;
- 	struct survey_info *cur_survey;
-@@ -655,6 +656,7 @@ struct ath_softc {
- 	u8 ant_tx, ant_rx;
- };
- 
-+int ath9k_config(struct ieee80211_hw *hw, u32 changed);
- void ath9k_tasklet(unsigned long data);
- int ath_cabq_update(struct ath_softc *);
- 
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1663,6 +1663,50 @@ static const struct file_operations fops
- 	.owner = THIS_MODULE
- };
- 
-+
-+static ssize_t read_file_chan_bw(struct file *file, char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	char buf[32];
-+	unsigned int len;
-+
-+	len = sprintf(buf, "0x%08x\n", sc->chan_bw);
-+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
-+}
-+
-+static ssize_t write_file_chan_bw(struct file *file, const char __user *user_buf,
-+			     size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	unsigned long chan_bw;
-+	char buf[32];
-+	ssize_t len;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, user_buf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	if (strict_strtoul(buf, 0, &chan_bw))
-+		return -EINVAL;
-+
-+	sc->chan_bw = chan_bw;
-+	if (!(sc->sc_flags & SC_OP_INVALID))
-+		ath9k_config(sc->hw, IEEE80211_CONF_CHANGE_CHANNEL);
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_chanbw = {
-+	.read = read_file_chan_bw,
-+	.write = write_file_chan_bw,
-+	.open = ath9k_debugfs_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+
- int ath9k_init_debug(struct ath_hw *ah)
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
-@@ -1724,6 +1768,9 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	debugfs_create_file("eeprom", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_eeprom);
- 
-+	debugfs_create_file("chanbw", S_IRUSR | S_IWUSR, sc->debug.debugfs_phy,
-+			    sc, &fops_chanbw);
-+
- 	sc->debug.regidx = 0;
- 	memset(&sc->debug.bb_mac_samp, 0, sizeof(sc->debug.bb_mac_samp));
- 	sc->debug.sampidx = 0;
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1564,7 +1564,7 @@ static void ath9k_disable_ps(struct ath_
- 
- }
- 
--static int ath9k_config(struct ieee80211_hw *hw, u32 changed)
-+int ath9k_config(struct ieee80211_hw *hw, u32 changed)
- {
- 	struct ath_softc *sc = hw->priv;
- 	struct ath_hw *ah = sc->sc_ah;
-@@ -1623,9 +1623,11 @@ static int ath9k_config(struct ieee80211
- 
- 	if ((changed & IEEE80211_CONF_CHANGE_CHANNEL) || reset_channel) {
- 		struct ieee80211_channel *curchan = hw->conf.channel;
-+		struct ath9k_channel *hchan;
- 		int pos = curchan->hw_value;
- 		int old_pos = -1;
- 		unsigned long flags;
-+		u32 oldflags;
- 
- 		if (ah->curchan)
- 			old_pos = ah->curchan - &ah->channels[0];
-@@ -1674,7 +1676,23 @@ static int ath9k_config(struct ieee80211
- 			memset(&sc->survey[pos], 0, sizeof(struct survey_info));
- 		}
- 
--		if (ath_set_channel(sc, hw, &sc->sc_ah->channels[pos]) < 0) {
-+		hchan = &sc->sc_ah->channels[pos];
-+		oldflags = hchan->channelFlags;
-+		switch (sc->chan_bw) {
-+		case 5:
-+			hchan->channelFlags &= ~CHANNEL_HALF;
-+			hchan->channelFlags |= CHANNEL_QUARTER;
-+			break;
-+		case 10:
-+			hchan->channelFlags &= ~CHANNEL_QUARTER;
-+			hchan->channelFlags |= CHANNEL_HALF;
-+			break;
-+		default:
-+			hchan->channelFlags &= ~(CHANNEL_HALF | CHANNEL_QUARTER);
-+			break;
-+		}
-+
-+		if (ath_set_channel(sc, hw, hchan) < 0) {
- 			ath_err(common, "Unable to set channel\n");
- 			mutex_unlock(&sc->mutex);
- 			return -EINVAL;
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1609,6 +1609,10 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- 	    caldata->rtt_hist.num_readings)
- 		allow_fbs = true;
- 
-+	if (!ah->curchan || ((ah->curchan->channelFlags ^ chan->channelFlags) &
-+	    (CHANNEL_HALF | CHANNEL_QUARTER)))
-+		bChannelChange = false;
-+
- 	if (bChannelChange &&
- 	    (ah->chip_fullsleep != true) &&
- 	    (ah->curchan != NULL) &&
diff '--exclude=.svn' -Nur package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch ../openwrt-trunk/package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch
--- package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/513-mac80211_reduce_txqueuelen.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,10 @@
+--- a/net/mac80211/iface.c
++++ b/net/mac80211/iface.c
+@@ -938,6 +938,7 @@ static const struct net_device_ops ieee8
+ static void ieee80211_if_setup(struct net_device *dev)
+ {
+ 	ether_setup(dev);
++	dev->tx_queue_len = 32;
+ 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
+ 	netdev_attach_ops(dev, &ieee80211_dataif_ops);
+ #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
diff '--exclude=.svn' -Nur package/mac80211/patches/520-mac80211_cur_txpower.patch ../openwrt-trunk/package/mac80211/patches/520-mac80211_cur_txpower.patch
--- package/mac80211/patches/520-mac80211_cur_txpower.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/520-mac80211_cur_txpower.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,32 @@
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -835,7 +835,7 @@ enum ieee80211_smps_mode {
+  */
+ struct ieee80211_conf {
+ 	u32 flags;
+-	int power_level, dynamic_ps_timeout;
++	int cur_power_level, power_level, dynamic_ps_timeout;
+ 	int max_sleep_period;
+ 
+ 	u16 listen_interval;
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -1957,7 +1957,7 @@ static int ieee80211_get_tx_power(struct
+ {
+ 	struct ieee80211_local *local = wiphy_priv(wiphy);
+ 
+-	*dbm = local->hw.conf.power_level;
++	*dbm = local->hw.conf.cur_power_level;
+ 
+ 	return 0;
+ }
+--- a/net/mac80211/main.c
++++ b/net/mac80211/main.c
+@@ -167,6 +167,7 @@ int ieee80211_hw_config(struct ieee80211
+ 
+ 	if (local->hw.conf.power_level != power) {
+ 		changed |= IEEE80211_CONF_CHANGE_POWER;
++		local->hw.conf.cur_power_level = power;
+ 		local->hw.conf.power_level = power;
+ 	}
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/520-mac80211_ht_change_rate_update.patch ../openwrt-trunk/package/mac80211/patches/520-mac80211_ht_change_rate_update.patch
--- package/mac80211/patches/520-mac80211_ht_change_rate_update.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/520-mac80211_ht_change_rate_update.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,35 +0,0 @@
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -196,7 +196,9 @@ void ieee80211_bss_info_change_notify(st
- 				      u32 changed)
- {
- 	struct ieee80211_local *local = sdata->local;
-+	struct ieee80211_supported_band *sband;
- 	static const u8 zero[ETH_ALEN] = { 0 };
-+	struct sta_info *sta;
- 
- 	if (!changed)
- 		return;
-@@ -226,6 +228,22 @@ void ieee80211_bss_info_change_notify(st
- 
- 	switch (sdata->vif.type) {
- 	case NL80211_IFTYPE_AP:
-+		if (!(changed & BSS_CHANGED_HT))
-+			break;
-+
-+		sband = local->hw.wiphy->bands[local->hw.conf.channel->band];
-+		rcu_read_lock();
-+		list_for_each_entry(sta, &local->sta_list, list) {
-+			if (sta->sdata != sdata &&
-+			    (!sdata->bss || sta->sdata->bss != sdata->bss))
-+				continue;
-+
-+			rate_control_rate_update(local, sband, sta,
-+				IEEE80211_RC_HT_CHANGED,
-+				local->_oper_channel_type);
-+		}
-+		rcu_read_unlock();
-+		break;
- 	case NL80211_IFTYPE_ADHOC:
- 	case NL80211_IFTYPE_WDS:
- 	case NL80211_IFTYPE_MESH_POINT:
diff '--exclude=.svn' -Nur package/mac80211/patches/521-ath9k_cur_txpower.patch ../openwrt-trunk/package/mac80211/patches/521-ath9k_cur_txpower.patch
--- package/mac80211/patches/521-ath9k_cur_txpower.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/521-ath9k_cur_txpower.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,19 @@
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -1219,6 +1219,8 @@ int ath9k_config(struct ieee80211_hw *hw
+ 			return -EINVAL;
+ 		}
+ 
++		conf->cur_power_level = sc->curtxpow / 2;
++
+ 		/*
+ 		 * The most recent snapshot of channel->noisefloor for the old
+ 		 * channel is only available after the hardware reset. Copy it to
+@@ -1233,6 +1235,7 @@ int ath9k_config(struct ieee80211_hw *hw
+ 		sc->config.txpowlimit = 2 * conf->power_level;
+ 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
+ 				       sc->config.txpowlimit, &sc->curtxpow);
++		conf->cur_power_level = sc->curtxpow / 2;
+ 	}
+ 
+ 	mutex_unlock(&sc->mutex);
diff '--exclude=.svn' -Nur package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch ../openwrt-trunk/package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch
--- package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/522-ath9k_per_chain_signal_strength.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,385 @@
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -706,6 +706,9 @@ enum mac80211_rx_flags {
+  * @signal: signal strength when receiving this frame, either in dBm, in dB or
+  *	unspecified depending on the hardware capabilities flags
+  *	@IEEE80211_HW_SIGNAL_*
++ * @chains: bitmask of receive chains for which separate signal strength
++ *	values were filled.
++ * @chain_signal: per-chain signal strength, same format as @signal
+  * @antenna: antenna used
+  * @rate_idx: index of data rate into band's supported rates or MCS index if
+  *	HT rates are use (RX_FLAG_HT)
+@@ -722,6 +725,9 @@ struct ieee80211_rx_status {
+ 	u8 band;
+ 	u8 antenna;
+ 	s8 signal;
++
++	u8 chains;
++	s8 chain_signal[4];
+ };
+ 
+ /**
+--- a/net/mac80211/sta_info.h
++++ b/net/mac80211/sta_info.h
+@@ -325,6 +325,11 @@ struct sta_info {
+ 	unsigned long rx_dropped;
+ 	int last_signal;
+ 	struct ewma avg_signal;
++
++	u8 chains;
++	s8 chain_signal_last[4];
++	struct ewma chain_signal_avg[4];
++
+ 	/* Plus 1 for non-QoS frames */
+ 	__le16 last_seq_ctrl[NUM_RX_DATA_QUEUES + 1];
+ 
+--- a/net/mac80211/rx.c
++++ b/net/mac80211/rx.c
+@@ -1231,6 +1231,7 @@ ieee80211_rx_h_sta_process(struct ieee80
+ 	struct sk_buff *skb = rx->skb;
+ 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
+ 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
++	int i;
+ 
+ 	if (!sta)
+ 		return RX_CONTINUE;
+@@ -1275,6 +1276,19 @@ ieee80211_rx_h_sta_process(struct ieee80
+ 		ewma_add(&sta->avg_signal, -status->signal);
+ 	}
+ 
++	if (status->chains) {
++		sta->chains = status->chains;
++		for (i = 0; i < 4; i++) {
++			int signal = status->chain_signal[i];
++
++			if (!(status->chains & BIT(i)))
++				continue;
++
++			sta->chain_signal_last[i] = signal;
++			ewma_add(&sta->chain_signal_avg[i], -signal);
++		}
++	}
++
+ 	/*
+ 	 * Change STA power saving mode only at the end of a frame
+ 	 * exchange sequence.
+--- a/net/mac80211/sta_info.c
++++ b/net/mac80211/sta_info.c
+@@ -254,6 +254,8 @@ struct sta_info *sta_info_alloc(struct i
+ 	do_posix_clock_monotonic_gettime(&uptime);
+ 	sta->last_connected = uptime.tv_sec;
+ 	ewma_init(&sta->avg_signal, 1024, 8);
++	for (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)
++		ewma_init(&sta->chain_signal_avg[i], 1024, 8);
+ 
+ 	if (sta_prepare_rate_control(local, sta, gfp)) {
+ 		kfree(sta);
+--- a/include/net/cfg80211.h
++++ b/include/net/cfg80211.h
+@@ -546,6 +546,8 @@ struct station_parameters {
+  * @STATION_INFO_STA_FLAGS: @sta_flags filled
+  * @STATION_INFO_BEACON_LOSS_COUNT: @beacon_loss_count filled
+  * @STATION_INFO_T_OFFSET: @t_offset filled
++ * @STATION_INFO_CHAIN_SIGNAL: @chain_signal filled
++ * @STATION_INFO_CHAIN_SIGNAL_AVG: @chain_signal_avg filled
+  */
+ enum station_info_flags {
+ 	STATION_INFO_INACTIVE_TIME	= 1<<0,
+@@ -569,6 +571,8 @@ enum station_info_flags {
+ 	STATION_INFO_STA_FLAGS		= 1<<18,
+ 	STATION_INFO_BEACON_LOSS_COUNT	= 1<<19,
+ 	STATION_INFO_T_OFFSET		= 1<<20,
++	STATION_INFO_CHAIN_SIGNAL	= 1<<21,
++	STATION_INFO_CHAIN_SIGNAL_AVG	= 1<<22,
+ };
+ 
+ /**
+@@ -652,6 +656,9 @@ struct sta_bss_parameters {
+  *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
+  * @signal_avg: Average signal strength, type depends on the wiphy's signal_type.
+  *	For CFG80211_SIGNAL_TYPE_MBM, value is expressed in _dBm_.
++ * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg
++ * @chain_signal: per-chain signal strength of last received packet in dBm
++ * @chain_signal_avg: per-chain signal strength average in dBm
+  * @txrate: current unicast bitrate from this station
+  * @rxrate: current unicast bitrate to this station
+  * @rx_packets: packets received from this station
+@@ -684,6 +691,11 @@ struct station_info {
+ 	u8 plink_state;
+ 	s8 signal;
+ 	s8 signal_avg;
++
++	u8 chains;
++	s8 chain_signal[4];
++	s8 chain_signal_avg[4];
++
+ 	struct rate_info txrate;
+ 	struct rate_info rxrate;
+ 	u32 rx_packets;
+--- a/drivers/net/wireless/ath/ath9k/mac.h
++++ b/drivers/net/wireless/ath/ath9k/mac.h
+@@ -133,12 +133,8 @@ struct ath_rx_status {
+ 	u8 rs_rate;
+ 	u8 rs_antenna;
+ 	u8 rs_more;
+-	int8_t rs_rssi_ctl0;
+-	int8_t rs_rssi_ctl1;
+-	int8_t rs_rssi_ctl2;
+-	int8_t rs_rssi_ext0;
+-	int8_t rs_rssi_ext1;
+-	int8_t rs_rssi_ext2;
++	int8_t rs_rssi_ctl[3];
++	int8_t rs_rssi_ext[3];
+ 	u8 rs_isaggr;
+ 	u8 rs_moreaggr;
+ 	u8 rs_num_delims;
+--- a/drivers/net/wireless/ath/ath9k/recv.c
++++ b/drivers/net/wireless/ath/ath9k/recv.c
+@@ -955,6 +955,7 @@ static int ath9k_rx_skb_preprocess(struc
+ 				   bool *decrypt_error)
+ {
+ 	struct ath_hw *ah = common->ah;
++	int i, j;
+ 
+ 	/*
+ 	 * everything but the rate is checked here, the rate check is done
+@@ -980,6 +981,20 @@ static int ath9k_rx_skb_preprocess(struc
+ 	if (rx_stats->rs_moreaggr)
+ 		rx_status->flag |= RX_FLAG_NO_SIGNAL_VAL;
+ 
++	for (i = 0, j = 0; i < ARRAY_SIZE(rx_stats->rs_rssi_ctl); i++) {
++		s8 rssi;
++
++		if (!(ah->rxchainmask & BIT(i)))
++			continue;
++
++		rssi = rx_stats->rs_rssi_ctl[i];
++		if (rssi != ATH9K_RSSI_BAD) {
++		    rx_status->chains |= BIT(j);
++		    rx_status->chain_signal[j] = ah->noise + rssi;
++		}
++		j++;
++	}
++
+ 	return 0;
+ }
+ 
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+@@ -458,12 +458,12 @@ int ath9k_hw_process_rxdesc_edma(struct 
+ 
+ 	/* XXX: Keycache */
+ 	rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);
+-	rxs->rs_rssi_ctl0 = MS(rxsp->status1, AR_RxRSSIAnt00);
+-	rxs->rs_rssi_ctl1 = MS(rxsp->status1, AR_RxRSSIAnt01);
+-	rxs->rs_rssi_ctl2 = MS(rxsp->status1, AR_RxRSSIAnt02);
+-	rxs->rs_rssi_ext0 = MS(rxsp->status5, AR_RxRSSIAnt10);
+-	rxs->rs_rssi_ext1 = MS(rxsp->status5, AR_RxRSSIAnt11);
+-	rxs->rs_rssi_ext2 = MS(rxsp->status5, AR_RxRSSIAnt12);
++	rxs->rs_rssi_ctl[0] = MS(rxsp->status1, AR_RxRSSIAnt00);
++	rxs->rs_rssi_ctl[1] = MS(rxsp->status1, AR_RxRSSIAnt01);
++	rxs->rs_rssi_ctl[2] = MS(rxsp->status1, AR_RxRSSIAnt02);
++	rxs->rs_rssi_ext[0] = MS(rxsp->status5, AR_RxRSSIAnt10);
++	rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);
++	rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);
+ 
+ 	if (rxsp->status11 & AR_RxKeyIdxValid)
+ 		rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);
+--- a/drivers/net/wireless/ath/ath9k/mac.c
++++ b/drivers/net/wireless/ath/ath9k/mac.c
+@@ -553,25 +553,25 @@ int ath9k_hw_rxprocdesc(struct ath_hw *a
+ 
+ 	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr) {
+ 		rs->rs_rssi = ATH9K_RSSI_BAD;
+-		rs->rs_rssi_ctl0 = ATH9K_RSSI_BAD;
+-		rs->rs_rssi_ctl1 = ATH9K_RSSI_BAD;
+-		rs->rs_rssi_ctl2 = ATH9K_RSSI_BAD;
+-		rs->rs_rssi_ext0 = ATH9K_RSSI_BAD;
+-		rs->rs_rssi_ext1 = ATH9K_RSSI_BAD;
+-		rs->rs_rssi_ext2 = ATH9K_RSSI_BAD;
++		rs->rs_rssi_ctl[0] = ATH9K_RSSI_BAD;
++		rs->rs_rssi_ctl[1] = ATH9K_RSSI_BAD;
++		rs->rs_rssi_ctl[2] = ATH9K_RSSI_BAD;
++		rs->rs_rssi_ext[0] = ATH9K_RSSI_BAD;
++		rs->rs_rssi_ext[1] = ATH9K_RSSI_BAD;
++		rs->rs_rssi_ext[2] = ATH9K_RSSI_BAD;
+ 	} else {
+ 		rs->rs_rssi = MS(ads.ds_rxstatus4, AR_RxRSSICombined);
+-		rs->rs_rssi_ctl0 = MS(ads.ds_rxstatus0,
++		rs->rs_rssi_ctl[0] = MS(ads.ds_rxstatus0,
+ 						AR_RxRSSIAnt00);
+-		rs->rs_rssi_ctl1 = MS(ads.ds_rxstatus0,
++		rs->rs_rssi_ctl[1] = MS(ads.ds_rxstatus0,
+ 						AR_RxRSSIAnt01);
+-		rs->rs_rssi_ctl2 = MS(ads.ds_rxstatus0,
++		rs->rs_rssi_ctl[2] = MS(ads.ds_rxstatus0,
+ 						AR_RxRSSIAnt02);
+-		rs->rs_rssi_ext0 = MS(ads.ds_rxstatus4,
++		rs->rs_rssi_ext[0] = MS(ads.ds_rxstatus4,
+ 						AR_RxRSSIAnt10);
+-		rs->rs_rssi_ext1 = MS(ads.ds_rxstatus4,
++		rs->rs_rssi_ext[1] = MS(ads.ds_rxstatus4,
+ 						AR_RxRSSIAnt11);
+-		rs->rs_rssi_ext2 = MS(ads.ds_rxstatus4,
++		rs->rs_rssi_ext[2] = MS(ads.ds_rxstatus4,
+ 						AR_RxRSSIAnt12);
+ 	}
+ 	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -997,12 +997,12 @@ void ath_debug_stat_rx(struct ath_softc 
+ #ifdef CONFIG_ATH9K_MAC_DEBUG
+ 	spin_lock(&sc->debug.samp_lock);
+ 	RX_SAMP_DBG(jiffies) = jiffies;
+-	RX_SAMP_DBG(rssi_ctl0) = rs->rs_rssi_ctl0;
+-	RX_SAMP_DBG(rssi_ctl1) = rs->rs_rssi_ctl1;
+-	RX_SAMP_DBG(rssi_ctl2) = rs->rs_rssi_ctl2;
+-	RX_SAMP_DBG(rssi_ext0) = rs->rs_rssi_ext0;
+-	RX_SAMP_DBG(rssi_ext1) = rs->rs_rssi_ext1;
+-	RX_SAMP_DBG(rssi_ext2) = rs->rs_rssi_ext2;
++	RX_SAMP_DBG(rssi_ctl0) = rs->rs_rssi_ctl[0];
++	RX_SAMP_DBG(rssi_ctl1) = rs->rs_rssi_ctl[1];
++	RX_SAMP_DBG(rssi_ctl2) = rs->rs_rssi_ctl[2];
++	RX_SAMP_DBG(rssi_ext0) = rs->rs_rssi_ext[0];
++	RX_SAMP_DBG(rssi_ext1) = rs->rs_rssi_ext[1];
++	RX_SAMP_DBG(rssi_ext2) = rs->rs_rssi_ext[2];
+ 	RX_SAMP_DBG(antenna) = rs->rs_antenna;
+ 	RX_SAMP_DBG(rssi) = rs->rs_rssi;
+ 	RX_SAMP_DBG(rate) = rs->rs_rate;
+--- a/include/linux/nl80211.h
++++ b/include/linux/nl80211.h
+@@ -1734,6 +1734,8 @@ enum nl80211_sta_bss_param {
+  * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
+  * @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)
+  * @NL80211_STA_INFO_T_OFFSET: timing offset with respect to this STA (s64)
++ * @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU
++ * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
+  * @__NL80211_STA_INFO_AFTER_LAST: internal
+  * @NL80211_STA_INFO_MAX: highest possible station info attribute
+  */
+@@ -1758,6 +1760,8 @@ enum nl80211_sta_info {
+ 	NL80211_STA_INFO_STA_FLAGS,
+ 	NL80211_STA_INFO_BEACON_LOSS,
+ 	NL80211_STA_INFO_T_OFFSET,
++	NL80211_STA_INFO_CHAIN_SIGNAL,
++	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
+ 
+ 	/* keep last */
+ 	__NL80211_STA_INFO_AFTER_LAST,
+--- a/net/wireless/nl80211.c
++++ b/net/wireless/nl80211.c
+@@ -2745,6 +2745,32 @@ nla_put_failure:
+ 	return false;
+ }
+ 
++static bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,
++			       int id)
++{
++	void *attr;
++	int i = 0;
++
++	if (!mask)
++		return true;
++
++	attr = nla_nest_start(msg, id);
++	if (!attr)
++		return false;
++
++	for (i = 0; i < 4; i++) {
++		if (!(mask & BIT(i)))
++			continue;
++
++		if (nla_put_u8(msg, i, signal[i]))
++			return false;
++	}
++
++	nla_nest_end(msg, attr);
++
++	return true;
++}
++
+ static int nl80211_send_station(struct sk_buff *msg, u32 pid, u32 seq,
+ 				int flags,
+ 				struct cfg80211_registered_device *rdev,
+@@ -2806,6 +2832,18 @@ static int nl80211_send_station(struct s
+ 	default:
+ 		break;
+ 	}
++	if (sinfo->filled & STATION_INFO_CHAIN_SIGNAL) {
++		if (!nl80211_put_signal(msg, sinfo->chains,
++					sinfo->chain_signal,
++					NL80211_STA_INFO_CHAIN_SIGNAL))
++			goto nla_put_failure;
++	}
++	if (sinfo->filled & STATION_INFO_CHAIN_SIGNAL_AVG) {
++		if (!nl80211_put_signal(msg, sinfo->chains,
++					sinfo->chain_signal_avg,
++					NL80211_STA_INFO_CHAIN_SIGNAL_AVG))
++			goto nla_put_failure;
++	}
+ 	if (sinfo->filled & STATION_INFO_TX_BITRATE) {
+ 		if (!nl80211_put_sta_rate(msg, &sinfo->txrate,
+ 					  NL80211_STA_INFO_TX_BITRATE))
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -355,6 +355,7 @@ static void sta_set_sinfo(struct sta_inf
+ 	struct ieee80211_sub_if_data *sdata = sta->sdata;
+ 	struct ieee80211_local *local = sdata->local;
+ 	struct timespec uptime;
++	int i;
+ 
+ 	sinfo->generation = sdata->local->sta_generation;
+ 
+@@ -394,6 +395,17 @@ static void sta_set_sinfo(struct sta_inf
+ 			sinfo->signal = (s8)sta->last_signal;
+ 		sinfo->signal_avg = (s8) -ewma_read(&sta->avg_signal);
+ 	}
++	if (sta->chains) {
++		sinfo->filled |= STATION_INFO_CHAIN_SIGNAL |
++				 STATION_INFO_CHAIN_SIGNAL_AVG;
++
++		sinfo->chains = sta->chains;
++		for (i = 0; i < ARRAY_SIZE(sinfo->chain_signal); i++) {
++			sinfo->chain_signal[i] = sta->chain_signal_last[i];
++			sinfo->chain_signal_avg[i] =
++				(s8) -ewma_read(&sta->chain_signal_avg[i]);
++		}
++	}
+ 
+ 	sta_set_rate_info_tx(sta, &sta->last_tx_rate, &sinfo->txrate);
+ 
+--- a/drivers/net/wireless/ath/ath9k/dfs.c
++++ b/drivers/net/wireless/ath/ath9k/dfs.c
+@@ -164,8 +164,8 @@ void ath9k_dfs_process_phyerr(struct ath
+ 		return;
+ 	}
+ 
+-	ard.rssi = rs->rs_rssi_ctl0;
+-	ard.ext_rssi = rs->rs_rssi_ext0;
++	ard.rssi = rs->rs_rssi_ctl[0];
++	ard.ext_rssi = rs->rs_rssi_ext[0];
+ 
+ 	/*
+ 	 * hardware stores this as 8 bit signed value.
+--- a/drivers/net/wireless/ath/ath9k/antenna.c
++++ b/drivers/net/wireless/ath/ath9k/antenna.c
+@@ -529,14 +529,14 @@ void ath_ant_comb_scan(struct ath_softc 
+ 	struct ath_ant_comb *antcomb = &sc->ant_comb;
+ 	int alt_ratio = 0, alt_rssi_avg = 0, main_rssi_avg = 0, curr_alt_set;
+ 	int curr_main_set;
+-	int main_rssi = rs->rs_rssi_ctl0;
+-	int alt_rssi = rs->rs_rssi_ctl1;
++	int main_rssi = rs->rs_rssi_ctl[0];
++	int alt_rssi = rs->rs_rssi_ctl[1];
+ 	int rx_ant_conf,  main_ant_conf;
+ 	bool short_scan = false;
+ 
+-	rx_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_CURRENT_SHIFT) &
++	rx_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_CURRENT_SHIFT) &
+ 		       ATH_ANT_RX_MASK;
+-	main_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_MAIN_SHIFT) &
++	main_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_MAIN_SHIFT) &
+ 			 ATH_ANT_RX_MASK;
+ 
+ 	/* Record packet only when both main_rssi and  alt_rssi is positive */
diff '--exclude=.svn' -Nur package/mac80211/patches/522-mac80211_reduce_txqueuelen.patch ../openwrt-trunk/package/mac80211/patches/522-mac80211_reduce_txqueuelen.patch
--- package/mac80211/patches/522-mac80211_reduce_txqueuelen.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/522-mac80211_reduce_txqueuelen.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,10 +0,0 @@
---- a/net/mac80211/iface.c
-+++ b/net/mac80211/iface.c
-@@ -686,6 +686,7 @@ static const struct net_device_ops ieee8
- static void ieee80211_if_setup(struct net_device *dev)
- {
- 	ether_setup(dev);
-+	dev->tx_queue_len = 32;
- 	dev->priv_flags &= ~IFF_TX_SKB_SHARING;
- 	netdev_attach_ops(dev, &ieee80211_dataif_ops);
- #if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,29))
diff '--exclude=.svn' -Nur package/mac80211/patches/530-ath9k_fix_initvals.patch ../openwrt-trunk/package/mac80211/patches/530-ath9k_fix_initvals.patch
--- package/mac80211/patches/530-ath9k_fix_initvals.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/530-ath9k_fix_initvals.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,208 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
+@@ -534,108 +534,108 @@ static const u32 ar9300_2p2_baseband_cor
+ 
+ static const u32 ar9300Modes_high_power_tx_gain_table_2p2[][5] = {
+ 	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
+-	{0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+-	{0x0000a2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+-	{0x0000a2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
++	{0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
++	{0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
++	{0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ 	{0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+-	{0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
+-	{0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+-	{0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
+-	{0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
+-	{0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
+-	{0x0000a510, 0x15000028, 0x15000028, 0x0f000202, 0x0f000202},
+-	{0x0000a514, 0x1b00002b, 0x1b00002b, 0x12000400, 0x12000400},
+-	{0x0000a518, 0x1f020028, 0x1f020028, 0x16000402, 0x16000402},
+-	{0x0000a51c, 0x2502002b, 0x2502002b, 0x19000404, 0x19000404},
+-	{0x0000a520, 0x2a04002a, 0x2a04002a, 0x1c000603, 0x1c000603},
+-	{0x0000a524, 0x2e06002a, 0x2e06002a, 0x21000a02, 0x21000a02},
+-	{0x0000a528, 0x3302202d, 0x3302202d, 0x25000a04, 0x25000a04},
+-	{0x0000a52c, 0x3804202c, 0x3804202c, 0x28000a20, 0x28000a20},
+-	{0x0000a530, 0x3c06202c, 0x3c06202c, 0x2c000e20, 0x2c000e20},
+-	{0x0000a534, 0x4108202d, 0x4108202d, 0x30000e22, 0x30000e22},
+-	{0x0000a538, 0x4506402d, 0x4506402d, 0x34000e24, 0x34000e24},
+-	{0x0000a53c, 0x4906222d, 0x4906222d, 0x38001640, 0x38001640},
+-	{0x0000a540, 0x4d062231, 0x4d062231, 0x3c001660, 0x3c001660},
+-	{0x0000a544, 0x50082231, 0x50082231, 0x3f001861, 0x3f001861},
+-	{0x0000a548, 0x5608422e, 0x5608422e, 0x43001a81, 0x43001a81},
+-	{0x0000a54c, 0x5a08442e, 0x5a08442e, 0x47001a83, 0x47001a83},
+-	{0x0000a550, 0x5e0a4431, 0x5e0a4431, 0x4a001c84, 0x4a001c84},
+-	{0x0000a554, 0x640a4432, 0x640a4432, 0x4e001ce3, 0x4e001ce3},
+-	{0x0000a558, 0x680a4434, 0x680a4434, 0x52001ce5, 0x52001ce5},
+-	{0x0000a55c, 0x6c0a6434, 0x6c0a6434, 0x56001ce9, 0x56001ce9},
+-	{0x0000a560, 0x6f0a6633, 0x6f0a6633, 0x5a001ceb, 0x5a001ceb},
+-	{0x0000a564, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a568, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a56c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a570, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a574, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a578, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a57c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
+-	{0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
+-	{0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
+-	{0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
+-	{0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
+-	{0x0000a590, 0x15800028, 0x15800028, 0x0f800202, 0x0f800202},
+-	{0x0000a594, 0x1b80002b, 0x1b80002b, 0x12800400, 0x12800400},
+-	{0x0000a598, 0x1f820028, 0x1f820028, 0x16800402, 0x16800402},
+-	{0x0000a59c, 0x2582002b, 0x2582002b, 0x19800404, 0x19800404},
+-	{0x0000a5a0, 0x2a84002a, 0x2a84002a, 0x1c800603, 0x1c800603},
+-	{0x0000a5a4, 0x2e86002a, 0x2e86002a, 0x21800a02, 0x21800a02},
+-	{0x0000a5a8, 0x3382202d, 0x3382202d, 0x25800a04, 0x25800a04},
+-	{0x0000a5ac, 0x3884202c, 0x3884202c, 0x28800a20, 0x28800a20},
+-	{0x0000a5b0, 0x3c86202c, 0x3c86202c, 0x2c800e20, 0x2c800e20},
+-	{0x0000a5b4, 0x4188202d, 0x4188202d, 0x30800e22, 0x30800e22},
+-	{0x0000a5b8, 0x4586402d, 0x4586402d, 0x34800e24, 0x34800e24},
+-	{0x0000a5bc, 0x4986222d, 0x4986222d, 0x38801640, 0x38801640},
+-	{0x0000a5c0, 0x4d862231, 0x4d862231, 0x3c801660, 0x3c801660},
+-	{0x0000a5c4, 0x50882231, 0x50882231, 0x3f801861, 0x3f801861},
+-	{0x0000a5c8, 0x5688422e, 0x5688422e, 0x43801a81, 0x43801a81},
+-	{0x0000a5cc, 0x5a88442e, 0x5a88442e, 0x47801a83, 0x47801a83},
+-	{0x0000a5d0, 0x5e8a4431, 0x5e8a4431, 0x4a801c84, 0x4a801c84},
+-	{0x0000a5d4, 0x648a4432, 0x648a4432, 0x4e801ce3, 0x4e801ce3},
+-	{0x0000a5d8, 0x688a4434, 0x688a4434, 0x52801ce5, 0x52801ce5},
+-	{0x0000a5dc, 0x6c8a6434, 0x6c8a6434, 0x56801ce9, 0x56801ce9},
+-	{0x0000a5e0, 0x6f8a6633, 0x6f8a6633, 0x5a801ceb, 0x5a801ceb},
+-	{0x0000a5e4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5e8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5ec, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5f0, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5f4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5f8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
+-	{0x0000a5fc, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
++	{0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
++	{0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
++	{0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
++	{0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
++	{0x0000a50c, 0x0d002621, 0x0d002621, 0x0b000200, 0x0b000200},
++	{0x0000a510, 0x13004620, 0x13004620, 0x0f000202, 0x0f000202},
++	{0x0000a514, 0x19004a20, 0x19004a20, 0x11000400, 0x11000400},
++	{0x0000a518, 0x1d004e20, 0x1d004e20, 0x15000402, 0x15000402},
++	{0x0000a51c, 0x21005420, 0x21005420, 0x19000404, 0x19000404},
++	{0x0000a520, 0x26005e20, 0x26005e20, 0x1b000603, 0x1b000603},
++	{0x0000a524, 0x2b005e40, 0x2b005e40, 0x1f000a02, 0x1f000a02},
++	{0x0000a528, 0x2f005e42, 0x2f005e42, 0x23000a04, 0x23000a04},
++	{0x0000a52c, 0x33005e44, 0x33005e44, 0x26000a20, 0x26000a20},
++	{0x0000a530, 0x38005e65, 0x38005e65, 0x2a000e20, 0x2a000e20},
++	{0x0000a534, 0x3c005e69, 0x3c005e69, 0x2e000e22, 0x2e000e22},
++	{0x0000a538, 0x40005e6b, 0x40005e6b, 0x31000e24, 0x31000e24},
++	{0x0000a53c, 0x44005e6d, 0x44005e6d, 0x34001640, 0x34001640},
++	{0x0000a540, 0x49005e72, 0x49005e72, 0x38001660, 0x38001660},
++	{0x0000a544, 0x4e005eb2, 0x4e005eb2, 0x3b001861, 0x3b001861},
++	{0x0000a548, 0x53005f12, 0x53005f12, 0x3e001a81, 0x3e001a81},
++	{0x0000a54c, 0x59025eb2, 0x59025eb2, 0x42001a83, 0x42001a83},
++	{0x0000a550, 0x5e025f12, 0x5e025f12, 0x44001c84, 0x44001c84},
++	{0x0000a554, 0x61027f12, 0x61027f12, 0x48001ce3, 0x48001ce3},
++	{0x0000a558, 0x6702bf12, 0x6702bf12, 0x4c001ce5, 0x4c001ce5},
++	{0x0000a55c, 0x6b02bf14, 0x6b02bf14, 0x50001ce9, 0x50001ce9},
++	{0x0000a560, 0x6f02bf16, 0x6f02bf16, 0x54001ceb, 0x54001ceb},
++	{0x0000a564, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a568, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a56c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a570, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a574, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a578, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a57c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
++	{0x0000a580, 0x00802220, 0x00802220, 0x00800000, 0x00800000},
++	{0x0000a584, 0x04802222, 0x04802222, 0x04800002, 0x04800002},
++	{0x0000a588, 0x09802421, 0x09802421, 0x08800004, 0x08800004},
++	{0x0000a58c, 0x0d802621, 0x0d802621, 0x0b800200, 0x0b800200},
++	{0x0000a590, 0x13804620, 0x13804620, 0x0f800202, 0x0f800202},
++	{0x0000a594, 0x19804a20, 0x19804a20, 0x11800400, 0x11800400},
++	{0x0000a598, 0x1d804e20, 0x1d804e20, 0x15800402, 0x15800402},
++	{0x0000a59c, 0x21805420, 0x21805420, 0x19800404, 0x19800404},
++	{0x0000a5a0, 0x26805e20, 0x26805e20, 0x1b800603, 0x1b800603},
++	{0x0000a5a4, 0x2b805e40, 0x2b805e40, 0x1f800a02, 0x1f800a02},
++	{0x0000a5a8, 0x2f805e42, 0x2f805e42, 0x23800a04, 0x23800a04},
++	{0x0000a5ac, 0x33805e44, 0x33805e44, 0x26800a20, 0x26800a20},
++	{0x0000a5b0, 0x38805e65, 0x38805e65, 0x2a800e20, 0x2a800e20},
++	{0x0000a5b4, 0x3c805e69, 0x3c805e69, 0x2e800e22, 0x2e800e22},
++	{0x0000a5b8, 0x40805e6b, 0x40805e6b, 0x31800e24, 0x31800e24},
++	{0x0000a5bc, 0x44805e6d, 0x44805e6d, 0x34801640, 0x34801640},
++	{0x0000a5c0, 0x49805e72, 0x49805e72, 0x38801660, 0x38801660},
++	{0x0000a5c4, 0x4e805eb2, 0x4e805eb2, 0x3b801861, 0x3b801861},
++	{0x0000a5c8, 0x53805f12, 0x53805f12, 0x3e801a81, 0x3e801a81},
++	{0x0000a5cc, 0x59825eb2, 0x59825eb2, 0x42801a83, 0x42801a83},
++	{0x0000a5d0, 0x5e825f12, 0x5e825f12, 0x44801c84, 0x44801c84},
++	{0x0000a5d4, 0x61827f12, 0x61827f12, 0x48801ce3, 0x48801ce3},
++	{0x0000a5d8, 0x6782bf12, 0x6782bf12, 0x4c801ce5, 0x4c801ce5},
++	{0x0000a5dc, 0x6b82bf14, 0x6b82bf14, 0x50801ce9, 0x50801ce9},
++	{0x0000a5e0, 0x6f82bf16, 0x6f82bf16, 0x54801ceb, 0x54801ceb},
++	{0x0000a5e4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5e8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5ec, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5f0, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5f4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5f8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
++	{0x0000a5fc, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
+ 	{0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+ 	{0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
+-	{0x0000a608, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+-	{0x0000a60c, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+-	{0x0000a610, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
+-	{0x0000a614, 0x01804601, 0x01804601, 0x01404000, 0x01404000},
+-	{0x0000a618, 0x01804601, 0x01804601, 0x01404501, 0x01404501},
+-	{0x0000a61c, 0x01804601, 0x01804601, 0x02008501, 0x02008501},
+-	{0x0000a620, 0x03408d02, 0x03408d02, 0x0280ca03, 0x0280ca03},
+-	{0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
+-	{0x0000a628, 0x03410d04, 0x03410d04, 0x04014c04, 0x04014c04},
+-	{0x0000a62c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a630, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a634, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a638, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000a63c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
+-	{0x0000b2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+-	{0x0000b2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+-	{0x0000b2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
++	{0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
++	{0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
++	{0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
++	{0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
++	{0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
++	{0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
++	{0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
++	{0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
++	{0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
++	{0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
++	{0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
++	{0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ 	{0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+-	{0x0000c2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
+-	{0x0000c2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
+-	{0x0000c2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
++	{0x0000c2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
++	{0x0000c2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
++	{0x0000c2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
+ 	{0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
+-	{0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+-	{0x00016048, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
+-	{0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+-	{0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+-	{0x00016448, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
+-	{0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
+-	{0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
+-	{0x00016848, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
+-	{0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
++	{0x00016044, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
++	{0x00016048, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
++	{0x00016068, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
++	{0x00016444, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
++	{0x00016448, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
++	{0x00016468, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
++	{0x00016844, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
++	{0x00016848, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
++	{0x00016868, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
+ };
+ 
+ static const u32 ar9300Modes_high_ob_db_tx_gain_table_2p2[][5] = {
diff '--exclude=.svn' -Nur package/mac80211/patches/530-mac80211_cur_txpower.patch ../openwrt-trunk/package/mac80211/patches/530-mac80211_cur_txpower.patch
--- package/mac80211/patches/530-mac80211_cur_txpower.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/530-mac80211_cur_txpower.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -816,7 +816,7 @@ enum ieee80211_smps_mode {
-  */
- struct ieee80211_conf {
- 	u32 flags;
--	int power_level, dynamic_ps_timeout;
-+	int cur_power_level, power_level, dynamic_ps_timeout;
- 	int max_sleep_period;
- 
- 	u16 listen_interval;
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -1696,7 +1696,7 @@ static int ieee80211_get_tx_power(struct
- {
- 	struct ieee80211_local *local = wiphy_priv(wiphy);
- 
--	*dbm = local->hw.conf.power_level;
-+	*dbm = local->hw.conf.cur_power_level;
- 
- 	return 0;
- }
---- a/net/mac80211/main.c
-+++ b/net/mac80211/main.c
-@@ -167,6 +167,7 @@ int ieee80211_hw_config(struct ieee80211
- 
- 	if (local->hw.conf.power_level != power) {
- 		changed |= IEEE80211_CONF_CHANGE_POWER;
-+		local->hw.conf.cur_power_level = power;
- 		local->hw.conf.power_level = power;
- 	}
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/531-ath9k_cur_txpower.patch ../openwrt-trunk/package/mac80211/patches/531-ath9k_cur_txpower.patch
--- package/mac80211/patches/531-ath9k_cur_txpower.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/531-ath9k_cur_txpower.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,19 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -1698,6 +1698,8 @@ int ath9k_config(struct ieee80211_hw *hw
- 			return -EINVAL;
- 		}
- 
-+		conf->cur_power_level = sc->curtxpow / 2;
-+
- 		/*
- 		 * The most recent snapshot of channel->noisefloor for the old
- 		 * channel is only available after the hardware reset. Copy it to
-@@ -1713,6 +1715,7 @@ int ath9k_config(struct ieee80211_hw *hw
- 		sc->config.txpowlimit = 2 * conf->power_level;
- 		ath9k_cmn_update_txpow(ah, sc->curtxpow,
- 				       sc->config.txpowlimit, &sc->curtxpow);
-+		conf->cur_power_level = sc->curtxpow / 2;
- 	}
- 
- 	mutex_unlock(&sc->mutex);
diff '--exclude=.svn' -Nur package/mac80211/patches/540-ath9k_extra_leds.patch ../openwrt-trunk/package/mac80211/patches/540-ath9k_extra_leds.patch
--- package/mac80211/patches/540-ath9k_extra_leds.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/540-ath9k_extra_leds.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,258 @@
+--- a/drivers/net/wireless/ath/ath9k/ath9k.h
++++ b/drivers/net/wireless/ath/ath9k/ath9k.h
+@@ -537,6 +537,9 @@ struct ath9k_wow_pattern {
+ #ifdef CONFIG_MAC80211_LEDS
+ void ath_init_leds(struct ath_softc *sc);
+ void ath_deinit_leds(struct ath_softc *sc);
++int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
++                        const char *trigger, bool active_low);
++
+ #else
+ static inline void ath_init_leds(struct ath_softc *sc)
+ {
+@@ -654,6 +657,13 @@ struct ath9k_vif_iter_data {
+ 	int nadhocs;   /* number of adhoc vifs */
+ };
+ 
++struct ath_led {
++	struct list_head list;
++	struct ath_softc *sc;
++	const struct gpio_led *gpio;
++	struct led_classdev cdev;
++};
++
+ struct ath_softc {
+ 	struct ieee80211_hw *hw;
+ 	struct device *dev;
+@@ -695,9 +705,8 @@ struct ath_softc {
+ 	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
+ 
+ #ifdef CONFIG_MAC80211_LEDS
+-	bool led_registered;
+-	char led_name[32];
+-	struct led_classdev led_cdev;
++	const char *led_default_trigger;
++	struct list_head leds;
+ #endif
+ 
+ 	struct ath9k_hw_cal_data caldata;
+--- a/drivers/net/wireless/ath/ath9k/gpio.c
++++ b/drivers/net/wireless/ath/ath9k/gpio.c
+@@ -24,22 +24,89 @@
+ static void ath_led_brightness(struct led_classdev *led_cdev,
+ 			       enum led_brightness brightness)
+ {
+-	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
+-	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, (brightness == LED_OFF));
++	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
++	struct ath_softc *sc = led->sc;
++
++	ath9k_ps_wakeup(sc);
++	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
++			  (brightness != LED_OFF) ^ led->gpio->active_low);
++	ath9k_ps_restore(sc);
++}
++
++static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
++{
++	const struct gpio_led *gpio = led->gpio;
++	int ret;
++
++	led->cdev.name = gpio->name;
++	led->cdev.default_trigger = gpio->default_trigger;
++	led->cdev.brightness_set = ath_led_brightness;
++
++	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
++	if (ret < 0)
++		return ret;
++
++	led->sc = sc;
++	list_add(&led->list, &sc->leds);
++
++	/* Configure gpio for output */
++	ath9k_hw_cfg_output(sc->sc_ah, gpio->gpio,
++			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
++
++	/* LED off */
++	ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
++
++	return 0;
++}
++
++int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
++			const char *trigger, bool active_low)
++{
++	struct ath_led *led;
++	struct gpio_led *gpio;
++	char *_name;
++	int ret;
++
++	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
++		      GFP_KERNEL);
++	if (!led)
++		return -ENOMEM;
++
++	led->gpio = gpio = (struct gpio_led *) (led + 1);
++	_name = (char *) (led->gpio + 1);
++
++	strcpy(_name, name);
++	gpio->name = _name;
++	gpio->gpio = gpio_num;
++	gpio->active_low = active_low;
++	gpio->default_trigger = trigger;
++
++	ret = ath_add_led(sc, led);
++	if (unlikely(ret < 0))
++		kfree(led);
++
++	return ret;
+ }
+ 
+ void ath_deinit_leds(struct ath_softc *sc)
+ {
+-	if (!sc->led_registered)
+-		return;
++	struct ath_led *led;
+ 
+-	ath_led_brightness(&sc->led_cdev, LED_OFF);
+-	led_classdev_unregister(&sc->led_cdev);
++	while (!list_empty(&sc->leds)) {
++		led = list_first_entry(&sc->leds, struct ath_led, list);
++		list_del(&led->list);
++		ath_led_brightness(&led->cdev, LED_OFF);
++		led_classdev_unregister(&led->cdev);
++		kfree(led);
++	}
+ }
+ 
+ void ath_init_leds(struct ath_softc *sc)
+ {
+-	int ret;
++	char led_name[32];
++	const char *trigger;
++
++	INIT_LIST_HEAD(&sc->leds);
+ 
+ 	if (AR_SREV_9100(sc->sc_ah))
+ 		return;
+@@ -57,26 +124,15 @@ void ath_init_leds(struct ath_softc *sc)
+ 			sc->sc_ah->led_pin = ATH_LED_PIN_DEF;
+ 	}
+ 
+-	/* Configure gpio 1 for output */
+-	ath9k_hw_cfg_output(sc->sc_ah, sc->sc_ah->led_pin,
+-			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
+-	/* LED off, active low */
+-	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, 1);
+-
+-	if (!led_blink)
+-		sc->led_cdev.default_trigger =
+-			ieee80211_get_radio_led_name(sc->hw);
+-
+-	snprintf(sc->led_name, sizeof(sc->led_name),
+-		"ath9k-%s", wiphy_name(sc->hw->wiphy));
+-	sc->led_cdev.name = sc->led_name;
+-	sc->led_cdev.brightness_set = ath_led_brightness;
++	snprintf(led_name, sizeof(led_name), "ath9k-%s",
++		 wiphy_name(sc->hw->wiphy));
+ 
+-	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
+-	if (ret < 0)
+-		return;
++	if (led_blink)
++		trigger = sc->led_default_trigger;
++	else
++		trigger = ieee80211_get_radio_led_name(sc->hw);
+ 
+-	sc->led_registered = true;
++	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
+ }
+ #endif
+ 
+--- a/drivers/net/wireless/ath/ath9k/init.c
++++ b/drivers/net/wireless/ath/ath9k/init.c
+@@ -811,7 +811,7 @@ int ath9k_init_device(u16 devid, struct 
+ 
+ #ifdef CONFIG_MAC80211_LEDS
+ 	/* must be initialized before ieee80211_register_hw */
+-	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
++	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
+ 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
+ 		ARRAY_SIZE(ath9k_tpt_blink));
+ #endif
+--- a/drivers/net/wireless/ath/ath9k/debug.c
++++ b/drivers/net/wireless/ath/ath9k/debug.c
+@@ -1255,6 +1255,61 @@ static const struct file_operations fops
+ 	.llseek = default_llseek,
+ };
+ 
++#ifdef CONFIG_MAC80211_LEDS
++
++static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
++				   size_t count, loff_t *ppos)
++{
++	struct ath_softc *sc = file->private_data;
++	char buf[32], *str, *name, *c;
++	ssize_t len;
++	unsigned int gpio;
++	bool active_low = false;
++
++	len = min(count, sizeof(buf) - 1);
++	if (copy_from_user(buf, ubuf, len))
++		return -EFAULT;
++
++	buf[len] = '\0';
++	name = strchr(buf, ',');
++	if (!name)
++		return -EINVAL;
++
++	*(name++) = 0;
++	if (!*name)
++		return -EINVAL;
++
++	c = strchr(name, '\n');
++	if (c)
++		*c = 0;
++
++	str = buf;
++	if (*str == '!') {
++		str++;
++		active_low = true;
++	}
++
++	if (kstrtouint(str, 0, &gpio) < 0)
++		return -EINVAL;
++
++	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
++		return -EINVAL;
++
++	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
++		return -EINVAL;
++
++	return count;
++}
++
++static const struct file_operations fops_gpio_led = {
++	.write = write_file_gpio_led,
++	.open = simple_open,
++	.owner = THIS_MODULE,
++	.llseek = default_llseek,
++};
++
++#endif
++
+ #ifdef CONFIG_ATH9K_MAC_DEBUG
+ 
+ void ath9k_debug_samp_bb_mac(struct ath_softc *sc)
+@@ -1688,6 +1743,11 @@ int ath9k_init_debug(struct ath_hw *ah)
+ 			    &fops_samps);
+ #endif
+ 
++#ifdef CONFIG_MAC80211_LEDS
++	debugfs_create_file("gpio_led", S_IWUSR,
++			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
++#endif
++
+ 	debugfs_create_u32("gpio_mask", S_IRUSR | S_IWUSR,
+ 			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/540-ath9k_limit_qlen.patch ../openwrt-trunk/package/mac80211/patches/540-ath9k_limit_qlen.patch
--- package/mac80211/patches/540-ath9k_limit_qlen.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/540-ath9k_limit_qlen.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,144 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -238,6 +238,7 @@ struct ath_atx_tid {
- 	struct ath_node *an;
- 	struct ath_atx_ac *ac;
- 	unsigned long tx_buf[BITS_TO_LONGS(ATH_TID_MAX_BUFS)];
-+	int buf_pending;
- 	u16 seq_start;
- 	u16 seq_next;
- 	u16 baw_size;
-@@ -284,6 +285,9 @@ struct ath_tx_control {
-  *  (axq_qnum).
-  */
- struct ath_tx {
-+	u32 qlen_single;
-+	u32 qlen_aggr;
-+
- 	u16 seq_no;
- 	u32 txqsetup;
- 	spinlock_t txbuflock;
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1729,6 +1729,10 @@ int ath9k_init_debug(struct ath_hw *ah)
- 			    sc, &fops_wiphy);
- 	debugfs_create_file("xmit", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_xmit);
-+	debugfs_create_u32("qlen_single", S_IRUSR | S_IWUSR,
-+			   sc->debug.debugfs_phy, &sc->tx.qlen_single);
-+	debugfs_create_u32("qlen_aggr", S_IRUSR | S_IWUSR,
-+			   sc->debug.debugfs_phy, &sc->tx.qlen_aggr);
- 	debugfs_create_file("stations", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_stations);
- 	debugfs_create_file("misc", S_IRUSR, sc->debug.debugfs_phy, sc,
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -355,6 +355,14 @@ static void ath_tx_count_frames(struct a
- 	}
- }
- 
-+static struct ath_atx_tid *ath_get_tid(struct ath_node *an, struct sk_buff *skb)
-+{
-+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-+	u8 tidno;
-+
-+	tidno = ieee80211_get_qos_ctl(hdr)[0] & IEEE80211_QOS_CTL_TID_MASK;
-+	return ATH_AN_2_TID(an, tidno);
-+}
- 
- static void ath_tx_complete_aggr(struct ath_softc *sc, struct ath_txq *txq,
- 				 struct ath_buf *bf, struct list_head *bf_q,
-@@ -443,6 +451,8 @@ static void ath_tx_complete_aggr(struct 
- 	__skb_queue_head_init(&bf_pending);
- 
- 	ath_tx_count_frames(sc, bf, ts, txok, &nframes, &nbad);
-+	tid->buf_pending -= nframes;
-+
- 	while (bf) {
- 		u16 seqno = bf->bf_state.seqno;
- 
-@@ -823,6 +833,7 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- 			ath_tx_addto_baw(sc, tid, seqno);
- 		bf->bf_state.ndelim = ndelim;
- 
-+		tid->buf_pending++;
- 		__skb_unlink(skb, &tid->buf_q);
- 		list_add_tail(&bf->list, bf_q);
- 		if (bf_prev)
-@@ -1682,6 +1693,8 @@ static void ath_tx_send_ampdu(struct ath
- 	/* Add sub-frame to BAW */
- 	ath_tx_addto_baw(sc, tid, bf->bf_state.seqno);
- 
-+	tid->buf_pending++;
-+
- 	/* Queue to h/w without aggregation */
- 	TX_STAT_INC(txctl->txq->axq_qnum, a_queued_hw);
- 	bf->bf_lastbf = bf;
-@@ -1810,23 +1823,13 @@ error:
- 
- /* FIXME: tx power */
- static void ath_tx_start_dma(struct ath_softc *sc, struct sk_buff *skb,
--			     struct ath_tx_control *txctl)
-+			     struct ath_tx_control *txctl,
-+			     struct ath_atx_tid *tid)
- {
- 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
--	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
--	struct ath_atx_tid *tid = NULL;
- 	struct ath_buf *bf;
--	u8 tidno;
- 
- 	spin_lock_bh(&txctl->txq->axq_lock);
--	if ((sc->sc_flags & SC_OP_TXAGGR) && txctl->an &&
--		ieee80211_is_data_qos(hdr->frame_control)) {
--		tidno = ieee80211_get_qos_ctl(hdr)[0] &
--			IEEE80211_QOS_CTL_TID_MASK;
--		tid = ATH_AN_2_TID(txctl->an, tidno);
--
--		WARN_ON(tid->ac->txq != txctl->txq);
--	}
- 
- 	if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && tid) {
- 		/*
-@@ -1861,6 +1864,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	struct ieee80211_vif *vif = info->control.vif;
- 	struct ath_softc *sc = hw->priv;
- 	struct ath_txq *txq = txctl->txq;
-+	struct ath_atx_tid *tid = NULL;
- 	int padpos, padsize;
- 	int frmlen = skb->len + FCS_LEN;
- 	int q;
-@@ -1903,6 +1907,24 @@ int ath_tx_start(struct ieee80211_hw *hw
- 
- 	setup_frame_info(hw, skb, frmlen);
- 
-+	if ((sc->sc_flags & SC_OP_TXAGGR) && txctl->an &&
-+	    ieee80211_is_data_qos(hdr->frame_control)) {
-+		tid = ath_get_tid(txctl->an, skb);
-+
-+		WARN_ON(tid->ac->txq != txq);
-+	}
-+
-+	if ((info->flags & IEEE80211_TX_CTL_AMPDU) && tid) {
-+		if (sc->tx.qlen_aggr > 0 && skb_queue_len(&tid->buf_q) +
-+		    tid->buf_pending >= sc->tx.qlen_aggr)
-+			return -ENOMEM;
-+	} else {
-+		if (sc->tx.qlen_single > 0 &&
-+		    txq->axq_depth - txq->axq_ampdu_depth >=
-+		      sc->tx.qlen_single)
-+			return -ENOMEM;
-+	}
-+
- 	/*
- 	 * At this point, the vif, hw_key and sta pointers in the tx control
- 	 * info are no longer valid (overwritten by the ath_frame_info data.
-@@ -1917,7 +1939,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	}
- 	spin_unlock_bh(&txq->axq_lock);
- 
--	ath_tx_start_dma(sc, skb, txctl);
-+	ath_tx_start_dma(sc, skb, txctl, tid);
- 	return 0;
- }
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/541-ath9k_extra_platform_leds.patch ../openwrt-trunk/package/mac80211/patches/541-ath9k_extra_platform_leds.patch
--- package/mac80211/patches/541-ath9k_extra_platform_leds.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/541-ath9k_extra_platform_leds.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,71 @@
+--- a/include/linux/ath9k_platform.h
++++ b/include/linux/ath9k_platform.h
+@@ -33,6 +33,9 @@ struct ath9k_platform_data {
+ 	bool is_clk_25mhz;
+ 	int (*get_mac_revision)(void);
+ 	int (*external_reset)(void);
++
++	int num_leds;
++	const struct gpio_led *leds;
+ };
+ 
+ #endif /* _LINUX_ATH9K_PLATFORM_H */
+--- a/drivers/net/wireless/ath/ath9k/gpio.c
++++ b/drivers/net/wireless/ath/ath9k/gpio.c
+@@ -14,6 +14,7 @@
+  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+  */
+ 
++#include <linux/ath9k_platform.h>
+ #include "ath9k.h"
+ 
+ /********************************/
+@@ -88,6 +89,24 @@ int ath_create_gpio_led(struct ath_softc
+ 	return ret;
+ }
+ 
++static int ath_create_platform_led(struct ath_softc *sc,
++				   const struct gpio_led *gpio)
++{
++	struct ath_led *led;
++	int ret;
++
++	led = kzalloc(sizeof(*led), GFP_KERNEL);
++	if (!led)
++		return -ENOMEM;
++
++	led->gpio = gpio;
++	ret = ath_add_led(sc, led);
++	if (ret < 0)
++		kfree(led);
++
++	return ret;
++}
++
+ void ath_deinit_leds(struct ath_softc *sc)
+ {
+ 	struct ath_led *led;
+@@ -103,8 +122,10 @@ void ath_deinit_leds(struct ath_softc *s
+ 
+ void ath_init_leds(struct ath_softc *sc)
+ {
++	struct ath9k_platform_data *pdata = sc->dev->platform_data;
+ 	char led_name[32];
+ 	const char *trigger;
++	int i;
+ 
+ 	INIT_LIST_HEAD(&sc->leds);
+ 
+@@ -133,6 +154,12 @@ void ath_init_leds(struct ath_softc *sc)
+ 		trigger = ieee80211_get_radio_led_name(sc->hw);
+ 
+ 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
++
++	if (!pdata)
++		return;
++
++	for (i = 0; i < pdata->num_leds; i++)
++		ath_create_platform_led(sc, &pdata->leds[i]);
+ }
+ #endif
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/541-ath9k_sw_retry_reduce.patch ../openwrt-trunk/package/mac80211/patches/541-ath9k_sw_retry_reduce.patch
--- package/mac80211/patches/541-ath9k_sw_retry_reduce.patch	2012-08-17 15:40:46.481971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/541-ath9k_sw_retry_reduce.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,62 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -264,14 +264,17 @@ static void ath_tid_drain(struct ath_sof
- }
- 
- static void ath_tx_set_retry(struct ath_softc *sc, struct ath_txq *txq,
--			     struct sk_buff *skb)
-+			     struct sk_buff *skb, int count)
- {
- 	struct ath_frame_info *fi = get_frame_info(skb);
- 	struct ath_buf *bf = fi->bf;
- 	struct ieee80211_hdr *hdr;
-+	int prev = fi->retries;
- 
- 	TX_STAT_INC(txq->axq_qnum, a_retries);
--	if (fi->retries++ > 0)
-+	fi->retries += count;
-+
-+	if (prev > 0)
- 		return;
- 
- 	hdr = (struct ieee80211_hdr *)skb->data;
-@@ -387,6 +390,7 @@ static void ath_tx_complete_aggr(struct 
- 	int nframes;
- 	u8 tidno;
- 	bool flush = !!(ts->ts_status & ATH9K_TX_FLUSH);
-+	int i, retries;
- 
- 	skb = bf->bf_mpdu;
- 	hdr = (struct ieee80211_hdr *)skb->data;
-@@ -395,6 +399,10 @@ static void ath_tx_complete_aggr(struct 
- 
- 	memcpy(rates, tx_info->control.rates, sizeof(rates));
- 
-+	retries = ts->ts_longretry + 1;
-+	for (i = 0; i < ts->ts_rateindex; i++)
-+		retries += rates[i].count;
-+
- 	rcu_read_lock();
- 
- 	sta = ieee80211_find_sta_by_ifaddr(hw, hdr->addr1, hdr->addr2);
-@@ -481,7 +489,8 @@ static void ath_tx_complete_aggr(struct 
- 				txpending = 1;
- 			} else if (fi->retries < ATH_MAX_SW_RETRIES) {
- 				if (txok || !an->sleeping)
--					ath_tx_set_retry(sc, txq, bf->bf_mpdu);
-+					ath_tx_set_retry(sc, txq, bf->bf_mpdu,
-+							 retries);
- 
- 				txpending = 1;
- 			} else {
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -546,7 +546,7 @@ struct ath_ant_comb {
- #define DEFAULT_CACHELINE       32
- #define ATH_REGCLASSIDS_MAX     10
- #define ATH_CABQ_READY_TIME     80      /* % of beacon interval */
--#define ATH_MAX_SW_RETRIES      10
-+#define ATH_MAX_SW_RETRIES      20
- #define ATH_CHAN_MAX            255
- 
- #define ATH_TXPOWER_MAX         100     /* .5 dBm units */
diff '--exclude=.svn' -Nur package/mac80211/patches/542-ath9k_ar9280_cold_reset.patch ../openwrt-trunk/package/mac80211/patches/542-ath9k_ar9280_cold_reset.patch
--- package/mac80211/patches/542-ath9k_ar9280_cold_reset.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/542-ath9k_ar9280_cold_reset.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,23 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1394,10 +1394,16 @@ static bool ath9k_hw_set_reset_reg(struc
- static bool ath9k_hw_chip_reset(struct ath_hw *ah,
- 				struct ath9k_channel *chan)
- {
--	if (AR_SREV_9280(ah) && ah->eep_ops->get_eeprom(ah, EEP_OL_PWRCTRL)) {
--		if (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_POWER_ON))
--			return false;
--	} else if (!ath9k_hw_set_reset_reg(ah, ATH9K_RESET_WARM))
-+	int reset_type = ATH9K_RESET_WARM;
-+
-+	if (AR_SREV_9280(ah)) {
-+		if (ah->eep_ops->get_eeprom(ah, EEP_OL_PWRCTRL))
-+			reset_type = ATH9K_RESET_POWER_ON;
-+		else
-+			reset_type = ATH9K_RESET_COLD;
-+	}
-+
-+	if (!ath9k_hw_set_reset_reg(ah, reset_type))
- 		return false;
- 
- 	if (!ath9k_hw_setpower(ah, ATH9K_PM_AWAKE))
diff '--exclude=.svn' -Nur package/mac80211/patches/543-ath9k_fix_half_quarter_rx_latency.patch ../openwrt-trunk/package/mac80211/patches/543-ath9k_fix_half_quarter_rx_latency.patch
--- package/mac80211/patches/543-ath9k_fix_half_quarter_rx_latency.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/543-ath9k_fix_half_quarter_rx_latency.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1006,16 +1006,26 @@ void ath9k_hw_init_global_settings(struc
- 
- 	if (IS_CHAN_HALF_RATE(chan)) {
- 		eifs = 175;
--		rx_lat *= 2;
-+
-+		if (!AR_SREV_9300_20_OR_LATER(ah))
-+			rx_lat = 10;
-+		else
-+			rx_lat *= 2;
-+
- 		tx_lat *= 2;
- 		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
--		    tx_lat += 11;
-+			tx_lat += 11;
- 
- 		slottime = 13;
- 		sifstime = 32;
- 	} else if (IS_CHAN_QUARTER_RATE(chan)) {
- 		eifs = 340;
--		rx_lat = (rx_lat * 4) - 1;
-+
-+		if (!AR_SREV_9300_20_OR_LATER(ah))
-+			rx_lat = 20;
-+		else
-+			rx_lat = (rx_lat * 4) - 1;
-+
- 		tx_lat *= 4;
- 		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 		    tx_lat += 22;
diff '--exclude=.svn' -Nur package/mac80211/patches/544-ath9k_fix_half_quarter_sifs.patch ../openwrt-trunk/package/mac80211/patches/544-ath9k_fix_half_quarter_sifs.patch
--- package/mac80211/patches/544-ath9k_fix_half_quarter_sifs.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/544-ath9k_fix_half_quarter_sifs.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,44 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1007,31 +1007,35 @@ void ath9k_hw_init_global_settings(struc
- 	if (IS_CHAN_HALF_RATE(chan)) {
- 		eifs = 175;
- 
--		if (!AR_SREV_9300_20_OR_LATER(ah))
-+		if (!AR_SREV_9300_20_OR_LATER(ah)) {
- 			rx_lat = 10;
--		else
-+			sifstime = 8;
-+		} else {
- 			rx_lat *= 2;
-+			sifstime = 32;
-+		}
- 
- 		tx_lat *= 2;
- 		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 			tx_lat += 11;
- 
- 		slottime = 13;
--		sifstime = 32;
- 	} else if (IS_CHAN_QUARTER_RATE(chan)) {
- 		eifs = 340;
- 
--		if (!AR_SREV_9300_20_OR_LATER(ah))
-+		if (!AR_SREV_9300_20_OR_LATER(ah)) {
- 			rx_lat = 20;
--		else
-+			sifstime = 8;
-+		} else {
- 			rx_lat = (rx_lat * 4) - 1;
-+			sifstime = 64;
-+		}
- 
- 		tx_lat *= 4;
- 		if (IS_CHAN_A_FAST_CLOCK(ah, chan))
- 		    tx_lat += 22;
- 
- 		slottime = 21;
--		sifstime = 64;
- 	} else {
- 		if (AR_SREV_9287(ah) && AR_SREV_9287_13_OR_LATER(ah)) {
- 			eifs = AR_D_GBL_IFS_EIFS_ASYNC_FIFO;
diff '--exclude=.svn' -Nur package/mac80211/patches/550-ath9k_debug_remove_packet_rssi.patch ../openwrt-trunk/package/mac80211/patches/550-ath9k_debug_remove_packet_rssi.patch
--- package/mac80211/patches/550-ath9k_debug_remove_packet_rssi.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/550-ath9k_debug_remove_packet_rssi.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,70 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -969,34 +969,6 @@ static ssize_t read_file_recv(struct fil
- 			"%18s : %10u\n", "DECRYPT BUSY ERR",
- 			sc->debug.stats.rxstats.decrypt_busy_err);
- 
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "RSSI-CTL0",
--			sc->debug.stats.rxstats.rs_rssi_ctl0);
--
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "RSSI-CTL1",
--			sc->debug.stats.rxstats.rs_rssi_ctl1);
--
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "RSSI-CTL2",
--			sc->debug.stats.rxstats.rs_rssi_ctl2);
--
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "RSSI-EXT0",
--			sc->debug.stats.rxstats.rs_rssi_ext0);
--
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "RSSI-EXT1",
--			sc->debug.stats.rxstats.rs_rssi_ext1);
--
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "RSSI-EXT2",
--			sc->debug.stats.rxstats.rs_rssi_ext2);
--
--	len += snprintf(buf + len, size - len,
--			"%18s : %10d\n", "Rx Antenna",
--			sc->debug.stats.rxstats.rs_antenna);
--
- 	PHY_ERR("UNDERRUN", ATH9K_PHYERR_UNDERRUN);
- 	PHY_ERR("TIMING", ATH9K_PHYERR_TIMING);
- 	PHY_ERR("PARITY", ATH9K_PHYERR_PARITY);
-@@ -1073,16 +1045,6 @@ void ath_debug_stat_rx(struct ath_softc 
- 		RX_PHY_ERR_INC(phyerr);
- 	}
- 
--	sc->debug.stats.rxstats.rs_rssi_ctl0 = rs->rs_rssi_ctl0;
--	sc->debug.stats.rxstats.rs_rssi_ctl1 = rs->rs_rssi_ctl1;
--	sc->debug.stats.rxstats.rs_rssi_ctl2 = rs->rs_rssi_ctl2;
--
--	sc->debug.stats.rxstats.rs_rssi_ext0 = rs->rs_rssi_ext0;
--	sc->debug.stats.rxstats.rs_rssi_ext1 = rs->rs_rssi_ext1;
--	sc->debug.stats.rxstats.rs_rssi_ext2 = rs->rs_rssi_ext2;
--
--	sc->debug.stats.rxstats.rs_antenna = rs->rs_antenna;
--
- 	spin_lock(&sc->debug.samp_lock);
- 	RX_SAMP_DBG(jiffies) = jiffies;
- 	RX_SAMP_DBG(rssi_ctl0) = rs->rs_rssi_ctl0;
---- a/drivers/net/wireless/ath/ath9k/debug.h
-+++ b/drivers/net/wireless/ath/ath9k/debug.h
-@@ -164,13 +164,6 @@ struct ath_rx_stats {
- 	u32 post_delim_crc_err;
- 	u32 decrypt_busy_err;
- 	u32 phy_err_stats[ATH9K_PHYERR_MAX];
--	int8_t rs_rssi_ctl0;
--	int8_t rs_rssi_ctl1;
--	int8_t rs_rssi_ctl2;
--	int8_t rs_rssi_ext0;
--	int8_t rs_rssi_ext1;
--	int8_t rs_rssi_ext2;
--	u8 rs_antenna;
- };
- 
- enum ath_reset_type {
diff '--exclude=.svn' -Nur package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch ../openwrt-trunk/package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch
--- package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/550-mac80211_optimize_mcs_rate_mask.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,98 @@
+--- a/net/mac80211/ieee80211_i.h
++++ b/net/mac80211/ieee80211_i.h
+@@ -710,6 +710,8 @@ struct ieee80211_sub_if_data {
+ 
+ 	/* bitmap of allowed (non-MCS) rate indexes for rate control */
+ 	u32 rc_rateidx_mask[IEEE80211_NUM_BANDS];
++
++	bool rc_has_mcs_mask[IEEE80211_NUM_BANDS];
+ 	u8  rc_rateidx_mcs_mask[IEEE80211_NUM_BANDS][IEEE80211_HT_MCS_MASK_LEN];
+ 
+ 	union {
+--- a/net/mac80211/cfg.c
++++ b/net/mac80211/cfg.c
+@@ -2136,9 +2136,20 @@ static int ieee80211_set_bitrate_mask(st
+ 	}
+ 
+ 	for (i = 0; i < IEEE80211_NUM_BANDS; i++) {
++		struct ieee80211_supported_band *sband = wiphy->bands[i];
++
+ 		sdata->rc_rateidx_mask[i] = mask->control[i].legacy;
+ 		memcpy(sdata->rc_rateidx_mcs_mask[i], mask->control[i].mcs,
+ 		       sizeof(mask->control[i].mcs));
++
++		sdata->rc_has_mcs_mask[i] = false;
++		if (!sband)
++			continue;
++
++		if (memcmp(sdata->rc_rateidx_mcs_mask[i],
++			   sband->ht_cap.mcs.rx_mask,
++			   sizeof(sband->ht_cap.mcs.rx_mask)) != 0)
++			sdata->rc_has_mcs_mask[i] = true;
+ 	}
+ 
+ 	return 0;
+--- a/include/net/mac80211.h
++++ b/include/net/mac80211.h
+@@ -3670,7 +3670,7 @@ void ieee80211_send_bar(struct ieee80211
+  *	(deprecated; this will be removed once drivers get updated to use
+  *	rate_idx_mask)
+  * @rate_idx_mask: user-requested (legacy) rate mask
+- * @rate_idx_mcs_mask: user-requested MCS rate mask
++ * @rate_idx_mcs_mask: user-requested MCS rate mask (NULL if not in use)
+  * @bss: whether this frame is sent out in AP or IBSS mode
+  */
+ struct ieee80211_tx_rate_control {
+@@ -3682,7 +3682,7 @@ struct ieee80211_tx_rate_control {
+ 	bool rts, short_preamble;
+ 	u8 max_rate_idx;
+ 	u32 rate_idx_mask;
+-	u8 rate_idx_mcs_mask[IEEE80211_HT_MCS_MASK_LEN];
++	u8 *rate_idx_mcs_mask;
+ 	bool bss;
+ };
+ 
+--- a/net/mac80211/tx.c
++++ b/net/mac80211/tx.c
+@@ -631,9 +631,11 @@ ieee80211_tx_h_rate_ctrl(struct ieee8021
+ 		txrc.max_rate_idx = -1;
+ 	else
+ 		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
+-	memcpy(txrc.rate_idx_mcs_mask,
+-	       tx->sdata->rc_rateidx_mcs_mask[tx->channel->band],
+-	       sizeof(txrc.rate_idx_mcs_mask));
++
++	if (tx->sdata->rc_has_mcs_mask[tx->channel->band])
++		txrc.rate_idx_mcs_mask =
++			tx->sdata->rc_rateidx_mcs_mask[tx->channel->band];
++
+ 	txrc.bss = (tx->sdata->vif.type == NL80211_IFTYPE_AP ||
+ 		    tx->sdata->vif.type == NL80211_IFTYPE_MESH_POINT ||
+ 		    tx->sdata->vif.type == NL80211_IFTYPE_ADHOC);
+@@ -2464,8 +2466,6 @@ struct sk_buff *ieee80211_beacon_get_tim
+ 		txrc.max_rate_idx = -1;
+ 	else
+ 		txrc.max_rate_idx = fls(txrc.rate_idx_mask) - 1;
+-	memcpy(txrc.rate_idx_mcs_mask, sdata->rc_rateidx_mcs_mask[band],
+-	       sizeof(txrc.rate_idx_mcs_mask));
+ 	txrc.bss = true;
+ 	rate_control_get_rate(sdata, NULL, &txrc);
+ 
+--- a/net/mac80211/rate.c
++++ b/net/mac80211/rate.c
+@@ -461,9 +461,12 @@ void rate_control_get_rate(struct ieee80
+ 	 * the common case.
+ 	 */
+ 	mask = sdata->rc_rateidx_mask[info->band];
+-	memcpy(mcs_mask, sdata->rc_rateidx_mcs_mask[info->band],
+-	       sizeof(mcs_mask));
+-	if (mask != (1 << txrc->sband->n_bitrates) - 1) {
++	if (mask != (1 << txrc->sband->n_bitrates) - 1 || txrc->rate_idx_mcs_mask) {
++		if (txrc->rate_idx_mcs_mask)
++			memcpy(mcs_mask, txrc->rate_idx_mcs_mask, sizeof(mcs_mask));
++		else
++			memset(mcs_mask, 0xff, sizeof(mcs_mask));
++
+ 		if (sta) {
+ 			/* Filter out rates that the STA does not support */
+ 			mask &= sta->sta.supp_rates[info->band];
diff '--exclude=.svn' -Nur package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch ../openwrt-trunk/package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch
--- package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/551-ath9k_optimize_interrupt_mitigation.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,30 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
+@@ -240,21 +240,19 @@ static bool ar9003_hw_get_isr(struct ath
+ 
+ 		*masked = isr & ATH9K_INT_COMMON;
+ 
+-		if (ah->config.rx_intr_mitigation)
++		if (ah->config.rx_intr_mitigation) {
+ 			if (isr & (AR_ISR_RXMINTR | AR_ISR_RXINTM))
+ 				*masked |= ATH9K_INT_RXLP;
+-
+-		if (ah->config.tx_intr_mitigation)
+-			if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM))
+-				*masked |= ATH9K_INT_TX;
+-
+-		if (isr & (AR_ISR_LP_RXOK | AR_ISR_RXERR))
++		} else if (isr & (AR_ISR_LP_RXOK | AR_ISR_RXERR))
+ 			*masked |= ATH9K_INT_RXLP;
+ 
+ 		if (isr & AR_ISR_HP_RXOK)
+ 			*masked |= ATH9K_INT_RXHP;
+ 
+-		if (isr & (AR_ISR_TXOK | AR_ISR_TXERR | AR_ISR_TXEOL)) {
++		if (ah->config.tx_intr_mitigation) {
++			if (isr & (AR_ISR_TXMINTR | AR_ISR_TXINTM))
++				*masked |= ATH9K_INT_TX;
++		} else if (isr & (AR_ISR_TXOK | AR_ISR_TXERR | AR_ISR_TXEOL)) {
+ 			*masked |= ATH9K_INT_TX;
+ 
+ 			if (!(pCap->hw_caps & ATH9K_HW_CAP_RAC_SUPPORTED)) {
diff '--exclude=.svn' -Nur package/mac80211/patches/551-ath9k_per_chain_signal_strength.patch ../openwrt-trunk/package/mac80211/patches/551-ath9k_per_chain_signal_strength.patch
--- package/mac80211/patches/551-ath9k_per_chain_signal_strength.patch	2012-08-17 15:40:46.481971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/551-ath9k_per_chain_signal_strength.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,374 +0,0 @@
---- a/include/net/mac80211.h
-+++ b/include/net/mac80211.h
-@@ -684,6 +684,9 @@ enum mac80211_rx_flags {
-  * @mactime: value in microseconds of the 64-bit Time Synchronization Function
-  * 	(TSF) timer when the first data symbol (MPDU) arrived at the hardware.
-  * @band: the active band when this frame was received
-+ * @chains: bitmask of receive chains for which separate signal strength
-+ *	values were filled.
-+ * @chain_signal: per-chain signal strength, same format as @signal
-  * @freq: frequency the radio was tuned to when receiving this frame, in MHz
-  * @signal: signal strength when receiving this frame, either in dBm, in dB or
-  *	unspecified depending on the hardware capabilities flags
-@@ -697,6 +700,10 @@ enum mac80211_rx_flags {
- struct ieee80211_rx_status {
- 	u64 mactime;
- 	enum ieee80211_band band;
-+
-+	u8 chains;
-+	s8 chain_signal[4];
-+
- 	int freq;
- 	int signal;
- 	int antenna;
---- a/net/mac80211/sta_info.h
-+++ b/net/mac80211/sta_info.h
-@@ -302,6 +302,11 @@ struct sta_info {
- 	unsigned long rx_dropped;
- 	int last_signal;
- 	struct ewma avg_signal;
-+
-+	u8 chains;
-+	s8 chain_signal_last[4];
-+	struct ewma chain_signal_avg[4];
-+
- 	/* Plus 1 for non-QoS frames */
- 	__le16 last_seq_ctrl[NUM_RX_DATA_QUEUES + 1];
- 
---- a/net/mac80211/rx.c
-+++ b/net/mac80211/rx.c
-@@ -1267,6 +1267,7 @@ ieee80211_rx_h_sta_process(struct ieee80
- 	struct sk_buff *skb = rx->skb;
- 	struct ieee80211_rx_status *status = IEEE80211_SKB_RXCB(skb);
- 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb->data;
-+	int i;
- 
- 	if (!sta)
- 		return RX_CONTINUE;
-@@ -1309,6 +1310,19 @@ ieee80211_rx_h_sta_process(struct ieee80
- 	sta->last_signal = status->signal;
- 	ewma_add(&sta->avg_signal, -status->signal);
- 
-+	if (status->chains) {
-+		sta->chains = status->chains;
-+		for (i = 0; i < 4; i++) {
-+			int signal = status->chain_signal[i];
-+
-+			if (!(status->chains & BIT(i)))
-+				continue;
-+
-+			sta->chain_signal_last[i] = signal;
-+			ewma_add(&sta->chain_signal_avg[i], -signal);
-+		}
-+	}
-+
- 	/*
- 	 * Change STA power saving mode only at the end of a frame
- 	 * exchange sequence.
---- a/net/mac80211/sta_info.c
-+++ b/net/mac80211/sta_info.c
-@@ -304,6 +304,8 @@ struct sta_info *sta_info_alloc(struct i
- 	do_posix_clock_monotonic_gettime(&uptime);
- 	sta->last_connected = uptime.tv_sec;
- 	ewma_init(&sta->avg_signal, 1024, 8);
-+	for (i = 0; i < ARRAY_SIZE(sta->chain_signal_avg); i++)
-+		ewma_init(&sta->chain_signal_avg[i], 1024, 8);
- 
- 	if (sta_prepare_rate_control(local, sta, gfp)) {
- 		kfree(sta);
---- a/include/net/cfg80211.h
-+++ b/include/net/cfg80211.h
-@@ -505,6 +505,8 @@ struct station_parameters {
-  * @STATION_INFO_CONNECTED_TIME: @connected_time filled
-  * @STATION_INFO_ASSOC_REQ_IES: @assoc_req_ies filled
-  * @STATION_INFO_STA_FLAGS: @sta_flags filled
-+ * @STATION_INFO_CHAIN_SIGNAL: @chain_signal filled
-+ * @STATION_INFO_CHAIN_SIGNAL_AVG: @chain_signal_avg filled
-  */
- enum station_info_flags {
- 	STATION_INFO_INACTIVE_TIME	= 1<<0,
-@@ -525,7 +527,9 @@ enum station_info_flags {
- 	STATION_INFO_BSS_PARAM          = 1<<15,
- 	STATION_INFO_CONNECTED_TIME	= 1<<16,
- 	STATION_INFO_ASSOC_REQ_IES	= 1<<17,
--	STATION_INFO_STA_FLAGS		= 1<<18
-+	STATION_INFO_STA_FLAGS		= 1<<18,
-+	STATION_INFO_CHAIN_SIGNAL	= 1<<19,
-+	STATION_INFO_CHAIN_SIGNAL_AVG	= 1<<20,
- };
- 
- /**
-@@ -605,6 +609,9 @@ struct sta_bss_parameters {
-  * @plink_state: mesh peer link state
-  * @signal: signal strength of last received packet in dBm
-  * @signal_avg: signal strength average in dBm
-+ * @chains: bitmask for filled values in @chain_signal, @chain_signal_avg
-+ * @chain_signal: per-chain signal strength of last received packet in dBm
-+ * @chain_signal_avg: per-chain signal strength average in dBm
-  * @txrate: current unicast bitrate from this station
-  * @rxrate: current unicast bitrate to this station
-  * @rx_packets: packets received from this station
-@@ -635,6 +642,11 @@ struct station_info {
- 	u8 plink_state;
- 	s8 signal;
- 	s8 signal_avg;
-+
-+	u8 chains;
-+	s8 chain_signal[4];
-+	s8 chain_signal_avg[4];
-+
- 	struct rate_info txrate;
- 	struct rate_info rxrate;
- 	u32 rx_packets;
---- a/drivers/net/wireless/ath/ath9k/mac.h
-+++ b/drivers/net/wireless/ath/ath9k/mac.h
-@@ -133,12 +133,8 @@ struct ath_rx_status {
- 	u8 rs_rate;
- 	u8 rs_antenna;
- 	u8 rs_more;
--	int8_t rs_rssi_ctl0;
--	int8_t rs_rssi_ctl1;
--	int8_t rs_rssi_ctl2;
--	int8_t rs_rssi_ext0;
--	int8_t rs_rssi_ext1;
--	int8_t rs_rssi_ext2;
-+	int8_t rs_rssi_ctl[3];
-+	int8_t rs_rssi_ext[3];
- 	u8 rs_isaggr;
- 	u8 rs_moreaggr;
- 	u8 rs_num_delims;
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -980,6 +980,7 @@ static int ath9k_rx_skb_preprocess(struc
- 				   bool *decrypt_error)
- {
- 	struct ath_hw *ah = common->ah;
-+	int i, j;
- 
- 	memset(rx_status, 0, sizeof(struct ieee80211_rx_status));
- 
-@@ -1005,6 +1006,20 @@ static int ath9k_rx_skb_preprocess(struc
- 	rx_status->antenna = rx_stats->rs_antenna;
- 	rx_status->flag |= RX_FLAG_MACTIME_MPDU;
- 
-+	for (i = 0, j = 0; i < ARRAY_SIZE(rx_stats->rs_rssi_ctl); i++) {
-+		s8 rssi;
-+
-+		if (!(ah->rxchainmask & BIT(i)))
-+			continue;
-+
-+		rssi = rx_stats->rs_rssi_ctl[i];
-+		if (rssi != ATH9K_RSSI_BAD) {
-+		    rx_status->chains |= BIT(j);
-+		    rx_status->chain_signal[j] = ah->noise + rssi;
-+		}
-+		j++;
-+	}
-+
- 	return 0;
- }
- 
-@@ -1535,14 +1550,14 @@ static void ath_ant_comb_scan(struct ath
- 	struct ath_ant_comb *antcomb = &sc->ant_comb;
- 	int alt_ratio = 0, alt_rssi_avg = 0, main_rssi_avg = 0, curr_alt_set;
- 	int curr_main_set;
--	int main_rssi = rs->rs_rssi_ctl0;
--	int alt_rssi = rs->rs_rssi_ctl1;
-+	int main_rssi = rs->rs_rssi_ctl[0];
-+	int alt_rssi = rs->rs_rssi_ctl[1];
- 	int rx_ant_conf,  main_ant_conf;
- 	bool short_scan = false;
- 
--	rx_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_CURRENT_SHIFT) &
-+	rx_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_CURRENT_SHIFT) &
- 		       ATH_ANT_RX_MASK;
--	main_ant_conf = (rs->rs_rssi_ctl2 >> ATH_ANT_RX_MAIN_SHIFT) &
-+	main_ant_conf = (rs->rs_rssi_ctl[2] >> ATH_ANT_RX_MAIN_SHIFT) &
- 			 ATH_ANT_RX_MASK;
- 
- 	/* Record packet only when both main_rssi and  alt_rssi is positive */
---- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-@@ -484,12 +484,12 @@ int ath9k_hw_process_rxdesc_edma(struct 
- 
- 	/* XXX: Keycache */
- 	rxs->rs_rssi = MS(rxsp->status5, AR_RxRSSICombined);
--	rxs->rs_rssi_ctl0 = MS(rxsp->status1, AR_RxRSSIAnt00);
--	rxs->rs_rssi_ctl1 = MS(rxsp->status1, AR_RxRSSIAnt01);
--	rxs->rs_rssi_ctl2 = MS(rxsp->status1, AR_RxRSSIAnt02);
--	rxs->rs_rssi_ext0 = MS(rxsp->status5, AR_RxRSSIAnt10);
--	rxs->rs_rssi_ext1 = MS(rxsp->status5, AR_RxRSSIAnt11);
--	rxs->rs_rssi_ext2 = MS(rxsp->status5, AR_RxRSSIAnt12);
-+	rxs->rs_rssi_ctl[0] = MS(rxsp->status1, AR_RxRSSIAnt00);
-+	rxs->rs_rssi_ctl[1] = MS(rxsp->status1, AR_RxRSSIAnt01);
-+	rxs->rs_rssi_ctl[2] = MS(rxsp->status1, AR_RxRSSIAnt02);
-+	rxs->rs_rssi_ext[0] = MS(rxsp->status5, AR_RxRSSIAnt10);
-+	rxs->rs_rssi_ext[1] = MS(rxsp->status5, AR_RxRSSIAnt11);
-+	rxs->rs_rssi_ext[2] = MS(rxsp->status5, AR_RxRSSIAnt12);
- 
- 	if (rxsp->status11 & AR_RxKeyIdxValid)
- 		rxs->rs_keyix = MS(rxsp->status11, AR_KeyIdx);
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -559,25 +559,25 @@ int ath9k_hw_rxprocdesc(struct ath_hw *a
- 
- 	if (ads.ds_rxstatus8 & AR_PostDelimCRCErr) {
- 		rs->rs_rssi = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ctl0 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ctl1 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ctl2 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ext0 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ext1 = ATH9K_RSSI_BAD;
--		rs->rs_rssi_ext2 = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ctl[0] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ctl[1] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ctl[2] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ext[0] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ext[1] = ATH9K_RSSI_BAD;
-+		rs->rs_rssi_ext[2] = ATH9K_RSSI_BAD;
- 	} else {
- 		rs->rs_rssi = MS(ads.ds_rxstatus4, AR_RxRSSICombined);
--		rs->rs_rssi_ctl0 = MS(ads.ds_rxstatus0,
-+		rs->rs_rssi_ctl[0] = MS(ads.ds_rxstatus0,
- 						AR_RxRSSIAnt00);
--		rs->rs_rssi_ctl1 = MS(ads.ds_rxstatus0,
-+		rs->rs_rssi_ctl[1] = MS(ads.ds_rxstatus0,
- 						AR_RxRSSIAnt01);
--		rs->rs_rssi_ctl2 = MS(ads.ds_rxstatus0,
-+		rs->rs_rssi_ctl[2] = MS(ads.ds_rxstatus0,
- 						AR_RxRSSIAnt02);
--		rs->rs_rssi_ext0 = MS(ads.ds_rxstatus4,
-+		rs->rs_rssi_ext[0] = MS(ads.ds_rxstatus4,
- 						AR_RxRSSIAnt10);
--		rs->rs_rssi_ext1 = MS(ads.ds_rxstatus4,
-+		rs->rs_rssi_ext[1] = MS(ads.ds_rxstatus4,
- 						AR_RxRSSIAnt11);
--		rs->rs_rssi_ext2 = MS(ads.ds_rxstatus4,
-+		rs->rs_rssi_ext[2] = MS(ads.ds_rxstatus4,
- 						AR_RxRSSIAnt12);
- 	}
- 	if (ads.ds_rxstatus8 & AR_RxKeyIdxValid)
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1047,12 +1047,12 @@ void ath_debug_stat_rx(struct ath_softc 
- 
- 	spin_lock(&sc->debug.samp_lock);
- 	RX_SAMP_DBG(jiffies) = jiffies;
--	RX_SAMP_DBG(rssi_ctl0) = rs->rs_rssi_ctl0;
--	RX_SAMP_DBG(rssi_ctl1) = rs->rs_rssi_ctl1;
--	RX_SAMP_DBG(rssi_ctl2) = rs->rs_rssi_ctl2;
--	RX_SAMP_DBG(rssi_ext0) = rs->rs_rssi_ext0;
--	RX_SAMP_DBG(rssi_ext1) = rs->rs_rssi_ext1;
--	RX_SAMP_DBG(rssi_ext2) = rs->rs_rssi_ext2;
-+	RX_SAMP_DBG(rssi_ctl0) = rs->rs_rssi_ctl[0];
-+	RX_SAMP_DBG(rssi_ctl1) = rs->rs_rssi_ctl[1];
-+	RX_SAMP_DBG(rssi_ctl2) = rs->rs_rssi_ctl[2];
-+	RX_SAMP_DBG(rssi_ext0) = rs->rs_rssi_ext[0];
-+	RX_SAMP_DBG(rssi_ext1) = rs->rs_rssi_ext[1];
-+	RX_SAMP_DBG(rssi_ext2) = rs->rs_rssi_ext[2];
- 	RX_SAMP_DBG(antenna) = rs->rs_antenna;
- 	RX_SAMP_DBG(rssi) = rs->rs_rssi;
- 	RX_SAMP_DBG(rate) = rs->rs_rate;
---- a/include/linux/nl80211.h
-+++ b/include/linux/nl80211.h
-@@ -1651,6 +1651,8 @@ enum nl80211_sta_bss_param {
-  *     containing info as possible, see &enum nl80211_sta_bss_param
-  * @NL80211_STA_INFO_CONNECTED_TIME: time since the station is last connected
-  * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
-+ * @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU
-+ * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
-  * @__NL80211_STA_INFO_AFTER_LAST: internal
-  * @NL80211_STA_INFO_MAX: highest possible station info attribute
-  */
-@@ -1673,6 +1675,8 @@ enum nl80211_sta_info {
- 	NL80211_STA_INFO_BSS_PARAM,
- 	NL80211_STA_INFO_CONNECTED_TIME,
- 	NL80211_STA_INFO_STA_FLAGS,
-+	NL80211_STA_INFO_CHAIN_SIGNAL,
-+	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
- 
- 	/* keep last */
- 	__NL80211_STA_INFO_AFTER_LAST,
---- a/net/wireless/nl80211.c
-+++ b/net/wireless/nl80211.c
-@@ -2322,6 +2322,33 @@ nla_put_failure:
- 	return false;
- }
- 
-+static bool nl80211_put_signal(struct sk_buff *msg, u8 mask, s8 *signal,
-+			       int id)
-+{
-+	void *attr;
-+	int i = 0;
-+
-+	if (!mask)
-+		return true;
-+
-+	attr = nla_nest_start(msg, id);
-+	if (!attr)
-+		goto nla_put_failure;
-+
-+	for (i = 0; i < 4; i++) {
-+		if (!(mask & BIT(i)))
-+			continue;
-+
-+		NLA_PUT_U8(msg, i, signal[i]);
-+	}
-+
-+	nla_nest_end(msg, attr);
-+
-+	return true;
-+nla_put_failure:
-+	return false;
-+}
-+
- static int nl80211_send_station(struct sk_buff *msg, u32 pid, u32 seq,
- 				int flags, struct net_device *dev,
- 				const u8 *mac_addr, struct station_info *sinfo)
-@@ -2368,6 +2395,18 @@ static int nl80211_send_station(struct s
- 	if (sinfo->filled & STATION_INFO_SIGNAL_AVG)
- 		NLA_PUT_U8(msg, NL80211_STA_INFO_SIGNAL_AVG,
- 			   sinfo->signal_avg);
-+	if (sinfo->filled & STATION_INFO_CHAIN_SIGNAL) {
-+		if (!nl80211_put_signal(msg, sinfo->chains,
-+					sinfo->chain_signal,
-+					NL80211_STA_INFO_CHAIN_SIGNAL))
-+			goto nla_put_failure;
-+	}
-+	if (sinfo->filled & STATION_INFO_CHAIN_SIGNAL_AVG) {
-+		if (!nl80211_put_signal(msg, sinfo->chains,
-+					sinfo->chain_signal_avg,
-+					NL80211_STA_INFO_CHAIN_SIGNAL_AVG))
-+			goto nla_put_failure;
-+	}
- 	if (sinfo->filled & STATION_INFO_TX_BITRATE) {
- 		if (!nl80211_put_sta_rate(msg, &sinfo->txrate,
- 					  NL80211_STA_INFO_TX_BITRATE))
---- a/net/mac80211/cfg.c
-+++ b/net/mac80211/cfg.c
-@@ -340,6 +340,7 @@ static void sta_set_sinfo(struct sta_inf
- {
- 	struct ieee80211_sub_if_data *sdata = sta->sdata;
- 	struct timespec uptime;
-+	int i;
- 
- 	sinfo->generation = sdata->local->sta_generation;
- 
-@@ -375,6 +376,17 @@ static void sta_set_sinfo(struct sta_inf
- 		sinfo->signal = (s8)sta->last_signal;
- 		sinfo->signal_avg = (s8) -ewma_read(&sta->avg_signal);
- 	}
-+	if (sta->chains) {
-+		sinfo->filled |= STATION_INFO_CHAIN_SIGNAL |
-+				 STATION_INFO_CHAIN_SIGNAL_AVG;
-+
-+		sinfo->chains = sta->chains;
-+		for (i = 0; i < ARRAY_SIZE(sinfo->chain_signal); i++) {
-+			sinfo->chain_signal[i] = sta->chain_signal_last[i];
-+			sinfo->chain_signal_avg[i] =
-+				(s8) -ewma_read(&sta->chain_signal_avg[i]);
-+		}
-+	}
- 
- 	sinfo->txrate.flags = 0;
- 	if (sta->last_tx_rate.flags & IEEE80211_TX_RC_MCS)
diff '--exclude=.svn' -Nur package/mac80211/patches/560-ath9k_reduce_ani_interval.patch ../openwrt-trunk/package/mac80211/patches/560-ath9k_reduce_ani_interval.patch
--- package/mac80211/patches/560-ath9k_reduce_ani_interval.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/560-ath9k_reduce_ani_interval.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,11 @@
+--- a/drivers/net/wireless/ath/ath9k/ani.h
++++ b/drivers/net/wireless/ath/ath9k/ani.h
+@@ -51,7 +51,7 @@
+ #define ATH9K_ANI_PERIOD                  300
+ 
+ /* in ms */
+-#define ATH9K_ANI_POLLINTERVAL            1000
++#define ATH9K_ANI_POLLINTERVAL            100
+ 
+ #define HAL_NOISE_IMMUNE_MAX              4
+ #define HAL_SPUR_IMMUNE_MAX               7
diff '--exclude=.svn' -Nur package/mac80211/patches/560-ath9k_rework_send_bar.patch ../openwrt-trunk/package/mac80211/patches/560-ath9k_rework_send_bar.patch
--- package/mac80211/patches/560-ath9k_rework_send_bar.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/560-ath9k_rework_send_bar.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,240 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -159,6 +159,9 @@ void ath_descdma_cleanup(struct ath_soft
- /* return block-ack bitmap index given sequence and starting sequence */
- #define ATH_BA_INDEX(_st, _seq) (((_seq) - (_st)) & (IEEE80211_SEQ_MAX - 1))
- 
-+/* return the seqno for _start + _offset */
-+#define ATH_BA_INDEX2SEQ(_seq, _offset) (((_seq) + (_offset)) & (IEEE80211_SEQ_MAX - 1))
-+
- /* returns delimiter padding required given the packet length */
- #define ATH_AGGR_GET_NDELIM(_len)					\
-        (((_len) >= ATH_AGGR_MINPLEN) ? 0 :                             \
-@@ -253,9 +256,9 @@ struct ath_atx_tid {
- struct ath_node {
- #ifdef CONFIG_ATH9K_DEBUGFS
- 	struct list_head list; /* for sc->nodes */
-+#endif
- 	struct ieee80211_sta *sta; /* station struct we're part of */
- 	struct ieee80211_vif *vif; /* interface with which we're associated */
--#endif
- 	struct ath_atx_tid tid[WME_NUM_TID];
- 	struct ath_atx_ac ac[WME_NUM_AC];
- 	int ps_key;
-@@ -277,7 +280,6 @@ struct ath_tx_control {
- };
- 
- #define ATH_TX_ERROR        0x01
--#define ATH_TX_BAR          0x02
- 
- /**
-  * @txq_map:  Index is mac80211 queue number.  This is
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -644,9 +644,9 @@ static void ath_node_attach(struct ath_s
- 	spin_lock(&sc->nodes_lock);
- 	list_add(&an->list, &sc->nodes);
- 	spin_unlock(&sc->nodes_lock);
-+#endif
- 	an->sta = sta;
- 	an->vif = vif;
--#endif
- 	if (sc->sc_flags & SC_OP_TXAGGR) {
- 		ath_tx_node_init(sc, an);
- 		an->maxampdu = 1 << (IEEE80211_HT_MAX_AMPDU_FACTOR +
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -53,7 +53,7 @@ static void ath_tx_complete(struct ath_s
- 			    int tx_flags, struct ath_txq *txq);
- static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
- 				struct ath_txq *txq, struct list_head *bf_q,
--				struct ath_tx_status *ts, int txok, int sendbar);
-+				struct ath_tx_status *ts, int txok);
- static void ath_tx_txqaddbuf(struct ath_softc *sc, struct ath_txq *txq,
- 			     struct list_head *head, bool internal);
- static void ath_tx_rc_status(struct ath_softc *sc, struct ath_buf *bf,
-@@ -150,6 +150,12 @@ static struct ath_frame_info *get_frame_
- 	return (struct ath_frame_info *) &tx_info->rate_driver_data[0];
- }
- 
-+static void ath_send_bar(struct ath_atx_tid *tid, u16 seqno)
-+{
-+	ieee80211_send_bar(tid->an->vif, tid->an->sta->addr, tid->tidno,
-+			   seqno << IEEE80211_SEQ_SEQ_SHIFT);
-+}
-+
- static void ath_tx_flush_tid(struct ath_softc *sc, struct ath_atx_tid *tid)
- {
- 	struct ath_txq *txq = tid->ac->txq;
-@@ -158,6 +164,7 @@ static void ath_tx_flush_tid(struct ath_
- 	struct list_head bf_head;
- 	struct ath_tx_status ts;
- 	struct ath_frame_info *fi;
-+	bool sendbar = false;
- 
- 	INIT_LIST_HEAD(&bf_head);
- 
-@@ -172,7 +179,8 @@ static void ath_tx_flush_tid(struct ath_
- 		if (bf && fi->retries) {
- 			list_add_tail(&bf->list, &bf_head);
- 			ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
--			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 1);
-+			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
-+			sendbar = true;
- 		} else {
- 			ath_tx_send_normal(sc, txq, NULL, skb);
- 		}
-@@ -185,6 +193,9 @@ static void ath_tx_flush_tid(struct ath_
- 	}
- 
- 	spin_unlock_bh(&txq->axq_lock);
-+
-+	if (sendbar)
-+		ath_send_bar(tid, tid->seq_start);
- }
- 
- static void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid,
-@@ -255,7 +266,7 @@ static void ath_tid_drain(struct ath_sof
- 			ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
- 
- 		spin_unlock(&txq->axq_lock);
--		ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
-+		ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
- 		spin_lock(&txq->axq_lock);
- 	}
- 
-@@ -381,7 +392,7 @@ static void ath_tx_complete_aggr(struct 
- 	struct ath_buf *bf_next, *bf_last = bf->bf_lastbf;
- 	struct list_head bf_head;
- 	struct sk_buff_head bf_pending;
--	u16 seq_st = 0, acked_cnt = 0, txfail_cnt = 0;
-+	u16 seq_st = 0, acked_cnt = 0, txfail_cnt = 0, seq_first;
- 	u32 ba[WME_BA_BMP_SIZE >> 5];
- 	int isaggr, txfail, txpending, sendbar = 0, needreset = 0, nbad = 0;
- 	bool rc_update = true;
-@@ -391,6 +402,7 @@ static void ath_tx_complete_aggr(struct 
- 	u8 tidno;
- 	bool flush = !!(ts->ts_status & ATH9K_TX_FLUSH);
- 	int i, retries;
-+	int bar_index = -1;
- 
- 	skb = bf->bf_mpdu;
- 	hdr = (struct ieee80211_hdr *)skb->data;
-@@ -416,8 +428,7 @@ static void ath_tx_complete_aggr(struct 
- 			if (!bf->bf_stale || bf_next != NULL)
- 				list_move_tail(&bf->list, &bf_head);
- 
--			ath_tx_complete_buf(sc, bf, txq, &bf_head, ts,
--				0, 0);
-+			ath_tx_complete_buf(sc, bf, txq, &bf_head, ts, 0);
- 
- 			bf = bf_next;
- 		}
-@@ -427,6 +438,7 @@ static void ath_tx_complete_aggr(struct 
- 	an = (struct ath_node *)sta->drv_priv;
- 	tidno = ieee80211_get_qos_ctl(hdr)[0] & IEEE80211_QOS_CTL_TID_MASK;
- 	tid = ATH_AN_2_TID(an, tidno);
-+	seq_first = tid->seq_start;
- 
- 	/*
- 	 * The hardware occasionally sends a tx status for the wrong TID.
-@@ -495,8 +507,9 @@ static void ath_tx_complete_aggr(struct 
- 				txpending = 1;
- 			} else {
- 				txfail = 1;
--				sendbar = 1;
- 				txfail_cnt++;
-+				bar_index = max_t(int, bar_index,
-+					ATH_BA_INDEX(seq_first, seqno));
- 			}
- 		}
- 
-@@ -525,7 +538,7 @@ static void ath_tx_complete_aggr(struct 
- 			}
- 
- 			ath_tx_complete_buf(sc, bf, txq, &bf_head, ts,
--				!txfail, sendbar);
-+				!txfail);
- 		} else {
- 			/* retry the un-acked ones */
- 			if (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)) {
-@@ -545,8 +558,10 @@ static void ath_tx_complete_aggr(struct 
- 
- 						ath_tx_complete_buf(sc, bf, txq,
- 								    &bf_head,
--								    ts, 0,
--								    !flush);
-+								    ts, 0);
-+						bar_index = max_t(int, bar_index,
-+							ATH_BA_INDEX(seq_first,
-+								seqno));
- 						break;
- 					}
- 
-@@ -564,6 +579,9 @@ static void ath_tx_complete_aggr(struct 
- 		bf = bf_next;
- 	}
- 
-+	if (bar_index >= 0)
-+		ath_send_bar(tid, ATH_BA_INDEX2SEQ(seq_first, bar_index + 1));
-+
- 	/* prepend un-acked frames to the beginning of the pending frame queue */
- 	if (!skb_queue_empty(&bf_pending)) {
- 		if (an->sleeping)
-@@ -1452,7 +1470,7 @@ static void ath_drain_txq_list(struct at
- 			ath_tx_complete_aggr(sc, txq, bf, &bf_head, &ts, 0,
- 					     retry_tx);
- 		else
--			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0, 0);
-+			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
- 		spin_lock_bh(&txq->axq_lock);
- 	}
- }
-@@ -1967,9 +1985,6 @@ static void ath_tx_complete(struct ath_s
- 
- 	ath_dbg(common, ATH_DBG_XMIT, "TX complete: skb: %p\n", skb);
- 
--	if (tx_flags & ATH_TX_BAR)
--		tx_info->flags |= IEEE80211_TX_STAT_AMPDU_NO_BACK;
--
- 	if (!(tx_flags & ATH_TX_ERROR))
- 		/* Frame was ACKed */
- 		tx_info->flags |= IEEE80211_TX_STAT_ACK;
-@@ -2013,16 +2028,13 @@ static void ath_tx_complete(struct ath_s
- 
- static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
- 				struct ath_txq *txq, struct list_head *bf_q,
--				struct ath_tx_status *ts, int txok, int sendbar)
-+				struct ath_tx_status *ts, int txok)
- {
- 	struct sk_buff *skb = bf->bf_mpdu;
- 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
- 	unsigned long flags;
- 	int tx_flags = 0;
- 
--	if (sendbar)
--		tx_flags = ATH_TX_BAR;
--
- 	if (!txok)
- 		tx_flags |= ATH_TX_ERROR;
- 
-@@ -2129,7 +2141,7 @@ static void ath_tx_process_buffer(struct
- 
- 	if (!bf_isampdu(bf)) {
- 		ath_tx_rc_status(sc, bf, ts, 1, txok ? 0 : 1, txok);
--		ath_tx_complete_buf(sc, bf, txq, bf_head, ts, txok, 0);
-+		ath_tx_complete_buf(sc, bf, txq, bf_head, ts, txok);
- 	} else
- 		ath_tx_complete_aggr(sc, txq, bf, bf_head, ts, txok, true);
- 
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -856,7 +856,7 @@ void ath_debug_stat_tx(struct ath_softc 
- 	sc->debug.stats.txstats[qnum].tx_bytes_all += bf->bf_mpdu->len;
- 
- 	if (bf_isampdu(bf)) {
--		if (flags & ATH_TX_BAR)
-+		if (flags & ATH_TX_ERROR)
- 			TX_STAT_INC(qnum, a_xretries);
- 		else
- 			TX_STAT_INC(qnum, a_completed);
diff '--exclude=.svn' -Nur package/mac80211/patches/561-ath9k_reduce_indentation.patch ../openwrt-trunk/package/mac80211/patches/561-ath9k_reduce_indentation.patch
--- package/mac80211/patches/561-ath9k_reduce_indentation.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/561-ath9k_reduce_indentation.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,159 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -490,27 +490,25 @@ static void ath_tx_complete_aggr(struct 
- 		} else if (!isaggr && txok) {
- 			/* transmit completion */
- 			acked_cnt++;
-+		} else if ((tid->state & AGGR_CLEANUP) || !retry) {
-+			/*
-+			 * cleanup in progress, just fail
-+			 * the un-acked sub-frames
-+			 */
-+			txfail = 1;
-+		} else if (flush) {
-+			txpending = 1;
-+		} else if (fi->retries < ATH_MAX_SW_RETRIES) {
-+			if (txok || !an->sleeping)
-+				ath_tx_set_retry(sc, txq, bf->bf_mpdu,
-+						 retries);
-+
-+			txpending = 1;
- 		} else {
--			if ((tid->state & AGGR_CLEANUP) || !retry) {
--				/*
--				 * cleanup in progress, just fail
--				 * the un-acked sub-frames
--				 */
--				txfail = 1;
--			} else if (flush) {
--				txpending = 1;
--			} else if (fi->retries < ATH_MAX_SW_RETRIES) {
--				if (txok || !an->sleeping)
--					ath_tx_set_retry(sc, txq, bf->bf_mpdu,
--							 retries);
--
--				txpending = 1;
--			} else {
--				txfail = 1;
--				txfail_cnt++;
--				bar_index = max_t(int, bar_index,
--					ATH_BA_INDEX(seq_first, seqno));
--			}
-+			txfail = 1;
-+			txfail_cnt++;
-+			bar_index = max_t(int, bar_index,
-+				ATH_BA_INDEX(seq_first, seqno));
- 		}
- 
- 		/*
-@@ -541,32 +539,29 @@ static void ath_tx_complete_aggr(struct 
- 				!txfail);
- 		} else {
- 			/* retry the un-acked ones */
--			if (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA)) {
--				if (bf->bf_next == NULL && bf_last->bf_stale) {
--					struct ath_buf *tbf;
--
--					tbf = ath_clone_txbuf(sc, bf_last);
--					/*
--					 * Update tx baw and complete the
--					 * frame with failed status if we
--					 * run out of tx buf.
--					 */
--					if (!tbf) {
--						spin_lock_bh(&txq->axq_lock);
--						ath_tx_update_baw(sc, tid, seqno);
--						spin_unlock_bh(&txq->axq_lock);
--
--						ath_tx_complete_buf(sc, bf, txq,
--								    &bf_head,
--								    ts, 0);
--						bar_index = max_t(int, bar_index,
--							ATH_BA_INDEX(seq_first,
--								seqno));
--						break;
--					}
-+			if (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) &&
-+			    bf->bf_next == NULL && bf_last->bf_stale) {
-+				struct ath_buf *tbf;
- 
--					fi->bf = tbf;
-+				tbf = ath_clone_txbuf(sc, bf_last);
-+				/*
-+				 * Update tx baw and complete the
-+				 * frame with failed status if we
-+				 * run out of tx buf.
-+				 */
-+				if (!tbf) {
-+					spin_lock_bh(&txq->axq_lock);
-+					ath_tx_update_baw(sc, tid, seqno);
-+					spin_unlock_bh(&txq->axq_lock);
-+
-+					ath_tx_complete_buf(sc, bf, txq,
-+							    &bf_head, ts, 0);
-+					bar_index = max_t(int, bar_index,
-+						ATH_BA_INDEX(seq_first, seqno));
-+					break;
- 				}
-+
-+				fi->bf = tbf;
- 			}
- 
- 			/*
-@@ -654,24 +649,26 @@ static u32 ath_lookup_rate(struct ath_so
- 	max_4ms_framelen = ATH_AMPDU_LIMIT_MAX;
- 
- 	for (i = 0; i < 4; i++) {
--		if (rates[i].count) {
--			int modeidx;
--			if (!(rates[i].flags & IEEE80211_TX_RC_MCS)) {
--				legacy = 1;
--				break;
--			}
--
--			if (rates[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
--				modeidx = MCS_HT40;
--			else
--				modeidx = MCS_HT20;
-+		int modeidx;
- 
--			if (rates[i].flags & IEEE80211_TX_RC_SHORT_GI)
--				modeidx++;
-+		if (!rates[i].count)
-+			continue;
- 
--			frmlen = ath_max_4ms_framelen[modeidx][rates[i].idx];
--			max_4ms_framelen = min(max_4ms_framelen, frmlen);
-+		if (!(rates[i].flags & IEEE80211_TX_RC_MCS)) {
-+			legacy = 1;
-+			break;
- 		}
-+
-+		if (rates[i].flags & IEEE80211_TX_RC_40_MHZ_WIDTH)
-+			modeidx = MCS_HT40;
-+		else
-+			modeidx = MCS_HT20;
-+
-+		if (rates[i].flags & IEEE80211_TX_RC_SHORT_GI)
-+			modeidx++;
-+
-+		frmlen = ath_max_4ms_framelen[modeidx][rates[i].idx];
-+		max_4ms_framelen = min(max_4ms_framelen, frmlen);
- 	}
- 
- 	/*
-@@ -1598,11 +1595,9 @@ void ath_txq_schedule(struct ath_softc *
- 				break;
- 		}
- 
--		if (!list_empty(&ac->tid_q)) {
--			if (!ac->sched) {
--				ac->sched = true;
--				list_add_tail(&ac->list, &txq->axq_acq);
--			}
-+		if (!list_empty(&ac->tid_q) && !ac->sched) {
-+			ac->sched = true;
-+			list_add_tail(&ac->list, &txq->axq_acq);
- 		}
- 
- 		if (ac == last_ac ||
diff '--exclude=.svn' -Nur package/mac80211/patches/561-ath9k_revert_initval_change.patch ../openwrt-trunk/package/mac80211/patches/561-ath9k_revert_initval_change.patch
--- package/mac80211/patches/561-ath9k_revert_initval_change.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/561-ath9k_revert_initval_change.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,19 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
+@@ -778,11 +778,11 @@ static const u32 ar9300Common_rx_gain_ta
+ 	{0x0000a074, 0x00000000},
+ 	{0x0000a078, 0x00000000},
+ 	{0x0000a07c, 0x00000000},
+-	{0x0000a080, 0x1a1a1a1a},
+-	{0x0000a084, 0x1a1a1a1a},
+-	{0x0000a088, 0x1a1a1a1a},
+-	{0x0000a08c, 0x1a1a1a1a},
+-	{0x0000a090, 0x171a1a1a},
++	{0x0000a080, 0x22222229},
++	{0x0000a084, 0x1d1d1d1d},
++	{0x0000a088, 0x1d1d1d1d},
++	{0x0000a08c, 0x1d1d1d1d},
++	{0x0000a090, 0x171d1d1d},
+ 	{0x0000a094, 0x11111717},
+ 	{0x0000a098, 0x00030311},
+ 	{0x0000a09c, 0x00000000},
diff '--exclude=.svn' -Nur package/mac80211/patches/562-ath9k_add_idle_hack.patch ../openwrt-trunk/package/mac80211/patches/562-ath9k_add_idle_hack.patch
--- package/mac80211/patches/562-ath9k_add_idle_hack.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/562-ath9k_add_idle_hack.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,20 @@
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -1055,6 +1055,7 @@ static void ath9k_remove_interface(struc
+ 	ath9k_calculate_summary_state(hw, NULL);
+ 
+ 	mutex_unlock(&sc->mutex);
++	ath9k_config(hw, IEEE80211_CONF_CHANGE_IDLE);
+ 	ath9k_ps_restore(sc);
+ }
+ 
+@@ -1107,7 +1108,8 @@ int ath9k_config(struct ieee80211_hw *hw
+ 	mutex_lock(&sc->mutex);
+ 
+ 	if (changed & IEEE80211_CONF_CHANGE_IDLE) {
+-		sc->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE);
++		sc->ps_idle = !!(conf->flags & IEEE80211_CONF_IDLE) &&
++			      !sc->nvifs;
+ 		if (sc->ps_idle) {
+ 			ath_cancel_work(sc);
+ 			ath9k_stop_btcoex(sc);
diff '--exclude=.svn' -Nur package/mac80211/patches/562-ath9k_remove_seq_incr.patch ../openwrt-trunk/package/mac80211/patches/562-ath9k_remove_seq_incr.patch
--- package/mac80211/patches/562-ath9k_remove_seq_incr.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/562-ath9k_remove_seq_incr.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -1742,10 +1742,6 @@ static void ath_tx_send_normal(struct at
- 	list_add_tail(&bf->list, &bf_head);
- 	bf->bf_state.bf_type = 0;
- 
--	/* update starting sequence number for subsequent ADDBA request */
--	if (tid)
--		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
--
- 	bf->bf_lastbf = bf;
- 	ath_tx_fill_desc(sc, bf, txq, fi->framelen);
- 	ath_tx_txqaddbuf(sc, txq, &bf_head, false);
diff '--exclude=.svn' -Nur package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch ../openwrt-trunk/package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch
--- package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/563-ath9k_rx_dma_stop_check.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,28 @@
+--- a/drivers/net/wireless/ath/ath9k/mac.c
++++ b/drivers/net/wireless/ath/ath9k/mac.c
+@@ -689,7 +689,7 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
+ {
+ #define AH_RX_STOP_DMA_TIMEOUT 10000   /* usec */
+ 	struct ath_common *common = ath9k_hw_common(ah);
+-	u32 mac_status, last_mac_status = 0;
++	u32 mac_status = 0, last_mac_status = 0;
+ 	int i;
+ 
+ 	/* Enable access to the DMA observation bus */
+@@ -719,6 +719,16 @@ bool ath9k_hw_stopdmarecv(struct ath_hw 
+ 	}
+ 
+ 	if (i == 0) {
++		if (!AR_SREV_9300_20_OR_LATER(ah) &&
++		    (mac_status & 0x700) == 0) {
++			/*
++			 * DMA is idle but the MAC is still stuck
++			 * processing events
++			 */
++			*reset = true;
++			return true;
++		}
++
+ 		ath_err(common,
+ 			"DMA failed to stop in %d ms AR_CR=0x%08x AR_DIAG_SW=0x%08x DMADBG_7=0x%08x\n",
+ 			AH_RX_STOP_DMA_TIMEOUT / 1000,
diff '--exclude=.svn' -Nur package/mac80211/patches/563-ath9k_simplify_tx_locking.patch ../openwrt-trunk/package/mac80211/patches/563-ath9k_simplify_tx_locking.patch
--- package/mac80211/patches/563-ath9k_simplify_tx_locking.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/563-ath9k_simplify_tx_locking.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,214 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -169,13 +169,11 @@ static void ath_tx_flush_tid(struct ath_
- 	INIT_LIST_HEAD(&bf_head);
- 
- 	memset(&ts, 0, sizeof(ts));
--	spin_lock_bh(&txq->axq_lock);
- 
- 	while ((skb = __skb_dequeue(&tid->buf_q))) {
- 		fi = get_frame_info(skb);
- 		bf = fi->bf;
- 
--		spin_unlock_bh(&txq->axq_lock);
- 		if (bf && fi->retries) {
- 			list_add_tail(&bf->list, &bf_head);
- 			ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
-@@ -184,7 +182,6 @@ static void ath_tx_flush_tid(struct ath_
- 		} else {
- 			ath_tx_send_normal(sc, txq, NULL, skb);
- 		}
--		spin_lock_bh(&txq->axq_lock);
- 	}
- 
- 	if (tid->baw_head == tid->baw_tail) {
-@@ -192,8 +189,6 @@ static void ath_tx_flush_tid(struct ath_
- 		tid->state &= ~AGGR_CLEANUP;
- 	}
- 
--	spin_unlock_bh(&txq->axq_lock);
--
- 	if (sendbar)
- 		ath_send_bar(tid, tid->seq_start);
- }
-@@ -254,9 +249,7 @@ static void ath_tid_drain(struct ath_sof
- 		bf = fi->bf;
- 
- 		if (!bf) {
--			spin_unlock(&txq->axq_lock);
- 			ath_tx_complete(sc, skb, ATH_TX_ERROR, txq);
--			spin_lock(&txq->axq_lock);
- 			continue;
- 		}
- 
-@@ -265,9 +258,7 @@ static void ath_tid_drain(struct ath_sof
- 		if (fi->retries)
- 			ath_tx_update_baw(sc, tid, bf->bf_state.seqno);
- 
--		spin_unlock(&txq->axq_lock);
- 		ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
--		spin_lock(&txq->axq_lock);
- 	}
- 
- 	tid->seq_next = tid->seq_start;
-@@ -525,9 +516,7 @@ static void ath_tx_complete_aggr(struct 
- 			 * complete the acked-ones/xretried ones; update
- 			 * block-ack window
- 			 */
--			spin_lock_bh(&txq->axq_lock);
- 			ath_tx_update_baw(sc, tid, seqno);
--			spin_unlock_bh(&txq->axq_lock);
- 
- 			if (rc_update && (acked_cnt == 1 || txfail_cnt == 1)) {
- 				memcpy(tx_info->control.rates, rates, sizeof(rates));
-@@ -550,9 +539,7 @@ static void ath_tx_complete_aggr(struct 
- 				 * run out of tx buf.
- 				 */
- 				if (!tbf) {
--					spin_lock_bh(&txq->axq_lock);
- 					ath_tx_update_baw(sc, tid, seqno);
--					spin_unlock_bh(&txq->axq_lock);
- 
- 					ath_tx_complete_buf(sc, bf, txq,
- 							    &bf_head, ts, 0);
-@@ -582,7 +569,6 @@ static void ath_tx_complete_aggr(struct 
- 		if (an->sleeping)
- 			ieee80211_sta_set_buffered(sta, tid->tidno, true);
- 
--		spin_lock_bh(&txq->axq_lock);
- 		skb_queue_splice(&bf_pending, &tid->buf_q);
- 		if (!an->sleeping) {
- 			ath_tx_queue_tid(txq, tid);
-@@ -590,7 +576,6 @@ static void ath_tx_complete_aggr(struct 
- 			if (ts->ts_status & ATH9K_TXERR_FILT)
- 				tid->ac->clear_ps_filter = true;
- 		}
--		spin_unlock_bh(&txq->axq_lock);
- 	}
- 
- 	if (tid->state & AGGR_CLEANUP)
-@@ -1190,9 +1175,9 @@ void ath_tx_aggr_stop(struct ath_softc *
- 		txtid->state |= AGGR_CLEANUP;
- 	else
- 		txtid->state &= ~AGGR_ADDBA_COMPLETE;
--	spin_unlock_bh(&txq->axq_lock);
- 
- 	ath_tx_flush_tid(sc, txtid);
-+	spin_unlock_bh(&txq->axq_lock);
- }
- 
- void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
-@@ -1434,8 +1419,6 @@ static bool bf_is_ampdu_not_probing(stru
- 
- static void ath_drain_txq_list(struct ath_softc *sc, struct ath_txq *txq,
- 			       struct list_head *list, bool retry_tx)
--	__releases(txq->axq_lock)
--	__acquires(txq->axq_lock)
- {
- 	struct ath_buf *bf, *lastbf;
- 	struct list_head bf_head;
-@@ -1462,13 +1445,11 @@ static void ath_drain_txq_list(struct at
- 		if (bf_is_ampdu_not_probing(bf))
- 			txq->axq_ampdu_depth--;
- 
--		spin_unlock_bh(&txq->axq_lock);
- 		if (bf_isampdu(bf))
- 			ath_tx_complete_aggr(sc, txq, bf, &bf_head, &ts, 0,
- 					     retry_tx);
- 		else
- 			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
--		spin_lock_bh(&txq->axq_lock);
- 	}
- }
- 
-@@ -1847,8 +1828,6 @@ static void ath_tx_start_dma(struct ath_
- 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
- 	struct ath_buf *bf;
- 
--	spin_lock_bh(&txctl->txq->axq_lock);
--
- 	if ((tx_info->flags & IEEE80211_TX_CTL_AMPDU) && tid) {
- 		/*
- 		 * Try aggregation if it's a unicast data frame
-@@ -1858,7 +1837,7 @@ static void ath_tx_start_dma(struct ath_
- 	} else {
- 		bf = ath_tx_setup_buffer(sc, txctl->txq, tid, skb);
- 		if (!bf)
--			goto out;
-+			return;
- 
- 		bf->bf_state.bfs_paprd = txctl->paprd;
- 
-@@ -1867,9 +1846,6 @@ static void ath_tx_start_dma(struct ath_
- 
- 		ath_tx_send_normal(sc, txctl->txq, tid, skb);
- 	}
--
--out:
--	spin_unlock_bh(&txctl->txq->axq_lock);
- }
- 
- /* Upon failure caller should free skb */
-@@ -1949,15 +1925,19 @@ int ath_tx_start(struct ieee80211_hw *hw
- 	 */
- 
- 	q = skb_get_queue_mapping(skb);
-+
- 	spin_lock_bh(&txq->axq_lock);
-+
- 	if (txq == sc->tx.txq_map[q] &&
- 	    ++txq->pending_frames > ATH_MAX_QDEPTH && !txq->stopped) {
- 		ieee80211_stop_queue(sc->hw, q);
- 		txq->stopped = 1;
- 	}
--	spin_unlock_bh(&txq->axq_lock);
- 
- 	ath_tx_start_dma(sc, skb, txctl, tid);
-+
-+	spin_unlock_bh(&txq->axq_lock);
-+
- 	return 0;
- }
- 
-@@ -2003,7 +1983,6 @@ static void ath_tx_complete(struct ath_s
- 
- 	q = skb_get_queue_mapping(skb);
- 	if (txq == sc->tx.txq_map[q]) {
--		spin_lock_bh(&txq->axq_lock);
- 		if (WARN_ON(--txq->pending_frames < 0))
- 			txq->pending_frames = 0;
- 
-@@ -2011,7 +1990,6 @@ static void ath_tx_complete(struct ath_s
- 			ieee80211_wake_queue(sc->hw, q);
- 			txq->stopped = 0;
- 		}
--		spin_unlock_bh(&txq->axq_lock);
- 	}
- 
- 	ieee80211_tx_status(hw, skb);
-@@ -2117,8 +2095,6 @@ static void ath_tx_rc_status(struct ath_
- static void ath_tx_process_buffer(struct ath_softc *sc, struct ath_txq *txq,
- 				  struct ath_tx_status *ts, struct ath_buf *bf,
- 				  struct list_head *bf_head)
--	__releases(txq->axq_lock)
--	__acquires(txq->axq_lock)
- {
- 	int txok;
- 
-@@ -2128,16 +2104,12 @@ static void ath_tx_process_buffer(struct
- 	if (bf_is_ampdu_not_probing(bf))
- 		txq->axq_ampdu_depth--;
- 
--	spin_unlock_bh(&txq->axq_lock);
--
- 	if (!bf_isampdu(bf)) {
- 		ath_tx_rc_status(sc, bf, ts, 1, txok ? 0 : 1, txok);
- 		ath_tx_complete_buf(sc, bf, txq, bf_head, ts, txok);
- 	} else
- 		ath_tx_complete_aggr(sc, txq, bf, bf_head, ts, txok, true);
- 
--	spin_lock_bh(&txq->axq_lock);
--
- 	if (sc->sc_flags & SC_OP_TXAGGR)
- 		ath_txq_schedule(sc, txq);
- }
diff '--exclude=.svn' -Nur package/mac80211/patches/564-ath9k_remove_imr_mib.patch ../openwrt-trunk/package/mac80211/patches/564-ath9k_remove_imr_mib.patch
--- package/mac80211/patches/564-ath9k_remove_imr_mib.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/564-ath9k_remove_imr_mib.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,12 @@
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -986,9 +986,6 @@ static void ath9k_hw_init_interrupt_mask
+ 	else
+ 		imr_reg |= AR_IMR_TXOK;
+ 
+-	if (opmode == NL80211_IFTYPE_AP)
+-		imr_reg |= AR_IMR_MIB;
+-
+ 	ENABLE_REGWRITE_BUFFER(ah);
+ 
+ 	REG_WRITE(ah, AR_IMR, imr_reg);
diff '--exclude=.svn' -Nur package/mac80211/patches/564-ath9k_track_last_bar.patch ../openwrt-trunk/package/mac80211/patches/564-ath9k_track_last_bar.patch
--- package/mac80211/patches/564-ath9k_track_last_bar.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/564-ath9k_track_last_bar.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,82 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -242,6 +242,7 @@ struct ath_atx_tid {
- 	struct ath_atx_ac *ac;
- 	unsigned long tx_buf[BITS_TO_LONGS(ATH_TID_MAX_BUFS)];
- 	int buf_pending;
-+	int bar_index;
- 	u16 seq_start;
- 	u16 seq_next;
- 	u16 baw_size;
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -206,6 +206,8 @@ static void ath_tx_update_baw(struct ath
- 	while (tid->baw_head != tid->baw_tail && !test_bit(tid->baw_head, tid->tx_buf)) {
- 		INCR(tid->seq_start, IEEE80211_SEQ_MAX);
- 		INCR(tid->baw_head, ATH_TID_MAX_BUFS);
-+		if (tid->bar_index >= 0)
-+			tid->bar_index--;
- 	}
- }
- 
-@@ -263,6 +265,7 @@ static void ath_tid_drain(struct ath_sof
- 
- 	tid->seq_next = tid->seq_start;
- 	tid->baw_tail = tid->baw_head;
-+	tid->bar_index = -1;
- }
- 
- static void ath_tx_set_retry(struct ath_softc *sc, struct ath_txq *txq,
-@@ -561,8 +564,12 @@ static void ath_tx_complete_aggr(struct 
- 		bf = bf_next;
- 	}
- 
--	if (bar_index >= 0)
-+	if (bar_index >= 0) {
-+		u16 bar_seq = ATH_BA_INDEX2SEQ(seq_first, bar_index);
- 		ath_send_bar(tid, ATH_BA_INDEX2SEQ(seq_first, bar_index + 1));
-+		if (BAW_WITHIN(tid->seq_start, tid->baw_size, bar_seq))
-+			tid->bar_index = ATH_BA_INDEX(tid->seq_start, bar_seq);
-+	}
- 
- 	/* prepend un-acked frames to the beginning of the pending frame queue */
- 	if (!skb_queue_empty(&bf_pending)) {
-@@ -789,8 +796,6 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- 
- 		bf->bf_state.bf_type = BUF_AMPDU | BUF_AGGR;
- 		seqno = bf->bf_state.seqno;
--		if (!bf_first)
--			bf_first = bf;
- 
- 		/* do not step over block-ack window */
- 		if (!BAW_WITHIN(tid->seq_start, tid->baw_size, seqno)) {
-@@ -798,6 +803,21 @@ static enum ATH_AGGR_STATUS ath_tx_form_
- 			break;
- 		}
- 
-+		if (tid->bar_index > ATH_BA_INDEX(tid->seq_start, seqno)) {
-+			struct ath_tx_status ts = {};
-+			struct list_head bf_head;
-+
-+			INIT_LIST_HEAD(&bf_head);
-+			list_add(&bf->list, &bf_head);
-+			__skb_unlink(skb, &tid->buf_q);
-+			ath_tx_update_baw(sc, tid, seqno);
-+			ath_tx_complete_buf(sc, bf, txq, &bf_head, &ts, 0);
-+			continue;
-+		}
-+
-+		if (!bf_first)
-+			bf_first = bf;
-+
- 		if (!rl) {
- 			aggr_limit = ath_lookup_rate(sc, bf, tid);
- 			rl = 1;
-@@ -1141,6 +1161,7 @@ int ath_tx_aggr_start(struct ath_softc *
- 	txtid->state |= AGGR_ADDBA_PROGRESS;
- 	txtid->paused = true;
- 	*ssn = txtid->seq_start = txtid->seq_next;
-+	txtid->bar_index = -1;
- 
- 	memset(txtid->tx_buf, 0, sizeof(txtid->tx_buf));
- 	txtid->baw_head = txtid->baw_tail = 0;
diff '--exclude=.svn' -Nur package/mac80211/patches/565-ath9k_fix_lockup.patch ../openwrt-trunk/package/mac80211/patches/565-ath9k_fix_lockup.patch
--- package/mac80211/patches/565-ath9k_fix_lockup.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/565-ath9k_fix_lockup.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,299 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/xmit.c
-+++ b/drivers/net/wireless/ath/ath9k/xmit.c
-@@ -104,6 +104,29 @@ static int ath_max_4ms_framelen[4][32] =
- /* Aggregation logic */
- /*********************/
- 
-+static void ath_txq_lock(struct ath_softc *sc, struct ath_txq *txq)
-+{
-+	spin_lock_bh(&txq->axq_lock);
-+}
-+
-+static void ath_txq_unlock(struct ath_softc *sc, struct ath_txq *txq)
-+{
-+	spin_unlock_bh(&txq->axq_lock);
-+}
-+
-+static void ath_txq_unlock_complete(struct ath_softc *sc, struct ath_txq *txq)
-+{
-+	struct sk_buff_head q;
-+	struct sk_buff *skb;
-+
-+	__skb_queue_head_init(&q);
-+	skb_queue_splice_init(&txq->complete_q, &q);
-+	spin_unlock_bh(&txq->axq_lock);
-+
-+	while ((skb = __skb_dequeue(&q)))
-+		ieee80211_tx_status(sc->hw, skb);
-+}
-+
- static void ath_tx_queue_tid(struct ath_txq *txq, struct ath_atx_tid *tid)
- {
- 	struct ath_atx_ac *ac = tid->ac;
-@@ -130,7 +153,7 @@ static void ath_tx_resume_tid(struct ath
- 
- 	WARN_ON(!tid->paused);
- 
--	spin_lock_bh(&txq->axq_lock);
-+	ath_txq_lock(sc, txq);
- 	tid->paused = false;
- 
- 	if (skb_queue_empty(&tid->buf_q))
-@@ -139,7 +162,7 @@ static void ath_tx_resume_tid(struct ath
- 	ath_tx_queue_tid(txq, tid);
- 	ath_txq_schedule(sc, txq);
- unlock:
--	spin_unlock_bh(&txq->axq_lock);
-+	ath_txq_unlock_complete(sc, txq);
- }
- 
- static struct ath_frame_info *get_frame_info(struct sk_buff *skb)
-@@ -189,8 +212,11 @@ static void ath_tx_flush_tid(struct ath_
- 		tid->state &= ~AGGR_CLEANUP;
- 	}
- 
--	if (sendbar)
-+	if (sendbar) {
-+		ath_txq_unlock(sc, txq);
- 		ath_send_bar(tid, tid->seq_start);
-+		ath_txq_lock(sc, txq);
-+	}
- }
- 
- static void ath_tx_update_baw(struct ath_softc *sc, struct ath_atx_tid *tid,
-@@ -564,13 +590,6 @@ static void ath_tx_complete_aggr(struct 
- 		bf = bf_next;
- 	}
- 
--	if (bar_index >= 0) {
--		u16 bar_seq = ATH_BA_INDEX2SEQ(seq_first, bar_index);
--		ath_send_bar(tid, ATH_BA_INDEX2SEQ(seq_first, bar_index + 1));
--		if (BAW_WITHIN(tid->seq_start, tid->baw_size, bar_seq))
--			tid->bar_index = ATH_BA_INDEX(tid->seq_start, bar_seq);
--	}
--
- 	/* prepend un-acked frames to the beginning of the pending frame queue */
- 	if (!skb_queue_empty(&bf_pending)) {
- 		if (an->sleeping)
-@@ -585,6 +604,17 @@ static void ath_tx_complete_aggr(struct 
- 		}
- 	}
- 
-+	if (bar_index >= 0) {
-+		u16 bar_seq = ATH_BA_INDEX2SEQ(seq_first, bar_index);
-+
-+		if (BAW_WITHIN(tid->seq_start, tid->baw_size, bar_seq))
-+			tid->bar_index = ATH_BA_INDEX(tid->seq_start, bar_seq);
-+
-+		ath_txq_unlock(sc, txq);
-+		ath_send_bar(tid, ATH_BA_INDEX2SEQ(seq_first, bar_index + 1));
-+		ath_txq_lock(sc, txq);
-+	}
-+
- 	if (tid->state & AGGR_CLEANUP)
- 		ath_tx_flush_tid(sc, tid);
- 
-@@ -1183,7 +1213,7 @@ void ath_tx_aggr_stop(struct ath_softc *
- 		return;
- 	}
- 
--	spin_lock_bh(&txq->axq_lock);
-+	ath_txq_lock(sc, txq);
- 	txtid->paused = true;
- 
- 	/*
-@@ -1198,7 +1228,7 @@ void ath_tx_aggr_stop(struct ath_softc *
- 		txtid->state &= ~AGGR_ADDBA_COMPLETE;
- 
- 	ath_tx_flush_tid(sc, txtid);
--	spin_unlock_bh(&txq->axq_lock);
-+	ath_txq_unlock_complete(sc, txq);
- }
- 
- void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
-@@ -1219,7 +1249,7 @@ void ath_tx_aggr_sleep(struct ieee80211_
- 		ac = tid->ac;
- 		txq = ac->txq;
- 
--		spin_lock_bh(&txq->axq_lock);
-+		ath_txq_lock(sc, txq);
- 
- 		buffered = !skb_queue_empty(&tid->buf_q);
- 
-@@ -1231,7 +1261,7 @@ void ath_tx_aggr_sleep(struct ieee80211_
- 			list_del(&ac->list);
- 		}
- 
--		spin_unlock_bh(&txq->axq_lock);
-+		ath_txq_unlock(sc, txq);
- 
- 		ieee80211_sta_set_buffered(sta, tidno, buffered);
- 	}
-@@ -1250,7 +1280,7 @@ void ath_tx_aggr_wakeup(struct ath_softc
- 		ac = tid->ac;
- 		txq = ac->txq;
- 
--		spin_lock_bh(&txq->axq_lock);
-+		ath_txq_lock(sc, txq);
- 		ac->clear_ps_filter = true;
- 
- 		if (!skb_queue_empty(&tid->buf_q) && !tid->paused) {
-@@ -1258,7 +1288,7 @@ void ath_tx_aggr_wakeup(struct ath_softc
- 			ath_txq_schedule(sc, txq);
- 		}
- 
--		spin_unlock_bh(&txq->axq_lock);
-+		ath_txq_unlock_complete(sc, txq);
- 	}
- }
- 
-@@ -1358,6 +1388,7 @@ struct ath_txq *ath_txq_setup(struct ath
- 		txq->axq_qnum = axq_qnum;
- 		txq->mac80211_qnum = -1;
- 		txq->axq_link = NULL;
-+		__skb_queue_head_init(&txq->complete_q);
- 		INIT_LIST_HEAD(&txq->axq_q);
- 		INIT_LIST_HEAD(&txq->axq_acq);
- 		spin_lock_init(&txq->axq_lock);
-@@ -1482,7 +1513,8 @@ static void ath_drain_txq_list(struct at
-  */
- void ath_draintxq(struct ath_softc *sc, struct ath_txq *txq, bool retry_tx)
- {
--	spin_lock_bh(&txq->axq_lock);
-+	ath_txq_lock(sc, txq);
-+
- 	if (sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_EDMA) {
- 		int idx = txq->txq_tailidx;
- 
-@@ -1503,7 +1535,7 @@ void ath_draintxq(struct ath_softc *sc, 
- 	if ((sc->sc_flags & SC_OP_TXAGGR) && !retry_tx)
- 		ath_txq_drain_pending_buffers(sc, txq);
- 
--	spin_unlock_bh(&txq->axq_lock);
-+	ath_txq_unlock_complete(sc, txq);
- }
- 
- bool ath_drain_all_txq(struct ath_softc *sc, bool retry_tx)
-@@ -1947,7 +1979,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 
- 	q = skb_get_queue_mapping(skb);
- 
--	spin_lock_bh(&txq->axq_lock);
-+	ath_txq_lock(sc, txq);
- 
- 	if (txq == sc->tx.txq_map[q] &&
- 	    ++txq->pending_frames > ATH_MAX_QDEPTH && !txq->stopped) {
-@@ -1957,7 +1989,7 @@ int ath_tx_start(struct ieee80211_hw *hw
- 
- 	ath_tx_start_dma(sc, skb, txctl, tid);
- 
--	spin_unlock_bh(&txq->axq_lock);
-+	ath_txq_unlock(sc, txq);
- 
- 	return 0;
- }
-@@ -1969,7 +2001,6 @@ int ath_tx_start(struct ieee80211_hw *hw
- static void ath_tx_complete(struct ath_softc *sc, struct sk_buff *skb,
- 			    int tx_flags, struct ath_txq *txq)
- {
--	struct ieee80211_hw *hw = sc->hw;
- 	struct ieee80211_tx_info *tx_info = IEEE80211_SKB_CB(skb);
- 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- 	struct ieee80211_hdr * hdr = (struct ieee80211_hdr *)skb->data;
-@@ -2013,7 +2044,7 @@ static void ath_tx_complete(struct ath_s
- 		}
- 	}
- 
--	ieee80211_tx_status(hw, skb);
-+	__skb_queue_tail(&txq->complete_q, skb);
- }
- 
- static void ath_tx_complete_buf(struct ath_softc *sc, struct ath_buf *bf,
-@@ -2149,7 +2180,7 @@ static void ath_tx_processq(struct ath_s
- 		txq->axq_qnum, ath9k_hw_gettxbuf(sc->sc_ah, txq->axq_qnum),
- 		txq->axq_link);
- 
--	spin_lock_bh(&txq->axq_lock);
-+	ath_txq_lock(sc, txq);
- 	for (;;) {
- 		if (work_pending(&sc->hw_reset_work))
- 			break;
-@@ -2208,7 +2239,7 @@ static void ath_tx_processq(struct ath_s
- 
- 		ath_tx_process_buffer(sc, txq, &ts, bf, &bf_head);
- 	}
--	spin_unlock_bh(&txq->axq_lock);
-+	ath_txq_unlock_complete(sc, txq);
- }
- 
- static void ath_tx_complete_poll_work(struct work_struct *work)
-@@ -2225,17 +2256,17 @@ static void ath_tx_complete_poll_work(st
- 	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
- 		if (ATH_TXQ_SETUP(sc, i)) {
- 			txq = &sc->tx.txq[i];
--			spin_lock_bh(&txq->axq_lock);
-+			ath_txq_lock(sc, txq);
- 			if (txq->axq_depth) {
- 				if (txq->axq_tx_inprogress) {
- 					needreset = true;
--					spin_unlock_bh(&txq->axq_lock);
-+					ath_txq_unlock(sc, txq);
- 					break;
- 				} else {
- 					txq->axq_tx_inprogress = true;
- 				}
- 			}
--			spin_unlock_bh(&txq->axq_lock);
-+			ath_txq_unlock_complete(sc, txq);
- 		}
- 
- 	if (needreset) {
-@@ -2293,10 +2324,10 @@ void ath_tx_edma_tasklet(struct ath_soft
- 
- 		txq = &sc->tx.txq[ts.qid];
- 
--		spin_lock_bh(&txq->axq_lock);
-+		ath_txq_lock(sc, txq);
- 
- 		if (list_empty(&txq->txq_fifo[txq->txq_tailidx])) {
--			spin_unlock_bh(&txq->axq_lock);
-+			ath_txq_unlock(sc, txq);
- 			return;
- 		}
- 
-@@ -2322,7 +2353,7 @@ void ath_tx_edma_tasklet(struct ath_soft
- 		}
- 
- 		ath_tx_process_buffer(sc, txq, &ts, bf, &bf_head);
--		spin_unlock_bh(&txq->axq_lock);
-+		ath_txq_unlock_complete(sc, txq);
- 	}
- }
- 
-@@ -2460,7 +2491,7 @@ void ath_tx_node_cleanup(struct ath_soft
- 		ac = tid->ac;
- 		txq = ac->txq;
- 
--		spin_lock_bh(&txq->axq_lock);
-+		ath_txq_lock(sc, txq);
- 
- 		if (tid->sched) {
- 			list_del(&tid->list);
-@@ -2476,6 +2507,6 @@ void ath_tx_node_cleanup(struct ath_soft
- 		tid->state &= ~AGGR_ADDBA_COMPLETE;
- 		tid->state &= ~AGGR_CLEANUP;
- 
--		spin_unlock_bh(&txq->axq_lock);
-+		ath_txq_unlock(sc, txq);
- 	}
- }
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -196,6 +196,7 @@ struct ath_txq {
- 	u8 txq_headidx;
- 	u8 txq_tailidx;
- 	int pending_frames;
-+	struct sk_buff_head complete_q;
- };
- 
- struct ath_atx_ac {
diff '--exclude=.svn' -Nur package/mac80211/patches/566-ath9k_fix_keymiss.patch ../openwrt-trunk/package/mac80211/patches/566-ath9k_fix_keymiss.patch
--- package/mac80211/patches/566-ath9k_fix_keymiss.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/566-ath9k_fix_keymiss.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,32 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_mac.c
-@@ -558,10 +558,11 @@ int ath9k_hw_process_rxdesc_edma(struct 
- 			rxs->rs_status |= ATH9K_RXERR_DECRYPT;
- 		else if (rxsp->status11 & AR_MichaelErr)
- 			rxs->rs_status |= ATH9K_RXERR_MIC;
--		if (rxsp->status11 & AR_KeyMiss)
--			rxs->rs_status |= ATH9K_RXERR_KEYMISS;
- 	}
- 
-+	if (rxsp->status11 & AR_KeyMiss)
-+		rxs->rs_status |= ATH9K_RXERR_KEYMISS;
-+
- 	return 0;
- }
- EXPORT_SYMBOL(ath9k_hw_process_rxdesc_edma);
---- a/drivers/net/wireless/ath/ath9k/mac.c
-+++ b/drivers/net/wireless/ath/ath9k/mac.c
-@@ -621,10 +621,11 @@ int ath9k_hw_rxprocdesc(struct ath_hw *a
- 			rs->rs_status |= ATH9K_RXERR_DECRYPT;
- 		else if (ads.ds_rxstatus8 & AR_MichaelErr)
- 			rs->rs_status |= ATH9K_RXERR_MIC;
--		if (ads.ds_rxstatus8 & AR_KeyMiss)
--			rs->rs_status |= ATH9K_RXERR_KEYMISS;
- 	}
- 
-+	if (ads.ds_rxstatus8 & AR_KeyMiss)
-+		rs->rs_status |= ATH9K_RXERR_KEYMISS;
-+
- 	return 0;
- }
- EXPORT_SYMBOL(ath9k_hw_rxprocdesc);
diff '--exclude=.svn' -Nur package/mac80211/patches/567-ath9k_fix_initvals.patch ../openwrt-trunk/package/mac80211/patches/567-ath9k_fix_initvals.patch
--- package/mac80211/patches/567-ath9k_fix_initvals.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/567-ath9k_fix_initvals.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,208 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_2p2_initvals.h
-@@ -835,108 +835,108 @@ static const u32 ar9300_2p2_baseband_cor
- 
- static const u32 ar9300Modes_high_power_tx_gain_table_2p2[][5] = {
- 	/* Addr      5G_HT20     5G_HT40     2G_HT40     2G_HT20   */
--	{0x0000a2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
--	{0x0000a2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
--	{0x0000a2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
-+	{0x0000a2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
-+	{0x0000a2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
-+	{0x0000a2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
- 	{0x0000a2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
--	{0x0000a410, 0x000050d9, 0x000050d9, 0x000050d9, 0x000050d9},
--	{0x0000a500, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
--	{0x0000a504, 0x06000003, 0x06000003, 0x04000002, 0x04000002},
--	{0x0000a508, 0x0a000020, 0x0a000020, 0x08000004, 0x08000004},
--	{0x0000a50c, 0x10000023, 0x10000023, 0x0b000200, 0x0b000200},
--	{0x0000a510, 0x15000028, 0x15000028, 0x0f000202, 0x0f000202},
--	{0x0000a514, 0x1b00002b, 0x1b00002b, 0x12000400, 0x12000400},
--	{0x0000a518, 0x1f020028, 0x1f020028, 0x16000402, 0x16000402},
--	{0x0000a51c, 0x2502002b, 0x2502002b, 0x19000404, 0x19000404},
--	{0x0000a520, 0x2a04002a, 0x2a04002a, 0x1c000603, 0x1c000603},
--	{0x0000a524, 0x2e06002a, 0x2e06002a, 0x21000a02, 0x21000a02},
--	{0x0000a528, 0x3302202d, 0x3302202d, 0x25000a04, 0x25000a04},
--	{0x0000a52c, 0x3804202c, 0x3804202c, 0x28000a20, 0x28000a20},
--	{0x0000a530, 0x3c06202c, 0x3c06202c, 0x2c000e20, 0x2c000e20},
--	{0x0000a534, 0x4108202d, 0x4108202d, 0x30000e22, 0x30000e22},
--	{0x0000a538, 0x4506402d, 0x4506402d, 0x34000e24, 0x34000e24},
--	{0x0000a53c, 0x4906222d, 0x4906222d, 0x38001640, 0x38001640},
--	{0x0000a540, 0x4d062231, 0x4d062231, 0x3c001660, 0x3c001660},
--	{0x0000a544, 0x50082231, 0x50082231, 0x3f001861, 0x3f001861},
--	{0x0000a548, 0x5608422e, 0x5608422e, 0x43001a81, 0x43001a81},
--	{0x0000a54c, 0x5a08442e, 0x5a08442e, 0x47001a83, 0x47001a83},
--	{0x0000a550, 0x5e0a4431, 0x5e0a4431, 0x4a001c84, 0x4a001c84},
--	{0x0000a554, 0x640a4432, 0x640a4432, 0x4e001ce3, 0x4e001ce3},
--	{0x0000a558, 0x680a4434, 0x680a4434, 0x52001ce5, 0x52001ce5},
--	{0x0000a55c, 0x6c0a6434, 0x6c0a6434, 0x56001ce9, 0x56001ce9},
--	{0x0000a560, 0x6f0a6633, 0x6f0a6633, 0x5a001ceb, 0x5a001ceb},
--	{0x0000a564, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a568, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a56c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a570, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a574, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a578, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a57c, 0x730c6634, 0x730c6634, 0x5d001eec, 0x5d001eec},
--	{0x0000a580, 0x00800000, 0x00800000, 0x00800000, 0x00800000},
--	{0x0000a584, 0x06800003, 0x06800003, 0x04800002, 0x04800002},
--	{0x0000a588, 0x0a800020, 0x0a800020, 0x08800004, 0x08800004},
--	{0x0000a58c, 0x10800023, 0x10800023, 0x0b800200, 0x0b800200},
--	{0x0000a590, 0x15800028, 0x15800028, 0x0f800202, 0x0f800202},
--	{0x0000a594, 0x1b80002b, 0x1b80002b, 0x12800400, 0x12800400},
--	{0x0000a598, 0x1f820028, 0x1f820028, 0x16800402, 0x16800402},
--	{0x0000a59c, 0x2582002b, 0x2582002b, 0x19800404, 0x19800404},
--	{0x0000a5a0, 0x2a84002a, 0x2a84002a, 0x1c800603, 0x1c800603},
--	{0x0000a5a4, 0x2e86002a, 0x2e86002a, 0x21800a02, 0x21800a02},
--	{0x0000a5a8, 0x3382202d, 0x3382202d, 0x25800a04, 0x25800a04},
--	{0x0000a5ac, 0x3884202c, 0x3884202c, 0x28800a20, 0x28800a20},
--	{0x0000a5b0, 0x3c86202c, 0x3c86202c, 0x2c800e20, 0x2c800e20},
--	{0x0000a5b4, 0x4188202d, 0x4188202d, 0x30800e22, 0x30800e22},
--	{0x0000a5b8, 0x4586402d, 0x4586402d, 0x34800e24, 0x34800e24},
--	{0x0000a5bc, 0x4986222d, 0x4986222d, 0x38801640, 0x38801640},
--	{0x0000a5c0, 0x4d862231, 0x4d862231, 0x3c801660, 0x3c801660},
--	{0x0000a5c4, 0x50882231, 0x50882231, 0x3f801861, 0x3f801861},
--	{0x0000a5c8, 0x5688422e, 0x5688422e, 0x43801a81, 0x43801a81},
--	{0x0000a5cc, 0x5a88442e, 0x5a88442e, 0x47801a83, 0x47801a83},
--	{0x0000a5d0, 0x5e8a4431, 0x5e8a4431, 0x4a801c84, 0x4a801c84},
--	{0x0000a5d4, 0x648a4432, 0x648a4432, 0x4e801ce3, 0x4e801ce3},
--	{0x0000a5d8, 0x688a4434, 0x688a4434, 0x52801ce5, 0x52801ce5},
--	{0x0000a5dc, 0x6c8a6434, 0x6c8a6434, 0x56801ce9, 0x56801ce9},
--	{0x0000a5e0, 0x6f8a6633, 0x6f8a6633, 0x5a801ceb, 0x5a801ceb},
--	{0x0000a5e4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5e8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5ec, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5f0, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5f4, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5f8, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
--	{0x0000a5fc, 0x738c6634, 0x738c6634, 0x5d801eec, 0x5d801eec},
-+	{0x0000a410, 0x000050d8, 0x000050d8, 0x000050d9, 0x000050d9},
-+	{0x0000a500, 0x00002220, 0x00002220, 0x00000000, 0x00000000},
-+	{0x0000a504, 0x04002222, 0x04002222, 0x04000002, 0x04000002},
-+	{0x0000a508, 0x09002421, 0x09002421, 0x08000004, 0x08000004},
-+	{0x0000a50c, 0x0d002621, 0x0d002621, 0x0b000200, 0x0b000200},
-+	{0x0000a510, 0x13004620, 0x13004620, 0x0f000202, 0x0f000202},
-+	{0x0000a514, 0x19004a20, 0x19004a20, 0x11000400, 0x11000400},
-+	{0x0000a518, 0x1d004e20, 0x1d004e20, 0x15000402, 0x15000402},
-+	{0x0000a51c, 0x21005420, 0x21005420, 0x19000404, 0x19000404},
-+	{0x0000a520, 0x26005e20, 0x26005e20, 0x1b000603, 0x1b000603},
-+	{0x0000a524, 0x2b005e40, 0x2b005e40, 0x1f000a02, 0x1f000a02},
-+	{0x0000a528, 0x2f005e42, 0x2f005e42, 0x23000a04, 0x23000a04},
-+	{0x0000a52c, 0x33005e44, 0x33005e44, 0x26000a20, 0x26000a20},
-+	{0x0000a530, 0x38005e65, 0x38005e65, 0x2a000e20, 0x2a000e20},
-+	{0x0000a534, 0x3c005e69, 0x3c005e69, 0x2e000e22, 0x2e000e22},
-+	{0x0000a538, 0x40005e6b, 0x40005e6b, 0x31000e24, 0x31000e24},
-+	{0x0000a53c, 0x44005e6d, 0x44005e6d, 0x34001640, 0x34001640},
-+	{0x0000a540, 0x49005e72, 0x49005e72, 0x38001660, 0x38001660},
-+	{0x0000a544, 0x4e005eb2, 0x4e005eb2, 0x3b001861, 0x3b001861},
-+	{0x0000a548, 0x53005f12, 0x53005f12, 0x3e001a81, 0x3e001a81},
-+	{0x0000a54c, 0x59025eb2, 0x59025eb2, 0x42001a83, 0x42001a83},
-+	{0x0000a550, 0x5e025f12, 0x5e025f12, 0x44001c84, 0x44001c84},
-+	{0x0000a554, 0x61027f12, 0x61027f12, 0x48001ce3, 0x48001ce3},
-+	{0x0000a558, 0x6702bf12, 0x6702bf12, 0x4c001ce5, 0x4c001ce5},
-+	{0x0000a55c, 0x6b02bf14, 0x6b02bf14, 0x50001ce9, 0x50001ce9},
-+	{0x0000a560, 0x6f02bf16, 0x6f02bf16, 0x54001ceb, 0x54001ceb},
-+	{0x0000a564, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a568, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a56c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a570, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a574, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a578, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a57c, 0x6f02bf16, 0x6f02bf16, 0x56001eec, 0x56001eec},
-+	{0x0000a580, 0x00802220, 0x00802220, 0x00800000, 0x00800000},
-+	{0x0000a584, 0x04802222, 0x04802222, 0x04800002, 0x04800002},
-+	{0x0000a588, 0x09802421, 0x09802421, 0x08800004, 0x08800004},
-+	{0x0000a58c, 0x0d802621, 0x0d802621, 0x0b800200, 0x0b800200},
-+	{0x0000a590, 0x13804620, 0x13804620, 0x0f800202, 0x0f800202},
-+	{0x0000a594, 0x19804a20, 0x19804a20, 0x11800400, 0x11800400},
-+	{0x0000a598, 0x1d804e20, 0x1d804e20, 0x15800402, 0x15800402},
-+	{0x0000a59c, 0x21805420, 0x21805420, 0x19800404, 0x19800404},
-+	{0x0000a5a0, 0x26805e20, 0x26805e20, 0x1b800603, 0x1b800603},
-+	{0x0000a5a4, 0x2b805e40, 0x2b805e40, 0x1f800a02, 0x1f800a02},
-+	{0x0000a5a8, 0x2f805e42, 0x2f805e42, 0x23800a04, 0x23800a04},
-+	{0x0000a5ac, 0x33805e44, 0x33805e44, 0x26800a20, 0x26800a20},
-+	{0x0000a5b0, 0x38805e65, 0x38805e65, 0x2a800e20, 0x2a800e20},
-+	{0x0000a5b4, 0x3c805e69, 0x3c805e69, 0x2e800e22, 0x2e800e22},
-+	{0x0000a5b8, 0x40805e6b, 0x40805e6b, 0x31800e24, 0x31800e24},
-+	{0x0000a5bc, 0x44805e6d, 0x44805e6d, 0x34801640, 0x34801640},
-+	{0x0000a5c0, 0x49805e72, 0x49805e72, 0x38801660, 0x38801660},
-+	{0x0000a5c4, 0x4e805eb2, 0x4e805eb2, 0x3b801861, 0x3b801861},
-+	{0x0000a5c8, 0x53805f12, 0x53805f12, 0x3e801a81, 0x3e801a81},
-+	{0x0000a5cc, 0x59825eb2, 0x59825eb2, 0x42801a83, 0x42801a83},
-+	{0x0000a5d0, 0x5e825f12, 0x5e825f12, 0x44801c84, 0x44801c84},
-+	{0x0000a5d4, 0x61827f12, 0x61827f12, 0x48801ce3, 0x48801ce3},
-+	{0x0000a5d8, 0x6782bf12, 0x6782bf12, 0x4c801ce5, 0x4c801ce5},
-+	{0x0000a5dc, 0x6b82bf14, 0x6b82bf14, 0x50801ce9, 0x50801ce9},
-+	{0x0000a5e0, 0x6f82bf16, 0x6f82bf16, 0x54801ceb, 0x54801ceb},
-+	{0x0000a5e4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5e8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5ec, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5f0, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5f4, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5f8, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
-+	{0x0000a5fc, 0x6f82bf16, 0x6f82bf16, 0x56801eec, 0x56801eec},
- 	{0x0000a600, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
- 	{0x0000a604, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
--	{0x0000a608, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
--	{0x0000a60c, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
--	{0x0000a610, 0x01804601, 0x01804601, 0x00000000, 0x00000000},
--	{0x0000a614, 0x01804601, 0x01804601, 0x01404000, 0x01404000},
--	{0x0000a618, 0x01804601, 0x01804601, 0x01404501, 0x01404501},
--	{0x0000a61c, 0x01804601, 0x01804601, 0x02008501, 0x02008501},
--	{0x0000a620, 0x03408d02, 0x03408d02, 0x0280ca03, 0x0280ca03},
--	{0x0000a624, 0x0300cc03, 0x0300cc03, 0x03010c04, 0x03010c04},
--	{0x0000a628, 0x03410d04, 0x03410d04, 0x04014c04, 0x04014c04},
--	{0x0000a62c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a630, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a634, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a638, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000a63c, 0x03410d04, 0x03410d04, 0x04015005, 0x04015005},
--	{0x0000b2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
--	{0x0000b2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
--	{0x0000b2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
-+	{0x0000a608, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
-+	{0x0000a60c, 0x00000000, 0x00000000, 0x00000000, 0x00000000},
-+	{0x0000a610, 0x00804000, 0x00804000, 0x00000000, 0x00000000},
-+	{0x0000a614, 0x00804201, 0x00804201, 0x01404000, 0x01404000},
-+	{0x0000a618, 0x0280c802, 0x0280c802, 0x01404501, 0x01404501},
-+	{0x0000a61c, 0x0280ca03, 0x0280ca03, 0x02008501, 0x02008501},
-+	{0x0000a620, 0x04c15104, 0x04c15104, 0x0280ca03, 0x0280ca03},
-+	{0x0000a624, 0x04c15305, 0x04c15305, 0x03010c04, 0x03010c04},
-+	{0x0000a628, 0x04c15305, 0x04c15305, 0x04014c04, 0x04014c04},
-+	{0x0000a62c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a630, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a634, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a638, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000a63c, 0x04c15305, 0x04c15305, 0x04015005, 0x04015005},
-+	{0x0000b2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
-+	{0x0000b2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
-+	{0x0000b2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
- 	{0x0000b2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
--	{0x0000c2dc, 0x000cfff0, 0x000cfff0, 0x03aaa352, 0x03aaa352},
--	{0x0000c2e0, 0x000f0000, 0x000f0000, 0x03ccc584, 0x03ccc584},
--	{0x0000c2e4, 0x03f00000, 0x03f00000, 0x03f0f800, 0x03f0f800},
-+	{0x0000c2dc, 0x0380c7fc, 0x0380c7fc, 0x03aaa352, 0x03aaa352},
-+	{0x0000c2e0, 0x0000f800, 0x0000f800, 0x03ccc584, 0x03ccc584},
-+	{0x0000c2e4, 0x03ff0000, 0x03ff0000, 0x03f0f800, 0x03f0f800},
- 	{0x0000c2e8, 0x00000000, 0x00000000, 0x03ff0000, 0x03ff0000},
--	{0x00016044, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
--	{0x00016048, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
--	{0x00016068, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
--	{0x00016444, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
--	{0x00016448, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
--	{0x00016468, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
--	{0x00016844, 0x012492d4, 0x012492d4, 0x012492d4, 0x012492d4},
--	{0x00016848, 0x61200001, 0x61200001, 0x66480001, 0x66480001},
--	{0x00016868, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c, 0x6db6db6c},
-+	{0x00016044, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
-+	{0x00016048, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
-+	{0x00016068, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
-+	{0x00016444, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
-+	{0x00016448, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
-+	{0x00016468, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
-+	{0x00016844, 0x056db2e6, 0x056db2e6, 0x056db2e6, 0x056db2e6},
-+	{0x00016848, 0xae480001, 0xae480001, 0xae480001, 0xae480001},
-+	{0x00016868, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c, 0x6eb6db6c},
- };
- 
- static const u32 ar9300Modes_high_ob_db_tx_gain_table_2p2[][5] = {
diff '--exclude=.svn' -Nur package/mac80211/patches/568-ath9k_fix_wep.patch ../openwrt-trunk/package/mac80211/patches/568-ath9k_fix_wep.patch
--- package/mac80211/patches/568-ath9k_fix_wep.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/568-ath9k_fix_wep.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,17 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/recv.c
-+++ b/drivers/net/wireless/ath/ath9k/recv.c
-@@ -823,6 +823,14 @@ static bool ath9k_rx_accept(struct ath_c
- 		(ATH9K_RXERR_DECRYPT | ATH9K_RXERR_CRC | ATH9K_RXERR_MIC |
- 		 ATH9K_RXERR_KEYMISS));
- 
-+	/*
-+	 * Key miss events are only relevant for pairwise keys where the
-+	 * descriptor does contain a valid key index. This has been observed
-+	 * mostly with CCMP encryption.
-+	 */
-+	if (rx_stats->rs_keyix == ATH9K_RXKEYIX_INVALID)
-+		rx_stats->rs_status &= ~ATH9K_RXERR_KEYMISS;
-+
- 	if (!rx_stats->rs_datalen)
- 		return false;
-         /*
diff '--exclude=.svn' -Nur package/mac80211/patches/569-ath9k_fix_cts.patch ../openwrt-trunk/package/mac80211/patches/569-ath9k_fix_cts.patch
--- package/mac80211/patches/569-ath9k_fix_cts.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/569-ath9k_fix_cts.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,21 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1061,13 +1061,16 @@ void ath9k_hw_init_global_settings(struc
- 
- 	/*
- 	 * Workaround for early ACK timeouts, add an offset to match the
--	 * initval's 64us ack timeout value.
-+	 * initval's 64us ack timeout value. Use 48us for the CTS timeout.
- 	 * This was initially only meant to work around an issue with delayed
- 	 * BA frames in some implementations, but it has been found to fix ACK
- 	 * timeout issues in other cases as well.
- 	 */
--	if (conf->channel && conf->channel->band == IEEE80211_BAND_2GHZ)
-+	if (conf->channel && conf->channel->band == IEEE80211_BAND_2GHZ) {
- 		acktimeout += 64 - sifstime - ah->slottime;
-+		ctstimeout += 48 - sifstime - ah->slottime;
-+	}
-+
- 
- 	ath9k_hw_set_sifs_time(ah, sifstime);
- 	ath9k_hw_setslottime(ah, slottime);
diff '--exclude=.svn' -Nur package/mac80211/patches/570-ath9k_mci_static.patch ../openwrt-trunk/package/mac80211/patches/570-ath9k_mci_static.patch
--- package/mac80211/patches/570-ath9k_mci_static.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/570-ath9k_mci_static.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,37 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/mci.c
-+++ b/drivers/net/wireless/ath/ath9k/mci.c
-@@ -234,8 +234,8 @@ static void ath_mci_cal_msg(struct ath_s
- 	}
- }
- 
--void ath_mci_process_profile(struct ath_softc *sc,
--			     struct ath_mci_profile_info *info)
-+static void ath_mci_process_profile(struct ath_softc *sc,
-+				    struct ath_mci_profile_info *info)
- {
- 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- 	struct ath_btcoex *btcoex = &sc->btcoex;
-@@ -261,8 +261,8 @@ void ath_mci_process_profile(struct ath_
- 	ath_mci_update_scheme(sc);
- }
- 
--void ath_mci_process_status(struct ath_softc *sc,
--			    struct ath_mci_profile_status *status)
-+static void ath_mci_process_status(struct ath_softc *sc,
-+				   struct ath_mci_profile_status *status)
- {
- 	struct ath_common *common = ath9k_hw_common(sc->sc_ah);
- 	struct ath_btcoex *btcoex = &sc->btcoex;
---- a/drivers/net/wireless/ath/ath9k/mci.h
-+++ b/drivers/net/wireless/ath/ath9k/mci.h
-@@ -128,10 +128,6 @@ struct ath_mci_coex {
- };
- 
- void ath_mci_flush_profile(struct ath_mci_profile *mci);
--void ath_mci_process_profile(struct ath_softc *sc,
--			     struct ath_mci_profile_info *info);
--void ath_mci_process_status(struct ath_softc *sc,
--			    struct ath_mci_profile_status *status);
- int ath_mci_setup(struct ath_softc *sc);
- void ath_mci_cleanup(struct ath_softc *sc);
- void ath_mci_intr(struct ath_softc *sc);
diff '--exclude=.svn' -Nur package/mac80211/patches/570-ath9k_paprd_hornet_mask.patch ../openwrt-trunk/package/mac80211/patches/570-ath9k_paprd_hornet_mask.patch
--- package/mac80211/patches/570-ath9k_paprd_hornet_mask.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/570-ath9k_paprd_hornet_mask.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,25 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+@@ -142,6 +142,7 @@ static int ar9003_paprd_setup_single_tab
+ 	};
+ 	int training_power;
+ 	int i, val;
++	u32 am2pm_mask = ah->paprd_ratemask;
+ 
+ 	if (IS_CHAN_2GHZ(ah->curchan))
+ 		training_power = ar9003_get_training_power_2g(ah);
+@@ -158,10 +159,13 @@ static int ar9003_paprd_setup_single_tab
+ 	}
+ 	ah->paprd_training_power = training_power;
+ 
++	if (AR_SREV_9330(ah))
++		am2pm_mask = 0;
++
+ 	REG_RMW_FIELD(ah, AR_PHY_PAPRD_AM2AM, AR_PHY_PAPRD_AM2AM_MASK,
+ 		      ah->paprd_ratemask);
+ 	REG_RMW_FIELD(ah, AR_PHY_PAPRD_AM2PM, AR_PHY_PAPRD_AM2PM_MASK,
+-		      ah->paprd_ratemask);
++		      am2pm_mask);
+ 	REG_RMW_FIELD(ah, AR_PHY_PAPRD_HT40, AR_PHY_PAPRD_HT40_MASK,
+ 		      ah->paprd_ratemask_ht40);
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/571-ath9k_btcoex_optional.patch ../openwrt-trunk/package/mac80211/patches/571-ath9k_btcoex_optional.patch
--- package/mac80211/patches/571-ath9k_btcoex_optional.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/571-ath9k_btcoex_optional.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,544 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/Kconfig
-+++ b/drivers/net/wireless/ath/ath9k/Kconfig
-@@ -59,6 +59,14 @@ config ATH9K_RATE_CONTROL
- 	  Say Y, if you want to use the ath9k specific rate control
- 	  module instead of minstrel_ht.
- 
-+config ATH9K_BTCOEX_SUPPORT
-+	bool "Atheros ath9k bluetooth coexistence support"
-+	depends on ATH9K
-+	default y
-+	---help---
-+	  Say Y, if you want to use the ath9k radios together with
-+	  Bluetooth modules in the same system.
-+
- config ATH9K_HTC
-        tristate "Atheros HTC based wireless cards support"
-        depends on USB && MAC80211
---- a/drivers/net/wireless/ath/ath9k/hw.h
-+++ b/drivers/net/wireless/ath/ath9k/hw.h
-@@ -210,7 +210,11 @@ enum ath9k_hw_caps {
- 	ATH9K_HW_CAP_5GHZ			= BIT(14),
- 	ATH9K_HW_CAP_APM			= BIT(15),
- 	ATH9K_HW_CAP_RTT			= BIT(16),
-+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
- 	ATH9K_HW_CAP_MCI			= BIT(17),
-+#else
-+	ATH9K_HW_CAP_MCI			= 0,
-+#endif
- };
- 
- struct ath9k_hw_capabilities {
-@@ -1229,6 +1233,16 @@ void ar9003_mci_sync_bt_state(struct ath
- void ar9003_mci_get_interrupt(struct ath_hw *ah, u32 *raw_intr,
- 			      u32 *rx_msg_intr);
- 
-+#ifdef CONFIG_ATH9K_BTCOEX_SUPPORT
-+static inline enum ath_btcoex_scheme
-+ath9k_hw_get_btcoex_scheme(struct ath_hw *ah)
-+{
-+	return ah->btcoex_hw.scheme;
-+}
-+#else
-+#define ath9k_hw_get_btcoex_scheme(...) ATH_BTCOEX_CFG_NONE
-+#endif
-+
- #define ATH9K_CLOCK_RATE_CCK		22
- #define ATH9K_CLOCK_RATE_5GHZ_OFDM	40
- #define ATH9K_CLOCK_RATE_2GHZ_OFDM	44
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -411,7 +411,7 @@ static int ath9k_init_btcoex(struct ath_
- 	struct ath_hw *ah = sc->sc_ah;
- 	int r;
- 
--	switch (sc->sc_ah->btcoex_hw.scheme) {
-+	switch (ath9k_hw_get_btcoex_scheme(sc->sc_ah)) {
- 	case ATH_BTCOEX_CFG_NONE:
- 		break;
- 	case ATH_BTCOEX_CFG_2WIRE:
-@@ -866,10 +866,10 @@ static void ath9k_deinit_softc(struct at
- 		kfree(sc->sbands[IEEE80211_BAND_5GHZ].channels);
- 
-         if ((sc->btcoex.no_stomp_timer) &&
--	    sc->sc_ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)
-+	    ath9k_hw_get_btcoex_scheme(sc->sc_ah) == ATH_BTCOEX_CFG_3WIRE)
- 		ath_gen_timer_free(sc->sc_ah, sc->btcoex.no_stomp_timer);
- 
--	if (sc->sc_ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_MCI)
-+	if (ath9k_hw_get_btcoex_scheme(sc->sc_ah) == ATH_BTCOEX_CFG_MCI)
- 		ath_mci_cleanup(sc);
- 
- 	for (i = 0; i < ATH9K_NUM_TX_QUEUES; i++)
---- a/drivers/net/wireless/ath/ath9k/pci.c
-+++ b/drivers/net/wireless/ath/ath9k/pci.c
-@@ -121,7 +121,7 @@ static void ath_pci_aspm_init(struct ath
- 	if (!parent)
- 		return;
- 
--	if (ah->btcoex_hw.scheme != ATH_BTCOEX_CFG_NONE) {
-+	if (ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) {
- 		/* Bluetooth coexistance requires disabling ASPM. */
- 		pci_read_config_byte(pdev, pos + PCI_EXP_LNKCTL, &aspm);
- 		aspm &= ~(PCIE_LINK_STATE_L0S | PCIE_LINK_STATE_L1);
---- a/drivers/net/wireless/ath/ath9k/htc_drv_init.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_drv_init.c
-@@ -610,7 +610,7 @@ static void ath9k_init_btcoex(struct ath
- {
- 	int qnum;
- 
--	switch (priv->ah->btcoex_hw.scheme) {
-+	switch (ath9k_hw_get_btcoex_scheme(priv->ah)) {
- 	case ATH_BTCOEX_CFG_NONE:
- 		break;
- 	case ATH_BTCOEX_CFG_3WIRE:
-@@ -704,7 +704,8 @@ static int ath9k_init_priv(struct ath9k_
- 
- 	if (product && strncmp(product, ATH_HTC_BTCOEX_PRODUCT_ID, 5) == 0) {
- 		ah->btcoex_hw.scheme = ATH_BTCOEX_CFG_3WIRE;
--		ath9k_init_btcoex(priv);
-+		if (ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE)
-+			ath9k_init_btcoex(priv);
- 	}
- 
- 	return 0;
---- a/drivers/net/wireless/ath/ath9k/htc_drv_main.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_drv_main.c
-@@ -958,7 +958,7 @@ static int ath9k_htc_start(struct ieee80
- 	mod_timer(&priv->tx.cleanup_timer,
- 		  jiffies + msecs_to_jiffies(ATH9K_HTC_TX_CLEANUP_INTERVAL));
- 
--	if (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE) {
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE) {
- 		ath9k_hw_btcoex_set_weight(ah, AR_BT_COEX_WGHT,
- 					   AR_STOMP_LOW_WLAN_WGHT);
- 		ath9k_hw_btcoex_enable(ah);
-@@ -1010,7 +1010,8 @@ static void ath9k_htc_stop(struct ieee80
- 
- 	mutex_lock(&priv->mutex);
- 
--	if (ah->btcoex_hw.enabled) {
-+	if (ah->btcoex_hw.enabled &&
-+	    ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) {
- 		ath9k_hw_btcoex_disable(ah);
- 		if (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)
- 			ath_htc_cancel_btcoex_work(priv);
---- a/drivers/net/wireless/ath/ath9k/main.c
-+++ b/drivers/net/wireless/ath/ath9k/main.c
-@@ -742,11 +742,11 @@ void ath9k_tasklet(unsigned long data)
- 			ath_tx_tasklet(sc);
- 	}
- 
--	if (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE)
- 		if (status & ATH9K_INT_GENTIMER)
- 			ath_gen_timer_isr(sc->sc_ah);
- 
--	if (status & ATH9K_INT_MCI)
-+	if ((status & ATH9K_INT_MCI) && ATH9K_HW_CAP_MCI)
- 		ath_mci_intr(sc);
- 
- out:
-@@ -1083,14 +1083,14 @@ static int ath9k_start(struct ieee80211_
- 
- 	spin_unlock_bh(&sc->sc_pcu_lock);
- 
--	if ((ah->btcoex_hw.scheme != ATH_BTCOEX_CFG_NONE) &&
-+	if ((ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) &&
- 	    !ah->btcoex_hw.enabled) {
- 		if (!(sc->sc_ah->caps.hw_caps & ATH9K_HW_CAP_MCI))
- 			ath9k_hw_btcoex_set_weight(ah, AR_BT_COEX_WGHT,
- 						   AR_STOMP_LOW_WLAN_WGHT);
- 		ath9k_hw_btcoex_enable(ah);
- 
--		if (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)
-+		if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE)
- 			ath9k_btcoex_timer_resume(sc);
- 	}
- 
-@@ -1194,9 +1194,10 @@ static void ath9k_stop(struct ieee80211_
- 	/* Ensure HW is awake when we try to shut it down. */
- 	ath9k_ps_wakeup(sc);
- 
--	if (ah->btcoex_hw.enabled) {
-+	if (ah->btcoex_hw.enabled &&
-+	    ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE) {
- 		ath9k_hw_btcoex_disable(ah);
--		if (ah->btcoex_hw.scheme == ATH_BTCOEX_CFG_3WIRE)
-+		if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_3WIRE)
- 			ath9k_btcoex_timer_pause(sc);
- 		ath_mci_flush_profile(&sc->btcoex.mci);
- 	}
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -253,6 +253,9 @@ int ath_init_btcoex_timer(struct ath_sof
- {
- 	struct ath_btcoex *btcoex = &sc->btcoex;
- 
-+	if (ath9k_hw_get_btcoex_scheme(sc->sc_ah) == ATH_BTCOEX_CFG_NONE)
-+		return 0;
-+
- 	btcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD * 1000;
- 	btcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *
- 		btcoex->btcoex_period / 100;
-@@ -286,6 +289,9 @@ void ath9k_btcoex_timer_resume(struct at
- 	ath_dbg(ath9k_hw_common(ah), ATH_DBG_BTCOEX,
- 		"Starting btcoex timers\n");
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	/* make sure duty cycle timer is also stopped when resuming */
- 	if (btcoex->hw_timer_enabled)
- 		ath9k_gen_timer_stop(sc->sc_ah, btcoex->no_stomp_timer);
-@@ -306,6 +312,9 @@ void ath9k_btcoex_timer_pause(struct ath
- 	struct ath_btcoex *btcoex = &sc->btcoex;
- 	struct ath_hw *ah = sc->sc_ah;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	del_timer_sync(&btcoex->period_timer);
- 
- 	if (btcoex->hw_timer_enabled)
---- a/drivers/net/wireless/ath/ath9k/hw.c
-+++ b/drivers/net/wireless/ath/ath9k/hw.c
-@@ -1932,7 +1932,8 @@ int ath9k_hw_reset(struct ath_hw *ah, st
- #endif
- 	}
- 
--	if (ah->btcoex_hw.enabled)
-+	if (ah->btcoex_hw.enabled &&
-+	    ath9k_hw_get_btcoex_scheme(ah) != ATH_BTCOEX_CFG_NONE)
- 		ath9k_hw_btcoex_enable(ah);
- 
- 	if (mci && mci_hw->ready) {
---- a/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/htc_drv_gpio.c
-@@ -116,6 +116,9 @@ void ath_htc_init_btcoex_work(struct ath
- {
- 	struct ath_btcoex *btcoex = &priv->btcoex;
- 
-+	if (ath9k_hw_get_btcoex_scheme(priv->ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	btcoex->btcoex_period = ATH_BTCOEX_DEF_BT_PERIOD;
- 	btcoex->btcoex_no_stomp = (100 - ATH_BTCOEX_DEF_DUTY_CYCLE) *
- 		btcoex->btcoex_period / 100;
-@@ -134,6 +137,9 @@ void ath_htc_resume_btcoex_work(struct a
- 	struct ath_btcoex *btcoex = &priv->btcoex;
- 	struct ath_hw *ah = priv->ah;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	ath_dbg(ath9k_hw_common(ah), ATH_DBG_BTCOEX, "Starting btcoex work\n");
- 
- 	btcoex->bt_priority_cnt = 0;
-@@ -148,6 +154,9 @@ void ath_htc_resume_btcoex_work(struct a
-  */
- void ath_htc_cancel_btcoex_work(struct ath9k_htc_priv *priv)
- {
-+	if (ath9k_hw_get_btcoex_scheme(priv->ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	cancel_delayed_work_sync(&priv->coex_period_work);
- 	cancel_delayed_work_sync(&priv->duty_cycle_work);
- }
---- a/drivers/net/wireless/ath/ath9k/btcoex.c
-+++ b/drivers/net/wireless/ath/ath9k/btcoex.c
-@@ -68,6 +68,9 @@ void ath9k_hw_init_btcoex_hw(struct ath_
- 	u32 i, idx;
- 	bool rxclear_polarity = ath_bt_config.bt_rxclear_polarity;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	if (AR_SREV_9300_20_OR_LATER(ah))
- 		rxclear_polarity = !ath_bt_config.bt_rxclear_polarity;
- 
-@@ -99,6 +102,9 @@ void ath9k_hw_btcoex_init_2wire(struct a
- {
- 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	/* connect bt_active to baseband */
- 	REG_CLR_BIT(ah, AR_GPIO_INPUT_EN_VAL,
- 		    (AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_DEF |
-@@ -121,6 +127,9 @@ void ath9k_hw_btcoex_init_3wire(struct a
- {
- 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	/* btcoex 3-wire */
- 	REG_SET_BIT(ah, AR_GPIO_INPUT_EN_VAL,
- 			(AR_GPIO_INPUT_EN_VAL_BT_PRIORITY_BB |
-@@ -147,6 +156,9 @@ static void ath9k_hw_btcoex_enable_2wire
- {
- 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	/* Configure the desired GPIO port for TX_FRAME output */
- 	ath9k_hw_cfg_output(ah, btcoex_hw->wlanactive_gpio,
- 			    AR_GPIO_OUTPUT_MUX_AS_TX_FRAME);
-@@ -158,6 +170,9 @@ void ath9k_hw_btcoex_set_weight(struct a
- {
- 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	btcoex_hw->bt_coex_weights = SM(bt_weight, AR_BTCOEX_BT_WGHT) |
- 				     SM(wlan_weight, AR_BTCOEX_WL_WGHT);
- }
-@@ -219,9 +234,9 @@ void ath9k_hw_btcoex_enable(struct ath_h
- {
- 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
- 
--	switch (btcoex_hw->scheme) {
-+	switch (ath9k_hw_get_btcoex_scheme(ah)) {
- 	case ATH_BTCOEX_CFG_NONE:
--		break;
-+		return;
- 	case ATH_BTCOEX_CFG_2WIRE:
- 		ath9k_hw_btcoex_enable_2wire(ah);
- 		break;
-@@ -246,6 +261,9 @@ void ath9k_hw_btcoex_disable(struct ath_
- 	struct ath_btcoex_hw *btcoex_hw = &ah->btcoex_hw;
- 	int i;
- 
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	btcoex_hw->enabled = false;
- 	if (btcoex_hw->scheme == ATH_BTCOEX_CFG_MCI) {
- 		ath9k_hw_btcoex_bt_stomp(ah, ATH_BTCOEX_STOMP_NONE);
-@@ -294,6 +312,9 @@ static void ar9003_btcoex_bt_stomp(struc
- void ath9k_hw_btcoex_bt_stomp(struct ath_hw *ah,
- 			      enum ath_stomp_type stomp_type)
- {
-+	if (ath9k_hw_get_btcoex_scheme(ah) == ATH_BTCOEX_CFG_NONE)
-+		return;
-+
- 	if (AR_SREV_9300_20_OR_LATER(ah)) {
- 		ar9003_btcoex_bt_stomp(ah, stomp_type);
- 		return;
---- a/drivers/net/wireless/ath/ath9k/ar9003_mci.c
-+++ b/drivers/net/wireless/ath/ath9k/ar9003_mci.c
-@@ -85,6 +85,9 @@ void ar9003_mci_remote_reset(struct ath_
- {
- 	u32 payload[4] = { 0xffffffff, 0xffffffff, 0xffffffff, 0xffffff00};
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	ar9003_mci_send_message(ah, MCI_REMOTE_RESET, 0, payload, 16,
- 				wait_done, false);
- 	udelay(5);
-@@ -94,6 +97,9 @@ void ar9003_mci_send_lna_transfer(struct
- {
- 	u32 payload = 0x00000000;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	ar9003_mci_send_message(ah, MCI_LNA_TRANS, 0, &payload, 1,
- 				wait_done, false);
- }
-@@ -107,6 +113,9 @@ static void ar9003_mci_send_req_wake(str
- 
- void ar9003_mci_send_sys_waking(struct ath_hw *ah, bool wait_done)
- {
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	ar9003_mci_send_message(ah, MCI_SYS_WAKING, MCI_FLAG_DISABLE_TIMESTAMP,
- 				NULL, 0, wait_done, false);
- }
-@@ -221,6 +230,9 @@ void ar9003_mci_send_coex_halt_bt_gpm(st
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
- 	u32 payload[4] = {0, 0, 0, 0};
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	ath_dbg(common, ATH_DBG_MCI, "MCI Send Coex %s BT GPM.\n",
- 		(halt) ? "halt" : "unhalt");
- 
-@@ -381,12 +393,17 @@ static void ar9003_mci_prep_interface(st
- 
- void ar9003_mci_disable_interrupt(struct ath_hw *ah)
- {
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	REG_WRITE(ah, AR_MCI_INTERRUPT_EN, 0);
- 	REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN, 0);
- }
- 
- void ar9003_mci_enable_interrupt(struct ath_hw *ah)
- {
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
- 
- 	REG_WRITE(ah, AR_MCI_INTERRUPT_EN, AR_MCI_INTERRUPT_DEFAULT);
- 	REG_WRITE(ah, AR_MCI_INTERRUPT_RX_MSG_EN,
-@@ -397,6 +414,9 @@ bool ar9003_mci_check_int(struct ath_hw 
- {
- 	u32 intr;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return false;
-+
- 	intr = REG_READ(ah, AR_MCI_INTERRUPT_RX_MSG_RAW);
- 	return ((intr & ints) == ints);
- }
-@@ -405,6 +425,10 @@ void ar9003_mci_get_interrupt(struct ath
- 			      u32 *rx_msg_intr)
- {
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
-+
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	*raw_intr = mci->raw_intr;
- 	*rx_msg_intr = mci->rx_msg_intr;
- 
-@@ -418,6 +442,9 @@ void ar9003_mci_2g5g_changed(struct ath_
- {
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	if (!mci->update_2g5g &&
- 	    (mci->is_2g != is_2g))
- 		mci->update_2g5g = true;
-@@ -531,6 +558,9 @@ void ar9003_mci_reset(struct ath_hw *ah,
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
- 	u32 regval, thresh;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	ath_dbg(common, ATH_DBG_MCI, "MCI full_sleep = %d, is_2g = %d\n",
- 		is_full_sleep, is_2g);
- 
-@@ -661,6 +691,9 @@ void ar9003_mci_mute_bt(struct ath_hw *a
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	/* disable all MCI messages */
- 	REG_WRITE(ah, AR_MCI_MSG_ATTRIBUTES_TABLE, 0xffff0000);
- 	REG_WRITE(ah, AR_BTCOEX_WL_WEIGHTS0, 0xffffffff);
-@@ -693,6 +726,9 @@ void ar9003_mci_sync_bt_state(struct ath
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
- 	u32 cur_bt_state;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	cur_bt_state = ar9003_mci_state(ah, MCI_STATE_REMOTE_SLEEP, NULL);
- 
- 	if (mci->bt_state != cur_bt_state) {
-@@ -857,6 +893,9 @@ void ar9003_mci_2g5g_switch(struct ath_h
- 	struct ath_common *common = ath9k_hw_common(ah);
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	if (mci->update_2g5g) {
- 		if (mci->is_2g) {
- 
-@@ -908,6 +947,9 @@ bool ar9003_mci_send_message(struct ath_
- 	u32 saved_mci_int_en;
- 	int i;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return false;
-+
- 	saved_mci_int_en = REG_READ(ah, AR_MCI_INTERRUPT_EN);
- 	regval = REG_READ(ah, AR_BTCOEX_CTRL);
- 
-@@ -973,6 +1015,9 @@ void ar9003_mci_setup(struct ath_hw *ah,
- 	struct ath9k_hw_mci *mci = &ah->btcoex_hw.mci;
- 	void *sched_buf = (void *)((char *) gpm_buf + (sched_addr - gpm_addr));
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	mci->gpm_addr = gpm_addr;
- 	mci->gpm_buf = gpm_buf;
- 	mci->gpm_len = len;
-@@ -987,6 +1032,9 @@ void ar9003_mci_cleanup(struct ath_hw *a
- {
- 	struct ath_common *common = ath9k_hw_common(ah);
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	/* Turn off MCI and Jupiter mode. */
- 	REG_WRITE(ah, AR_BTCOEX_CTRL, 0x00);
- 	ath_dbg(common, ATH_DBG_MCI, "MCI ar9003_mci_cleanup\n");
-@@ -1056,6 +1104,9 @@ u32 ar9003_mci_wait_for_gpm(struct ath_h
- 	u8 recv_type = 0, recv_opcode = 0;
- 	bool b_is_bt_cal_done = (gpm_type == MCI_GPM_BT_CAL_DONE);
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return 0;
-+
- 	more_data = time_out ? MCI_GPM_NOMORE : MCI_GPM_MORE;
- 
- 	while (time_out > 0) {
-@@ -1188,6 +1239,9 @@ u32 ar9003_mci_state(struct ath_hw *ah, 
- 	u32 value = 0, more_gpm = 0, gpm_ptr;
- 	u8 query_type;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return 0;
-+
- 	switch (state_type) {
- 	case MCI_STATE_ENABLE:
- 		if (mci->ready) {
---- a/drivers/net/wireless/ath/ath9k/mci.c
-+++ b/drivers/net/wireless/ath/ath9k/mci.c
-@@ -425,6 +425,9 @@ int ath_mci_setup(struct ath_softc *sc)
- 	struct ath_mci_coex *mci = &sc->mci_coex;
- 	int error = 0;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return 0;
-+
- 	mci->sched_buf.bf_len = ATH_MCI_SCHED_BUF_SIZE + ATH_MCI_GPM_BUF_SIZE;
- 
- 	if (ath_mci_buf_alloc(sc, &mci->sched_buf)) {
-@@ -458,6 +461,9 @@ void ath_mci_cleanup(struct ath_softc *s
- 	struct ath_hw *ah = sc->sc_ah;
- 	struct ath_mci_coex *mci = &sc->mci_coex;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	/*
- 	 * both schedule and gpm buffers will be released
- 	 */
-@@ -476,6 +482,9 @@ void ath_mci_intr(struct ath_softc *sc)
- 	u32 more_data = MCI_GPM_MORE;
- 	bool skip_gpm = false;
- 
-+	if (!ATH9K_HW_CAP_MCI)
-+		return;
-+
- 	ar9003_mci_get_interrupt(sc->sc_ah, &mci_int, &mci_int_rxmsg);
- 
- 	if (ar9003_mci_state(ah, MCI_STATE_ENABLE, NULL) == 0) {
diff '--exclude=.svn' -Nur package/mac80211/patches/571-ath9k_paprd_retrain_pa_in.patch ../openwrt-trunk/package/mac80211/patches/571-ath9k_paprd_retrain_pa_in.patch
--- package/mac80211/patches/571-ath9k_paprd_retrain_pa_in.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/571-ath9k_paprd_retrain_pa_in.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,153 @@
+--- a/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
++++ b/drivers/net/wireless/ath/ath9k/ar9003_paprd.c
+@@ -786,6 +786,102 @@ int ar9003_paprd_setup_gain_table(struct
+ }
+ EXPORT_SYMBOL(ar9003_paprd_setup_gain_table);
+ 
++static bool ar9003_paprd_retrain_pa_in(struct ath_hw *ah,
++				       struct ath9k_hw_cal_data *caldata,
++				       int chain)
++{
++	u32 *pa_in = caldata->pa_table[chain];
++	int capdiv_offset, quick_drop_offset;
++	int capdiv2g, quick_drop;
++	int count = 0;
++	int i;
++
++	if (!AR_SREV_9485(ah) && !AR_SREV_9330(ah))
++		return false;
++
++	capdiv2g = REG_READ_FIELD(ah, AR_PHY_65NM_CH0_TXRF3,
++				  AR_PHY_65NM_CH0_TXRF3_CAPDIV2G);
++
++	quick_drop = REG_READ_FIELD(ah, AR_PHY_PAPRD_TRAINER_CNTL3,
++				    AR_PHY_PAPRD_TRAINER_CNTL3_CF_PAPRD_QUICK_DROP);
++
++	if (quick_drop)
++		quick_drop -= 0x40;
++
++	for (i = 0; i < NUM_BIN + 1; i++) {
++		if (pa_in[i] == 1400)
++			count++;
++	}
++
++	if (AR_SREV_9485(ah)) {
++		if (pa_in[23] < 800) {
++			capdiv_offset = (int)((1000 - pa_in[23] + 75) / 150);
++			capdiv2g += capdiv_offset;
++			if (capdiv2g > 7) {
++				capdiv2g = 7;
++				if (pa_in[23] < 600) {
++					quick_drop++;
++					if (quick_drop > 0)
++						quick_drop = 0;
++				}
++			}
++		} else if (pa_in[23] == 1400) {
++			quick_drop_offset = min_t(int, count / 3, 2);
++			quick_drop += quick_drop_offset;
++			capdiv2g += quick_drop_offset / 2;
++
++			if (capdiv2g > 7)
++				capdiv2g = 7;
++
++			if (quick_drop > 0) {
++				quick_drop = 0;
++				capdiv2g -= quick_drop_offset;
++				if (capdiv2g < 0)
++					capdiv2g = 0;
++			}
++		} else {
++			return false;
++		}
++	} else if (AR_SREV_9330(ah)) {
++		if (pa_in[23] < 1000) {
++			capdiv_offset = (1000 - pa_in[23]) / 100;
++			capdiv2g += capdiv_offset;
++			if (capdiv_offset > 3) {
++				capdiv_offset = 1;
++				quick_drop--;
++			}
++
++			capdiv2g += capdiv_offset;
++			if (capdiv2g > 6)
++				capdiv2g = 6;
++			if (quick_drop < -4)
++				quick_drop = -4;
++		} else if (pa_in[23] == 1400) {
++			if (count > 3) {
++				quick_drop++;
++				capdiv2g -= count / 4;
++				if (quick_drop > -2)
++					quick_drop = -2;
++			} else {
++				capdiv2g--;
++			}
++
++			if (capdiv2g < 0)
++				capdiv2g = 0;
++		} else {
++			return false;
++		}
++	}
++
++	REG_RMW_FIELD(ah, AR_PHY_65NM_CH0_TXRF3,
++		      AR_PHY_65NM_CH0_TXRF3_CAPDIV2G, capdiv2g);
++	REG_RMW_FIELD(ah, AR_PHY_PAPRD_TRAINER_CNTL3,
++		      AR_PHY_PAPRD_TRAINER_CNTL3_CF_PAPRD_QUICK_DROP,
++		      quick_drop);
++
++	return true;
++}
++
+ int ar9003_paprd_create_curve(struct ath_hw *ah,
+ 			      struct ath9k_hw_cal_data *caldata, int chain)
+ {
+@@ -821,6 +917,9 @@ int ar9003_paprd_create_curve(struct ath
+ 	if (!create_pa_curve(data_L, data_U, pa_table, small_signal_gain))
+ 		status = -2;
+ 
++	if (ar9003_paprd_retrain_pa_in(ah, caldata, chain))
++		status = -EINPROGRESS;
++
+ 	REG_CLR_BIT(ah, AR_PHY_PAPRD_TRAINER_STAT1,
+ 		    AR_PHY_PAPRD_TRAINER_STAT1_PAPRD_TRAIN_DONE);
+ 
+--- a/drivers/net/wireless/ath/ath9k/ar9003_phy.h
++++ b/drivers/net/wireless/ath/ath9k/ar9003_phy.h
+@@ -625,6 +625,10 @@
+ #define AR_PHY_AIC_CTRL_4_B0	(AR_SM_BASE + 0x4c0)
+ #define AR_PHY_AIC_STAT_2_B0	(AR_SM_BASE + 0x4cc)
+ 
++#define AR_PHY_65NM_CH0_TXRF3       0x16048
++#define AR_PHY_65NM_CH0_TXRF3_CAPDIV2G		0x0000001e
++#define AR_PHY_65NM_CH0_TXRF3_CAPDIV2G_S	1
++
+ #define AR_PHY_65NM_CH0_SYNTH4      0x1608c
+ #define AR_PHY_SYNTH4_LONG_SHIFT_SELECT   (AR_SREV_9462(ah) ? 0x00000001 : 0x00000002)
+ #define AR_PHY_SYNTH4_LONG_SHIFT_SELECT_S (AR_SREV_9462(ah) ? 0 : 1)
+--- a/drivers/net/wireless/ath/ath9k/link.c
++++ b/drivers/net/wireless/ath/ath9k/link.c
+@@ -254,6 +254,7 @@ void ath_paprd_calibrate(struct work_str
+ 	int chain_ok = 0;
+ 	int chain;
+ 	int len = 1800;
++	int ret;
+ 
+ 	if (!caldata)
+ 		return;
+@@ -302,7 +303,13 @@ void ath_paprd_calibrate(struct work_str
+ 			break;
+ 		}
+ 
+-		if (ar9003_paprd_create_curve(ah, caldata, chain)) {
++		ret = ar9003_paprd_create_curve(ah, caldata, chain);
++		if (ret == -EINPROGRESS) {
++			ath_dbg(common, CALIBRATE,
++				"PAPRD curve on chain %d needs to be re-trained\n",
++				chain);
++			break;
++		} else if (ret) {
+ 			ath_dbg(common, CALIBRATE,
+ 				"PAPRD create curve failed on chain %d\n",
+ 				chain);
diff '--exclude=.svn' -Nur package/mac80211/patches/572-ath9k_enable_paprd.patch ../openwrt-trunk/package/mac80211/patches/572-ath9k_enable_paprd.patch
--- package/mac80211/patches/572-ath9k_enable_paprd.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/572-ath9k_enable_paprd.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,12 @@
+--- a/drivers/net/wireless/ath/ath9k/hw.c
++++ b/drivers/net/wireless/ath/ath9k/hw.c
+@@ -464,9 +464,6 @@ static void ath9k_hw_init_config(struct 
+ 		ah->config.spurchans[i][1] = AR_NO_SPUR;
+ 	}
+ 
+-	/* PAPRD needs some more work to be enabled */
+-	ah->config.paprd_disable = 1;
+-
+ 	ah->config.rx_intr_mitigation = true;
+ 	ah->config.pcieSerDesWrite = true;
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/573-ath9k_fix_reset_hang.patch ../openwrt-trunk/package/mac80211/patches/573-ath9k_fix_reset_hang.patch
--- package/mac80211/patches/573-ath9k_fix_reset_hang.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/573-ath9k_fix_reset_hang.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,61 @@
+--- a/drivers/net/wireless/ath/ath9k/mac.c
++++ b/drivers/net/wireless/ath/ath9k/mac.c
+@@ -783,15 +783,10 @@ bool ath9k_hw_intrpend(struct ath_hw *ah
+ }
+ EXPORT_SYMBOL(ath9k_hw_intrpend);
+ 
+-void ath9k_hw_disable_interrupts(struct ath_hw *ah)
++void ath9k_hw_kill_interrupts(struct ath_hw *ah)
+ {
+ 	struct ath_common *common = ath9k_hw_common(ah);
+ 
+-	if (!(ah->imask & ATH9K_INT_GLOBAL))
+-		atomic_set(&ah->intr_ref_cnt, -1);
+-	else
+-		atomic_dec(&ah->intr_ref_cnt);
+-
+ 	ath_dbg(common, INTERRUPT, "disable IER\n");
+ 	REG_WRITE(ah, AR_IER, AR_IER_DISABLE);
+ 	(void) REG_READ(ah, AR_IER);
+@@ -803,6 +798,17 @@ void ath9k_hw_disable_interrupts(struct 
+ 		(void) REG_READ(ah, AR_INTR_SYNC_ENABLE);
+ 	}
+ }
++EXPORT_SYMBOL(ath9k_hw_kill_interrupts);
++
++void ath9k_hw_disable_interrupts(struct ath_hw *ah)
++{
++	if (!(ah->imask & ATH9K_INT_GLOBAL))
++		atomic_set(&ah->intr_ref_cnt, -1);
++	else
++		atomic_dec(&ah->intr_ref_cnt);
++
++	ath9k_hw_kill_interrupts(ah);
++}
+ EXPORT_SYMBOL(ath9k_hw_disable_interrupts);
+ 
+ void ath9k_hw_enable_interrupts(struct ath_hw *ah)
+--- a/drivers/net/wireless/ath/ath9k/mac.h
++++ b/drivers/net/wireless/ath/ath9k/mac.h
+@@ -734,6 +734,7 @@ bool ath9k_hw_intrpend(struct ath_hw *ah
+ void ath9k_hw_set_interrupts(struct ath_hw *ah);
+ void ath9k_hw_enable_interrupts(struct ath_hw *ah);
+ void ath9k_hw_disable_interrupts(struct ath_hw *ah);
++void ath9k_hw_kill_interrupts(struct ath_hw *ah);
+ 
+ void ar9002_hw_attach_mac_ops(struct ath_hw *ah);
+ 
+--- a/drivers/net/wireless/ath/ath9k/main.c
++++ b/drivers/net/wireless/ath/ath9k/main.c
+@@ -459,8 +459,10 @@ irqreturn_t ath_isr(int irq, void *dev)
+ 	if (!ath9k_hw_intrpend(ah))
+ 		return IRQ_NONE;
+ 
+-	if(test_bit(SC_OP_HW_RESET, &sc->sc_flags))
++	if (test_bit(SC_OP_HW_RESET, &sc->sc_flags)) {
++		ath9k_hw_kill_interrupts(ah);
+ 		return IRQ_HANDLED;
++	}
+ 
+ 	/*
+ 	 * Figure out the reason(s) for the interrupt.  Note
diff '--exclude=.svn' -Nur package/mac80211/patches/580-ath9k_extra_leds.patch ../openwrt-trunk/package/mac80211/patches/580-ath9k_extra_leds.patch
--- package/mac80211/patches/580-ath9k_extra_leds.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/580-ath9k_extra_leds.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,258 +0,0 @@
---- a/drivers/net/wireless/ath/ath9k/ath9k.h
-+++ b/drivers/net/wireless/ath/ath9k/ath9k.h
-@@ -475,6 +475,9 @@ void ath9k_btcoex_timer_pause(struct ath
- #ifdef CONFIG_MAC80211_LEDS
- void ath_init_leds(struct ath_softc *sc);
- void ath_deinit_leds(struct ath_softc *sc);
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio, const char *name,
-+                        const char *trigger, bool active_low);
-+
- #else
- static inline void ath_init_leds(struct ath_softc *sc)
- {
-@@ -595,6 +598,13 @@ struct ath9k_vif_iter_data {
- 	int nothers;   /* number of vifs not specified above. */
- };
- 
-+struct ath_led {
-+	struct list_head list;
-+	struct ath_softc *sc;
-+	const struct gpio_led *gpio;
-+	struct led_classdev cdev;
-+};
-+
- struct ath_softc {
- 	struct ieee80211_hw *hw;
- 	struct device *dev;
-@@ -638,9 +648,8 @@ struct ath_softc {
- 	struct ieee80211_supported_band sbands[IEEE80211_NUM_BANDS];
- 
- #ifdef CONFIG_MAC80211_LEDS
--	bool led_registered;
--	char led_name[32];
--	struct led_classdev led_cdev;
-+	const char *led_default_trigger;
-+	struct list_head leds;
- #endif
- 
- 	struct ath9k_hw_cal_data caldata;
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -24,22 +24,89 @@
- static void ath_led_brightness(struct led_classdev *led_cdev,
- 			       enum led_brightness brightness)
- {
--	struct ath_softc *sc = container_of(led_cdev, struct ath_softc, led_cdev);
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, (brightness == LED_OFF));
-+	struct ath_led *led = container_of(led_cdev, struct ath_led, cdev);
-+	struct ath_softc *sc = led->sc;
-+
-+	ath9k_ps_wakeup(sc);
-+	ath9k_hw_set_gpio(sc->sc_ah, led->gpio->gpio,
-+			  (brightness != LED_OFF) ^ led->gpio->active_low);
-+	ath9k_ps_restore(sc);
-+}
-+
-+static int ath_add_led(struct ath_softc *sc, struct ath_led *led)
-+{
-+	const struct gpio_led *gpio = led->gpio;
-+	int ret;
-+
-+	led->cdev.name = gpio->name;
-+	led->cdev.default_trigger = gpio->default_trigger;
-+	led->cdev.brightness_set = ath_led_brightness;
-+
-+	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &led->cdev);
-+	if (ret < 0)
-+		return ret;
-+
-+	led->sc = sc;
-+	list_add(&led->list, &sc->leds);
-+
-+	/* Configure gpio for output */
-+	ath9k_hw_cfg_output(sc->sc_ah, gpio->gpio,
-+			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
-+
-+	/* LED off */
-+	ath9k_hw_set_gpio(sc->sc_ah, gpio->gpio, gpio->active_low);
-+
-+	return 0;
-+}
-+
-+int ath_create_gpio_led(struct ath_softc *sc, int gpio_num, const char *name,
-+			const char *trigger, bool active_low)
-+{
-+	struct ath_led *led;
-+	struct gpio_led *gpio;
-+	char *_name;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led) + sizeof(*gpio) + strlen(name) + 1,
-+		      GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio = (struct gpio_led *) (led + 1);
-+	_name = (char *) (led->gpio + 1);
-+
-+	strcpy(_name, name);
-+	gpio->name = _name;
-+	gpio->gpio = gpio_num;
-+	gpio->active_low = active_low;
-+	gpio->default_trigger = trigger;
-+
-+	ret = ath_add_led(sc, led);
-+	if (unlikely(ret < 0))
-+		kfree(led);
-+
-+	return ret;
- }
- 
- void ath_deinit_leds(struct ath_softc *sc)
- {
--	if (!sc->led_registered)
--		return;
-+	struct ath_led *led;
- 
--	ath_led_brightness(&sc->led_cdev, LED_OFF);
--	led_classdev_unregister(&sc->led_cdev);
-+	while (!list_empty(&sc->leds)) {
-+		led = list_first_entry(&sc->leds, struct ath_led, list);
-+		list_del(&led->list);
-+		ath_led_brightness(&led->cdev, LED_OFF);
-+		led_classdev_unregister(&led->cdev);
-+		kfree(led);
-+	}
- }
- 
- void ath_init_leds(struct ath_softc *sc)
- {
--	int ret;
-+	char led_name[32];
-+	const char *trigger;
-+
-+	INIT_LIST_HEAD(&sc->leds);
- 
- 	if (AR_SREV_9100(sc->sc_ah))
- 		return;
-@@ -57,26 +124,15 @@ void ath_init_leds(struct ath_softc *sc)
- 			sc->sc_ah->led_pin = ATH_LED_PIN_DEF;
- 	}
- 
--	/* Configure gpio 1 for output */
--	ath9k_hw_cfg_output(sc->sc_ah, sc->sc_ah->led_pin,
--			    AR_GPIO_OUTPUT_MUX_AS_OUTPUT);
--	/* LED off, active low */
--	ath9k_hw_set_gpio(sc->sc_ah, sc->sc_ah->led_pin, 1);
--
--	if (!led_blink)
--		sc->led_cdev.default_trigger =
--			ieee80211_get_radio_led_name(sc->hw);
--
--	snprintf(sc->led_name, sizeof(sc->led_name),
--		"ath9k-%s", wiphy_name(sc->hw->wiphy));
--	sc->led_cdev.name = sc->led_name;
--	sc->led_cdev.brightness_set = ath_led_brightness;
-+	snprintf(led_name, sizeof(led_name), "ath9k-%s",
-+		 wiphy_name(sc->hw->wiphy));
- 
--	ret = led_classdev_register(wiphy_dev(sc->hw->wiphy), &sc->led_cdev);
--	if (ret < 0)
--		return;
-+	if (led_blink)
-+		trigger = sc->led_default_trigger;
-+	else
-+		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
--	sc->led_registered = true;
-+	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
- }
- #endif
- 
---- a/drivers/net/wireless/ath/ath9k/init.c
-+++ b/drivers/net/wireless/ath/ath9k/init.c
-@@ -803,7 +803,7 @@ int ath9k_init_device(u16 devid, struct 
- 
- #ifdef CONFIG_MAC80211_LEDS
- 	/* must be initialized before ieee80211_register_hw */
--	sc->led_cdev.default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
-+	sc->led_default_trigger = ieee80211_create_tpt_led_trigger(sc->hw,
- 		IEEE80211_TPT_LEDTRIG_FL_RADIO, ath9k_tpt_blink,
- 		ARRAY_SIZE(ath9k_tpt_blink));
- #endif
---- a/drivers/net/wireless/ath/ath9k/debug.c
-+++ b/drivers/net/wireless/ath/ath9k/debug.c
-@@ -1304,6 +1304,61 @@ static const struct file_operations fops
- 	.llseek = default_llseek,
- };
- 
-+#ifdef CONFIG_MAC80211_LEDS
-+
-+static ssize_t write_file_gpio_led(struct file *file, const char __user *ubuf,
-+				   size_t count, loff_t *ppos)
-+{
-+	struct ath_softc *sc = file->private_data;
-+	char buf[32], *str, *name, *c;
-+	ssize_t len;
-+	unsigned int gpio;
-+	bool active_low = false;
-+
-+	len = min(count, sizeof(buf) - 1);
-+	if (copy_from_user(buf, ubuf, len))
-+		return -EFAULT;
-+
-+	buf[len] = '\0';
-+	name = strchr(buf, ',');
-+	if (!name)
-+		return -EINVAL;
-+
-+	*(name++) = 0;
-+	if (!*name)
-+		return -EINVAL;
-+
-+	c = strchr(name, '\n');
-+	if (c)
-+		*c = 0;
-+
-+	str = buf;
-+	if (*str == '!') {
-+		str++;
-+		active_low = true;
-+	}
-+
-+	if (kstrtouint(str, 0, &gpio) < 0)
-+		return -EINVAL;
-+
-+	if (gpio >= sc->sc_ah->caps.num_gpio_pins)
-+		return -EINVAL;
-+
-+	if (ath_create_gpio_led(sc, gpio, name, NULL, active_low) < 0)
-+		return -EINVAL;
-+
-+	return count;
-+}
-+
-+static const struct file_operations fops_gpio_led = {
-+	.write = write_file_gpio_led,
-+	.open = ath9k_debugfs_open,
-+	.owner = THIS_MODULE,
-+	.llseek = default_llseek,
-+};
-+
-+#endif
-+
- void ath9k_debug_samp_bb_mac(struct ath_softc *sc)
- {
- #define ATH_SAMP_DBG(c) (sc->debug.bb_mac_samp[sc->debug.sampidx].c)
-@@ -1725,6 +1780,11 @@ int ath9k_init_debug(struct ath_hw *ah)
- 	debugfs_create_file("samples", S_IRUSR, sc->debug.debugfs_phy, sc,
- 			    &fops_samps);
- 
-+#ifdef CONFIG_MAC80211_LEDS
-+	debugfs_create_file("gpio_led", S_IWUSR,
-+			   sc->debug.debugfs_phy, sc, &fops_gpio_led);
-+#endif
-+
- 	debugfs_create_u32("gpio_mask", S_IRUSR | S_IWUSR,
- 			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/581-ath9k_extra_platform_leds.patch ../openwrt-trunk/package/mac80211/patches/581-ath9k_extra_platform_leds.patch
--- package/mac80211/patches/581-ath9k_extra_platform_leds.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/581-ath9k_extra_platform_leds.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,71 +0,0 @@
---- a/include/linux/ath9k_platform.h
-+++ b/include/linux/ath9k_platform.h
-@@ -32,6 +32,9 @@ struct ath9k_platform_data {
- 	bool is_clk_25mhz;
- 	int (*get_mac_revision)(void);
- 	int (*external_reset)(void);
-+
-+	int num_leds;
-+	const struct gpio_led *leds;
- };
- 
- #endif /* _LINUX_ATH9K_PLATFORM_H */
---- a/drivers/net/wireless/ath/ath9k/gpio.c
-+++ b/drivers/net/wireless/ath/ath9k/gpio.c
-@@ -14,6 +14,7 @@
-  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-  */
- 
-+#include <linux/ath9k_platform.h>
- #include "ath9k.h"
- 
- /********************************/
-@@ -88,6 +89,24 @@ int ath_create_gpio_led(struct ath_softc
- 	return ret;
- }
- 
-+static int ath_create_platform_led(struct ath_softc *sc,
-+				   const struct gpio_led *gpio)
-+{
-+	struct ath_led *led;
-+	int ret;
-+
-+	led = kzalloc(sizeof(*led), GFP_KERNEL);
-+	if (!led)
-+		return -ENOMEM;
-+
-+	led->gpio = gpio;
-+	ret = ath_add_led(sc, led);
-+	if (ret < 0)
-+		kfree(led);
-+
-+	return ret;
-+}
-+
- void ath_deinit_leds(struct ath_softc *sc)
- {
- 	struct ath_led *led;
-@@ -103,8 +122,10 @@ void ath_deinit_leds(struct ath_softc *s
- 
- void ath_init_leds(struct ath_softc *sc)
- {
-+	struct ath9k_platform_data *pdata = sc->dev->platform_data;
- 	char led_name[32];
- 	const char *trigger;
-+	int i;
- 
- 	INIT_LIST_HEAD(&sc->leds);
- 
-@@ -133,6 +154,12 @@ void ath_init_leds(struct ath_softc *sc)
- 		trigger = ieee80211_get_radio_led_name(sc->hw);
- 
- 	ath_create_gpio_led(sc, sc->sc_ah->led_pin, led_name, trigger, 1);
-+
-+	if (!pdata)
-+		return;
-+
-+	for (i = 0; i < pdata->num_leds; i++)
-+		ath_create_platform_led(sc, &pdata->leds[i]);
- }
- #endif
- 
diff '--exclude=.svn' -Nur package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch ../openwrt-trunk/package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch
--- package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/600-rt2x00-disable-pci-code-if-CONFIG_PCI-not-defined.patch	2012-08-18 14:47:33.125458002 +0200
@@ -8,7 +8,7 @@
  /*
   * PCI driver handlers.
   */
-@@ -383,6 +384,7 @@ int rt2x00pci_resume(struct pci_dev *pci
+@@ -392,6 +393,7 @@ int rt2x00pci_resume(struct pci_dev *pci
  }
  EXPORT_SYMBOL_GPL(rt2x00pci_resume);
  #endif /* CONFIG_PM */
diff '--exclude=.svn' -Nur package/mac80211/patches/601-rt2x00-set_pci_mwi.patch ../openwrt-trunk/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch
--- package/mac80211/patches/601-rt2x00-set_pci_mwi.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/601-rt2x00-set_pci_mwi.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/rt2x00/rt2x00pci.c
 +++ b/drivers/net/wireless/rt2x00/rt2x00pci.c
-@@ -272,8 +272,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
+@@ -273,8 +273,10 @@ int rt2x00pci_probe(struct pci_dev *pci_
  
  	pci_set_master(pci_dev);
  
diff '--exclude=.svn' -Nur package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch ../openwrt-trunk/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch
--- package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/602-rt2x00-introduce-rt2x00_platform_h.patch	2012-08-18 14:47:33.115458002 +0200
@@ -25,7 +25,7 @@
 @@ -39,6 +39,7 @@
  #include <linux/input-polldev.h>
  #include <linux/kfifo.h>
- #include <linux/timer.h>
+ #include <linux/hrtimer.h>
 +#include <linux/rt2x00_platform.h>
  
  #include <net/mac80211.h>
diff '--exclude=.svn' -Nur package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch ../openwrt-trunk/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch
--- package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/603-rt2x00-introduce-rt2x00eeprom.patch	2012-08-18 14:47:33.115458002 +0200
@@ -101,7 +101,7 @@
 +}
 --- a/drivers/net/wireless/rt2x00/rt2x00.h
 +++ b/drivers/net/wireless/rt2x00/rt2x00.h
-@@ -554,6 +554,7 @@ struct rt2x00lib_ops {
+@@ -560,6 +560,7 @@ struct rt2x00lib_ops {
  			       const u8 *data, const size_t len);
  	int (*load_firmware) (struct rt2x00_dev *rt2x00dev,
  			      const u8 *data, const size_t len);
@@ -109,7 +109,7 @@
  
  	/*
  	 * Device initialization/deinitialization handlers.
-@@ -705,6 +706,7 @@ enum rt2x00_capability_flags {
+@@ -721,6 +722,7 @@ enum rt2x00_capability_flags {
  	REQUIRE_SW_SEQNO,
  	REQUIRE_HT_TX_DESC,
  	REQUIRE_PS_AUTOWAKE,
@@ -117,7 +117,7 @@
  
  	/*
  	 * Capabilities
-@@ -961,6 +963,11 @@ struct rt2x00_dev {
+@@ -976,6 +978,11 @@ struct rt2x00_dev {
  	const struct firmware *fw;
  
  	/*
@@ -131,7 +131,7 @@
  	DECLARE_KFIFO_PTR(txstatus_fifo, u32);
 --- a/drivers/net/wireless/rt2x00/rt2x00lib.h
 +++ b/drivers/net/wireless/rt2x00/rt2x00lib.h
-@@ -309,6 +309,22 @@ static inline void rt2x00lib_free_firmwa
+@@ -322,6 +322,22 @@ static inline void rt2x00lib_free_firmwa
  #endif /* CONFIG_RT2X00_LIB_FIRMWARE */
  
  /*
@@ -164,7 +164,7 @@
  	select RT2X00_LIB_CRYPTO
  	select CRC_CCITT
  	select EEPROM_93CX6
-@@ -204,6 +205,9 @@ config RT2X00_LIB_FIRMWARE
+@@ -212,6 +213,9 @@ config RT2X00_LIB_FIRMWARE
  config RT2X00_LIB_CRYPTO
  	boolean
  
@@ -208,7 +208,7 @@
  
  #ifdef CONFIG_PCI
  static void rt2800pci_eepromregister_read(struct eeprom_93cx6 *eeprom)
-@@ -311,6 +301,20 @@ static int rt2800pci_write_firmware(stru
+@@ -317,6 +307,20 @@ static int rt2800pci_write_firmware(stru
  }
  
  /*
@@ -229,7 +229,7 @@
   * Initialization functions.
   */
  static bool rt2800pci_get_entry_state(struct queue_entry *entry)
-@@ -1052,6 +1056,7 @@ static const struct rt2x00lib_ops rt2800
+@@ -1159,6 +1163,7 @@ static const struct rt2x00lib_ops rt2800
  	.get_firmware_name	= rt2800pci_get_firmware_name,
  	.check_firmware		= rt2800_check_firmware,
  	.load_firmware		= rt2800_load_firmware,
@@ -239,9 +239,9 @@
  	.get_entry_state	= rt2800pci_get_entry_state,
 --- a/drivers/net/wireless/rt2x00/rt2x00dev.c
 +++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
-@@ -1145,6 +1145,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
- 		    BIT(NL80211_IFTYPE_MESH_POINT) |
- 		    BIT(NL80211_IFTYPE_WDS);
+@@ -1163,6 +1163,10 @@ int rt2x00lib_probe_dev(struct rt2x00_de
+ 
+ 	rt2x00dev->hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
  
 +	retval = rt2x00lib_load_eeprom_file(rt2x00dev);
 +	if (retval)
@@ -250,10 +250,10 @@
  	/*
  	 * Initialize work.
  	 */
-@@ -1261,6 +1265,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
- 	 * Free queue structures.
+@@ -1287,6 +1291,11 @@ void rt2x00lib_remove_dev(struct rt2x00_
  	 */
- 	rt2x00queue_free(rt2x00dev);
+ 	if (rt2x00dev->drv_data)
+ 		kfree(rt2x00dev->drv_data);
 +
 +	/*
 +	 * Free EEPROM image.
diff '--exclude=.svn' -Nur package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch ../openwrt-trunk/package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch
--- package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/604-rt2x00-add-CONFIG_RT2X00_LIB_EEPROM-option.patch	2012-08-18 14:47:33.115458002 +0200
@@ -1,10 +1,10 @@
 --- a/config.mk
 +++ b/config.mk
-@@ -606,6 +606,7 @@ CONFIG_RT2X00=y
- CONFIG_RT2X00_LIB=m
- CONFIG_RT2800_LIB=m
- CONFIG_RT2X00_LIB_FIRMWARE=y
-+CONFIG_RT2X00_LIB_EEPROM=y
- CONFIG_RT2X00_LIB_CRYPTO=y
- # CONFIG_RT2X00_LIB_SOC=y
+@@ -624,6 +624,7 @@ export CONFIG_RT2X00=y
+ export CONFIG_RT2X00_LIB=m
+ export CONFIG_RT2800_LIB=m
+ export CONFIG_RT2X00_LIB_FIRMWARE=y
++export CONFIG_RT2X00_LIB_EEPROM=y
+ export CONFIG_RT2X00_LIB_CRYPTO=y
+ # export CONFIG_RT2X00_LIB_SOC=y
  ifdef CONFIG_COMPAT_KERNEL_2_6_25
diff '--exclude=.svn' -Nur package/mac80211/patches/605-rt2x00-pci-eeprom.patch ../openwrt-trunk/package/mac80211/patches/605-rt2x00-pci-eeprom.patch
--- package/mac80211/patches/605-rt2x00-pci-eeprom.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/605-rt2x00-pci-eeprom.patch	2012-08-18 14:47:33.125458002 +0200
@@ -9,7 +9,7 @@
  {
  	memcpy(rt2x00dev->eeprom, rt2x00dev->eeprom_file->data, EEPROM_SIZE);
  }
-@@ -938,8 +938,9 @@ static int rt2800pci_validate_eeprom(str
+@@ -974,8 +974,9 @@ static int rt2800pci_validate_eeprom(str
  	/*
  	 * Read EEPROM into buffer
  	 */
@@ -30,8 +30,8 @@
 +	struct rt2x00_platform_data *pdata;
  	struct rt2x00_dev *rt2x00dev;
  	int retval;
- 
-@@ -299,6 +300,12 @@ int rt2x00pci_probe(struct pci_dev *pci_
+ 	u16 chip;
+@@ -300,6 +301,12 @@ int rt2x00pci_probe(struct pci_dev *pci_
  	rt2x00dev->irq = pci_dev->irq;
  	rt2x00dev->name = pci_name(pci_dev);
  
diff '--exclude=.svn' -Nur package/mac80211/patches/606-rt2x00_no_realign.patch ../openwrt-trunk/package/mac80211/patches/606-rt2x00_no_realign.patch
--- package/mac80211/patches/606-rt2x00_no_realign.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/606-rt2x00_no_realign.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,67 @@
+[RFC] rt2x00: For drivers that only need L2 padding don't realign frames
+
+Signed-off-by: Helmut Schaa <helmut.schaa@...>
+---
+
+Ivo, Gertjan, do you remeber by any chance why this alignment stuff was added
+in the first place? Was it because of DMA restrictions?
+
+While doing some profiling on the rt3052 SoC I noticed that 30-40% time was
+spent in memmove calls. And the culprit is the memmove aligning the payload
+to a 4byte boundary since that has to move a whole bunch of data.
+
+Interesstingly the legacy drivers insert an l2pad between the header and the
+payload but doesn't realign the payload itself to a 4-byte boundary. Hence,
+I came up with this patch and indeed CPU usage improves impressively.
+
+Only tested on rt2800pci!
+
+Thanks,
+Helmut
+
+ drivers/net/wireless/rt2x00/rt2x00queue.c |   30 +++-------------------------
+ 1 files changed, 4 insertions(+), 26 deletions(-)
+
+--- a/drivers/net/wireless/rt2x00/rt2x00queue.c
++++ b/drivers/net/wireless/rt2x00/rt2x00queue.c
+@@ -151,36 +151,14 @@ void rt2x00queue_align_frame(struct sk_b
+ void rt2x00queue_insert_l2pad(struct sk_buff *skb, unsigned int header_length)
+ {
+ 	unsigned int payload_length = skb->len - header_length;
+-	unsigned int header_align = ALIGN_SIZE(skb, 0);
+-	unsigned int payload_align = ALIGN_SIZE(skb, header_length);
+ 	unsigned int l2pad = payload_length ? L2PAD_SIZE(header_length) : 0;
+ 
+-	/*
+-	 * Adjust the header alignment if the payload needs to be moved more
+-	 * than the header.
+-	 */
+-	if (payload_align > header_align)
+-		header_align += 4;
+-
+-	/* There is nothing to do if no alignment is needed */
+-	if (!header_align)
++	if (!l2pad)
+ 		return;
+ 
+-	/* Reserve the amount of space needed in front of the frame */
+-	skb_push(skb, header_align);
+-
+-	/*
+-	 * Move the header.
+-	 */
+-	memmove(skb->data, skb->data + header_align, header_length);
+-
+-	/* Move the payload, if present and if required */
+-	if (payload_length && payload_align)
+-		memmove(skb->data + header_length + l2pad,
+-			skb->data + header_length + l2pad + payload_align,
+-			payload_length);
+-
+-	/* Trim the skb to the correct size */
++	/* insert l2pad -> Move header */
++	skb_push(skb, l2pad);
++	memmove(skb->data, skb->data + l2pad, header_length);
+ 	skb_trim(skb, header_length + l2pad + payload_length);
+ }
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch ../openwrt-trunk/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch
--- package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/607-rt2x00-allow_disabling_bands_through_platform_data.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,47 @@
+--- a/include/linux/rt2x00_platform.h
++++ b/include/linux/rt2x00_platform.h
+@@ -14,6 +14,9 @@
+ 
+ struct rt2x00_platform_data {
+ 	char *eeprom_file_name;
++
++	int disable_2ghz;
++	int disable_5ghz;
+ };
+ 
+ #endif /* _RT2X00_PLATFORM_H */
+--- a/drivers/net/wireless/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
+@@ -834,6 +834,22 @@ static int rt2x00lib_probe_hw_modes(stru
+ 	unsigned int num_rates;
+ 	unsigned int i;
+ 
++	if (rt2x00dev->dev->platform_data) {
++		struct rt2x00_platform_data *pdata;
++
++		pdata = rt2x00dev->dev->platform_data;
++		if (pdata->disable_2ghz)
++			spec->supported_bands &= ~SUPPORT_BAND_2GHZ;
++		if (pdata->disable_5ghz)
++			spec->supported_bands &= ~SUPPORT_BAND_5GHZ;
++	}
++
++	if ((spec->supported_bands & SUPPORT_BAND_BOTH) == 0) {
++		ERROR(rt2x00dev, "No supported bands\n");
++		return -EINVAL;
++	}
++
++
+ 	num_rates = 0;
+ 	if (spec->supported_rates & SUPPORT_RATE_CCK)
+ 		num_rates += 4;
+--- a/drivers/net/wireless/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -425,6 +425,7 @@ struct hw_mode_spec {
+ 	unsigned int supported_bands;
+ #define SUPPORT_BAND_2GHZ	0x00000001
+ #define SUPPORT_BAND_5GHZ	0x00000002
++#define SUPPORT_BAND_BOTH	(SUPPORT_BAND_2GHZ | SUPPORT_BAND_5GHZ)
+ 
+ 	unsigned int supported_rates;
+ #define SUPPORT_RATE_CCK	0x00000001
diff '--exclude=.svn' -Nur package/mac80211/patches/608-add_platform_data_mac_addr.patch ../openwrt-trunk/package/mac80211/patches/608-add_platform_data_mac_addr.patch
--- package/mac80211/patches/608-add_platform_data_mac_addr.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/608-add_platform_data_mac_addr.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,63 @@
+--- a/include/linux/rt2x00_platform.h
++++ b/include/linux/rt2x00_platform.h
+@@ -14,6 +14,7 @@
+ 
+ struct rt2x00_platform_data {
+ 	char *eeprom_file_name;
++	const u8 *mac_address;
+ 
+ 	int disable_2ghz;
+ 	int disable_5ghz;
+--- a/drivers/net/wireless/rt2x00/rt2x00dev.c
++++ b/drivers/net/wireless/rt2x00/rt2x00dev.c
+@@ -825,6 +825,18 @@ static void rt2x00lib_rate(struct ieee80
+ 		entry->flags |= IEEE80211_RATE_SHORT_PREAMBLE;
+ }
+ 
++const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev)
++{
++	struct rt2x00_platform_data *pdata;
++
++	pdata = rt2x00dev->dev->platform_data;
++	if (!pdata)
++		return NULL;
++
++	return pdata->mac_address;
++}
++EXPORT_SYMBOL_GPL(rt2x00lib_get_mac_address);
++
+ static int rt2x00lib_probe_hw_modes(struct rt2x00_dev *rt2x00dev,
+ 				    struct hw_mode_spec *spec)
+ {
+--- a/drivers/net/wireless/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -1280,6 +1280,7 @@ static inline void rt2x00debug_dump_fram
+  */
+ u32 rt2x00lib_get_bssidx(struct rt2x00_dev *rt2x00dev,
+ 			 struct ieee80211_vif *vif);
++const u8 *rt2x00lib_get_mac_address(struct rt2x00_dev *rt2x00dev);
+ 
+ /*
+  * Interrupt context handlers.
+--- a/drivers/net/wireless/rt2x00/rt61pci.c
++++ b/drivers/net/wireless/rt2x00/rt61pci.c
+@@ -2393,6 +2393,7 @@ static int rt61pci_validate_eeprom(struc
+ 	u32 reg;
+ 	u16 word;
+ 	u8 *mac;
++	const u8 *pdata_mac;
+ 	s8 value;
+ 
+ 	rt2x00pci_register_read(rt2x00dev, E2PROM_CSR, &reg);
+@@ -2413,7 +2414,11 @@ static int rt61pci_validate_eeprom(struc
+ 	/*
+ 	 * Start validation of the data that has been read.
+ 	 */
++	pdata_mac = rt2x00lib_get_mac_address(rt2x00dev);
+ 	mac = rt2x00_eeprom_addr(rt2x00dev, EEPROM_MAC_ADDR_0);
++	if (pdata_mac)
++		memcpy(mac, pdata_mac, 6);
++
+ 	if (!is_valid_ether_addr(mac)) {
+ 		random_ether_addr(mac);
+ 		EEPROM(rt2x00dev, "MAC: %pM\n", mac);
diff '--exclude=.svn' -Nur package/mac80211/patches/620-rt2x00-support-rt3352.patch ../openwrt-trunk/package/mac80211/patches/620-rt2x00-support-rt3352.patch
--- package/mac80211/patches/620-rt2x00-support-rt3352.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/620-rt2x00-support-rt3352.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,445 @@
+--- a/drivers/net/wireless/rt2x00/rt2800lib.c
++++ b/drivers/net/wireless/rt2x00/rt2800lib.c
+@@ -1547,6 +1547,7 @@ void rt2800_config_ant(struct rt2x00_dev
+ 	case 1:
+ 		if (rt2x00_rt(rt2x00dev, RT3070) ||
+ 		    rt2x00_rt(rt2x00dev, RT3090) ||
++		    rt2x00_rt(rt2x00dev, RT3352) ||
+ 		    rt2x00_rt(rt2x00dev, RT3390)) {
+ 			rt2x00_eeprom_read(rt2x00dev,
+ 					   EEPROM_NIC_CONF1, &eeprom);
+@@ -1985,6 +1986,58 @@ static void rt2800_config_channel_rf3290
+ 	}
+ }
+ 
++static void rt2800_config_channel_rf3322(struct rt2x00_dev *rt2x00dev,
++					 struct ieee80211_conf *conf,
++					 struct rf_channel *rf,
++					 struct channel_info *info)
++{
++	u8 rfcsr;
++
++	rt2800_rfcsr_write(rt2x00dev, 8, rf->rf1);
++	rt2800_rfcsr_write(rt2x00dev, 9, rf->rf3);
++
++	rt2800_rfcsr_write(rt2x00dev, 11, 0x42);
++	rt2800_rfcsr_write(rt2x00dev, 12, 0x1C);
++	rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
++
++	if (info->default_power1 > POWER_BOUND)
++		rt2800_rfcsr_write(rt2x00dev, 47, POWER_BOUND);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 47, info->default_power1);
++
++	if (info->default_power2 > POWER_BOUND)
++		rt2800_rfcsr_write(rt2x00dev, 48, POWER_BOUND);
++	else
++		rt2800_rfcsr_write(rt2x00dev, 48, info->default_power2);
++
++	rt2800_rfcsr_read(rt2x00dev, 17, &rfcsr);
++	if (rt2x00dev->freq_offset > FREQ_OFFSET_BOUND)
++		rt2x00_set_field8(&rfcsr, RFCSR17_CODE,
++				  FREQ_OFFSET_BOUND);
++	else
++		rt2x00_set_field8(&rfcsr, RFCSR17_CODE, rt2x00dev->freq_offset);
++
++	rt2800_rfcsr_write(rt2x00dev, 17, rfcsr);
++
++	rt2800_rfcsr_read(rt2x00dev, 1, &rfcsr);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX0_PD, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX0_PD, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 1);
++	rt2x00_set_field8(&rfcsr, RFCSR1_RX2_PD, 0);
++	rt2x00_set_field8(&rfcsr, RFCSR1_TX2_PD, 0);
++
++	if ( rt2x00dev->default_ant.tx_chain_num == 1 )
++		rt2x00_set_field8(&rfcsr, RFCSR1_TX1_PD, 0);
++
++	if ( rt2x00dev->default_ant.rx_chain_num == 1 )
++		rt2x00_set_field8(&rfcsr, RFCSR1_RX1_PD, 0);
++
++	rt2800_rfcsr_write(rt2x00dev, 1, rfcsr);
++
++	rt2800_rfcsr_write(rt2x00dev, 31, 80);
++}
++
+ static void rt2800_config_channel_rf53xx(struct rt2x00_dev *rt2x00dev,
+ 					 struct ieee80211_conf *conf,
+ 					 struct rf_channel *rf,
+@@ -2114,6 +2167,9 @@ static void rt2800_config_channel(struct
+ 	case RF3290:
+ 		rt2800_config_channel_rf3290(rt2x00dev, conf, rf, info);
+ 		break;
++	case RF3322:
++		rt2800_config_channel_rf3322(rt2x00dev, conf, rf, info);
++		break;
+ 	case RF5360:
+ 	case RF5370:
+ 	case RF5372:
+@@ -2126,6 +2182,7 @@ static void rt2800_config_channel(struct
+ 	}
+ 
+ 	if (rt2x00_rf(rt2x00dev, RF3290) ||
++	    rt2x00_rf(rt2x00dev, RF3322) ||
+ 	    rt2x00_rf(rt2x00dev, RF5360) ||
+ 	    rt2x00_rf(rt2x00dev, RF5370) ||
+ 	    rt2x00_rf(rt2x00dev, RF5372) ||
+@@ -2144,10 +2201,20 @@ static void rt2800_config_channel(struct
+ 	/*
+ 	 * Change BBP settings
+ 	 */
+-	rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
+-	rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
+-	rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
+-	rt2800_bbp_write(rt2x00dev, 86, 0);
++	if (rt2x00_rt(rt2x00dev, RT3352))
++	{
++		rt2800_bbp_write(rt2x00dev, 27, 0x0);
++		rt2800_bbp_write(rt2x00dev, 62, 0x26 + rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 27, 0x20);
++		rt2800_bbp_write(rt2x00dev, 62, 0x26 + rt2x00dev->lna_gain);
++	}
++	else
++	{
++		rt2800_bbp_write(rt2x00dev, 62, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 63, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 64, 0x37 - rt2x00dev->lna_gain);
++		rt2800_bbp_write(rt2x00dev, 86, 0);
++	}
+ 
+ 	if (rf->channel <= 14) {
+ 		if (!rt2x00_rt(rt2x00dev, RT5390) &&
+@@ -2242,6 +2309,16 @@ static void rt2800_config_channel(struct
+ 	rt2800_register_read(rt2x00dev, CH_IDLE_STA, &reg);
+ 	rt2800_register_read(rt2x00dev, CH_BUSY_STA, &reg);
+ 	rt2800_register_read(rt2x00dev, CH_BUSY_STA_SEC, &reg);
++
++	/*
++	 * Clear update flag
++	 */
++	if (rt2x00_rt(rt2x00dev, RT3352))
++	{
++		rt2800_bbp_read(rt2x00dev, 49, &bbp);
++		rt2x00_set_field8(&bbp, BBP49_UPDATE_FLAG, 0);
++		rt2800_bbp_write(rt2x00dev, 49, bbp);
++	}
+ }
+ 
+ static int rt2800_get_gain_calibration_delta(struct rt2x00_dev *rt2x00dev)
+@@ -2893,11 +2970,15 @@ static int rt2800_init_registers(struct 
+ 	if (rt2x00_rt(rt2x00dev, RT3071) ||
+ 	    rt2x00_rt(rt2x00dev, RT3090) ||
+ 	    rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3390)) {
+ 
+ 		if (rt2x00_rt(rt2x00dev, RT3290))
+ 			rt2800_register_write(rt2x00dev, TX_SW_CFG0,
+ 					      0x00000404);
++		else if (rt2x00_rt(rt2x00dev, RT3352))
++			rt2800_register_write(rt2x00dev, TX_SW_CFG0,
++					      0x00000402);
+ 		else
+ 			rt2800_register_write(rt2x00dev, TX_SW_CFG0,
+ 					      0x00000400);
+@@ -3310,6 +3391,11 @@ static int rt2800_init_bbp(struct rt2x00
+ 		     rt2800_wait_bbp_ready(rt2x00dev)))
+ 		return -EACCES;
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 3, 0x00);
++		rt2800_bbp_write(rt2x00dev, 4, 0x50);
++	}
++
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392)) {
+@@ -3320,15 +3406,20 @@ static int rt2800_init_bbp(struct rt2x00
+ 
+ 	if (rt2800_is_305x_soc(rt2x00dev) ||
+ 	    rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3572) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 31, 0x08);
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 47, 0x48);
++
+ 	rt2800_bbp_write(rt2x00dev, 65, 0x2c);
+ 	rt2800_bbp_write(rt2x00dev, 66, 0x38);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 68, 0x0b);
+@@ -3337,6 +3428,7 @@ static int rt2800_init_bbp(struct rt2x00
+ 		rt2800_bbp_write(rt2x00dev, 69, 0x16);
+ 		rt2800_bbp_write(rt2x00dev, 73, 0x12);
+ 	} else if (rt2x00_rt(rt2x00dev, RT3290) ||
++		   rt2x00_rt(rt2x00dev, RT3352) ||
+ 		   rt2x00_rt(rt2x00dev, RT5390) ||
+ 		   rt2x00_rt(rt2x00dev, RT5392)) {
+ 		rt2800_bbp_write(rt2x00dev, 69, 0x12);
+@@ -3368,6 +3460,10 @@ static int rt2800_init_bbp(struct rt2x00
+ 	} else if (rt2800_is_305x_soc(rt2x00dev)) {
+ 		rt2800_bbp_write(rt2x00dev, 78, 0x0e);
+ 		rt2800_bbp_write(rt2x00dev, 80, 0x08);
++	} else if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 78, 0x0e);
++		rt2800_bbp_write(rt2x00dev, 80, 0x08);
++		rt2800_bbp_write(rt2x00dev, 81, 0x37);
+ 	} else {
+ 		rt2800_bbp_write(rt2x00dev, 81, 0x37);
+ 	}
+@@ -3397,18 +3493,21 @@ static int rt2800_init_bbp(struct rt2x00
+ 		rt2800_bbp_write(rt2x00dev, 84, 0x99);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 86, 0x38);
+ 	else
+ 		rt2800_bbp_write(rt2x00dev, 86, 0x00);
+ 
+-	if (rt2x00_rt(rt2x00dev, RT5392))
++	if (rt2x00_rt(rt2x00dev, RT5392) ||
++	    rt2x00_rt(rt2x00dev, RT3352))
+ 		rt2800_bbp_write(rt2x00dev, 88, 0x90);
+ 
+ 	rt2800_bbp_write(rt2x00dev, 91, 0x04);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 92, 0x02);
+@@ -3425,6 +3524,7 @@ static int rt2800_init_bbp(struct rt2x00
+ 	    rt2x00_rt_rev_gte(rt2x00dev, RT3090, REV_RT3090E) ||
+ 	    rt2x00_rt_rev_gte(rt2x00dev, RT3390, REV_RT3390E) ||
+ 	    rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3572) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392) ||
+@@ -3434,6 +3534,7 @@ static int rt2800_init_bbp(struct rt2x00
+ 		rt2800_bbp_write(rt2x00dev, 103, 0x00);
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 104, 0x92);
+@@ -3442,6 +3543,8 @@ static int rt2800_init_bbp(struct rt2x00
+ 		rt2800_bbp_write(rt2x00dev, 105, 0x01);
+ 	else if (rt2x00_rt(rt2x00dev, RT3290))
+ 		rt2800_bbp_write(rt2x00dev, 105, 0x1c);
++	else if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 105, 0x34);
+ 	else if (rt2x00_rt(rt2x00dev, RT5390) ||
+ 			 rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 105, 0x3c);
+@@ -3451,11 +3554,16 @@ static int rt2800_init_bbp(struct rt2x00
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390))
+ 		rt2800_bbp_write(rt2x00dev, 106, 0x03);
++	else if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 106, 0x05);
+ 	else if (rt2x00_rt(rt2x00dev, RT5392))
+ 		rt2800_bbp_write(rt2x00dev, 106, 0x12);
+ 	else
+ 		rt2800_bbp_write(rt2x00dev, 106, 0x35);
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 120, 0x50);
++
+ 	if (rt2x00_rt(rt2x00dev, RT3290) ||
+ 	    rt2x00_rt(rt2x00dev, RT5390) ||
+ 	    rt2x00_rt(rt2x00dev, RT5392))
+@@ -3466,6 +3574,9 @@ static int rt2800_init_bbp(struct rt2x00
+ 		rt2800_bbp_write(rt2x00dev, 135, 0xf6);
+ 	}
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352))
++		rt2800_bbp_write(rt2x00dev, 137, 0x0F);
++
+ 	if (rt2x00_rt(rt2x00dev, RT3071) ||
+ 	    rt2x00_rt(rt2x00dev, RT3090) ||
+ 	    rt2x00_rt(rt2x00dev, RT3390) ||
+@@ -3506,6 +3617,28 @@ static int rt2800_init_bbp(struct rt2x00
+ 		rt2800_bbp_write(rt2x00dev, 3, value);
+ 	}
+ 
++	if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_bbp_write(rt2x00dev, 163, 0xBD);
++		/* Set ITxBF timeout to 0x9C40=1000msec */
++		rt2800_bbp_write(rt2x00dev, 179, 0x02);
++		rt2800_bbp_write(rt2x00dev, 180, 0x00);
++		rt2800_bbp_write(rt2x00dev, 182, 0x40);
++		rt2800_bbp_write(rt2x00dev, 180, 0x01);
++		rt2800_bbp_write(rt2x00dev, 182, 0x9C);
++		rt2800_bbp_write(rt2x00dev, 179, 0x00);
++		/* Reprogram the inband interface to put right values in RXWI */
++		rt2800_bbp_write(rt2x00dev, 142, 0x04);
++		rt2800_bbp_write(rt2x00dev, 143, 0x3b);
++		rt2800_bbp_write(rt2x00dev, 142, 0x06);
++		rt2800_bbp_write(rt2x00dev, 143, 0xA0);
++		rt2800_bbp_write(rt2x00dev, 142, 0x07);
++		rt2800_bbp_write(rt2x00dev, 143, 0xA1);
++		rt2800_bbp_write(rt2x00dev, 142, 0x08);
++		rt2800_bbp_write(rt2x00dev, 143, 0xA2);
++
++		rt2800_bbp_write(rt2x00dev, 148, 0xC8);
++	}
++
+ 	if (rt2x00_rt(rt2x00dev, RT5390) ||
+ 		rt2x00_rt(rt2x00dev, RT5392)) {
+ 		int ant, div_mode;
+@@ -3639,6 +3772,7 @@ static int rt2800_init_rfcsr(struct rt2x
+ 	    !rt2x00_rt(rt2x00dev, RT3071) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3090) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3290) &&
++	    !rt2x00_rt(rt2x00dev, RT3352) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3390) &&
+ 	    !rt2x00_rt(rt2x00dev, RT3572) &&
+ 	    !rt2x00_rt(rt2x00dev, RT5390) &&
+@@ -3835,6 +3969,71 @@ static int rt2800_init_rfcsr(struct rt2x
+ 		rt2800_rfcsr_write(rt2x00dev, 30, 0x00);
+ 		rt2800_rfcsr_write(rt2x00dev, 31, 0x00);
+ 		return 0;
++	} else if (rt2x00_rt(rt2x00dev, RT3352)) {
++		rt2800_rfcsr_write(rt2x00dev, 0, 0xF0);
++		rt2800_rfcsr_write(rt2x00dev, 1, 0x23);
++		rt2800_rfcsr_write(rt2x00dev, 2, 0x50);
++		rt2800_rfcsr_write(rt2x00dev, 3, 0x18);
++		rt2800_rfcsr_write(rt2x00dev, 4, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 5, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 6, 0x33);
++		rt2800_rfcsr_write(rt2x00dev, 7, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 8, 0xF1);
++		rt2800_rfcsr_write(rt2x00dev, 9, 0x02);
++		rt2800_rfcsr_write(rt2x00dev, 10, 0xD2);
++		rt2800_rfcsr_write(rt2x00dev, 11, 0x42);
++		rt2800_rfcsr_write(rt2x00dev, 12, 0x1C);
++		rt2800_rfcsr_write(rt2x00dev, 13, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 14, 0x5A);
++		rt2800_rfcsr_write(rt2x00dev, 15, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 16, 0x01);
++/*		rt2800_rfcsr_write(rt2x00dev, 17, 0x1A); */
++		rt2800_rfcsr_write(rt2x00dev, 18, 0x45);
++		rt2800_rfcsr_write(rt2x00dev, 19, 0x02);
++		rt2800_rfcsr_write(rt2x00dev, 20, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 21, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 22, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 23, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 24, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 25, 0x80);
++		rt2800_rfcsr_write(rt2x00dev, 26, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 27, 0x03);
++		rt2800_rfcsr_write(rt2x00dev, 28, 0x03);
++		rt2800_rfcsr_write(rt2x00dev, 29, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 30, 0x10);
++		rt2800_rfcsr_write(rt2x00dev, 31, 0x80);
++		rt2800_rfcsr_write(rt2x00dev, 32, 0x80);
++		rt2800_rfcsr_write(rt2x00dev, 33, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 34, 0x01);
++		rt2800_rfcsr_write(rt2x00dev, 35, 0x03);
++		rt2800_rfcsr_write(rt2x00dev, 36, 0xBD);
++		rt2800_rfcsr_write(rt2x00dev, 37, 0x3C);
++		rt2800_rfcsr_write(rt2x00dev, 38, 0x5F);
++		rt2800_rfcsr_write(rt2x00dev, 39, 0xC5);
++		rt2800_rfcsr_write(rt2x00dev, 40, 0x33);
++		rt2800_rfcsr_write(rt2x00dev, 41, 0x5B);
++		rt2800_rfcsr_write(rt2x00dev, 42, 0x5B);
++		rt2800_rfcsr_write(rt2x00dev, 43, 0xDB);
++		rt2800_rfcsr_write(rt2x00dev, 44, 0xDB);
++		rt2800_rfcsr_write(rt2x00dev, 45, 0xDB);
++		rt2800_rfcsr_write(rt2x00dev, 46, 0xDD);
++		rt2800_rfcsr_write(rt2x00dev, 47, 0x0D);
++		rt2800_rfcsr_write(rt2x00dev, 48, 0x14);
++		rt2800_rfcsr_write(rt2x00dev, 49, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 50, 0x2D);
++		rt2800_rfcsr_write(rt2x00dev, 51, 0x7F);
++		rt2800_rfcsr_write(rt2x00dev, 52, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 53, 0x52);
++		rt2800_rfcsr_write(rt2x00dev, 54, 0x1B);
++		rt2800_rfcsr_write(rt2x00dev, 55, 0x7F);
++		rt2800_rfcsr_write(rt2x00dev, 56, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 57, 0x52);
++		rt2800_rfcsr_write(rt2x00dev, 58, 0x1B);
++		rt2800_rfcsr_write(rt2x00dev, 59, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 60, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 61, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 62, 0x00);
++		rt2800_rfcsr_write(rt2x00dev, 63, 0x00);
+ 	} else if (rt2x00_rt(rt2x00dev, RT5390)) {
+ 		rt2800_rfcsr_write(rt2x00dev, 1, 0x0f);
+ 		rt2800_rfcsr_write(rt2x00dev, 2, 0x80);
+@@ -4035,6 +4234,7 @@ static int rt2800_init_rfcsr(struct rt2x
+ 			rt2800_init_rx_filter(rt2x00dev, true, 0x27, 0x19);
+ 	} else if (rt2x00_rt(rt2x00dev, RT3071) ||
+ 		   rt2x00_rt(rt2x00dev, RT3090) ||
++		   rt2x00_rt(rt2x00dev, RT3352) ||
+ 		   rt2x00_rt(rt2x00dev, RT3390) ||
+ 		   rt2x00_rt(rt2x00dev, RT3572)) {
+ 		drv_data->calibration_bw20 =
+@@ -4493,6 +4693,7 @@ int rt2800_init_eeprom(struct rt2x00_dev
+ 	case RT3071:
+ 	case RT3090:
+ 	case RT3290:
++	case RT3352:
+ 	case RT3390:
+ 	case RT3572:
+ 	case RT5390:
+@@ -4515,6 +4716,7 @@ int rt2800_init_eeprom(struct rt2x00_dev
+ 	case RF3052:
+ 	case RF3290:
+ 	case RF3320:
++	case RF3322:
+ 	case RF5360:
+ 	case RF5370:
+ 	case RF5372:
+@@ -4539,6 +4741,7 @@ int rt2800_init_eeprom(struct rt2x00_dev
+ 
+ 	if (rt2x00_rt(rt2x00dev, RT3070) ||
+ 	    rt2x00_rt(rt2x00dev, RT3090) ||
++	    rt2x00_rt(rt2x00dev, RT3352) ||
+ 	    rt2x00_rt(rt2x00dev, RT3390)) {
+ 		value = rt2x00_get_field16(eeprom,
+ 				EEPROM_NIC_CONF1_ANT_DIVERSITY);
+@@ -4832,6 +5035,7 @@ int rt2800_probe_hw_mode(struct rt2x00_d
+ 		   rt2x00_rf(rt2x00dev, RF3022) ||
+ 		   rt2x00_rf(rt2x00dev, RF3290) ||
+ 		   rt2x00_rf(rt2x00dev, RF3320) ||
++		   rt2x00_rf(rt2x00dev, RF3322) ||
+ 		   rt2x00_rf(rt2x00dev, RF5360) ||
+ 		   rt2x00_rf(rt2x00dev, RF5370) ||
+ 		   rt2x00_rf(rt2x00dev, RF5372) ||
+--- a/drivers/net/wireless/rt2x00/rt2x00.h
++++ b/drivers/net/wireless/rt2x00/rt2x00.h
+@@ -189,6 +189,7 @@ struct rt2x00_chip {
+ #define RT3071		0x3071
+ #define RT3090		0x3090	/* 2.4GHz PCIe */
+ #define RT3290		0x3290
++#define RT3352		0x3352  /* WSOC */
+ #define RT3390		0x3390
+ #define RT3572		0x3572
+ #define RT3593		0x3593
+--- a/drivers/net/wireless/rt2x00/rt2800.h
++++ b/drivers/net/wireless/rt2x00/rt2800.h
+@@ -1936,6 +1936,11 @@ struct mac_iveiv_entry {
+ #define BBP47_TSSI_ADC6			FIELD8(0x80)
+ 
+ /*
++ * BBP 49
++ */
++#define BBP49_UPDATE_FLAG		FIELD8(0x01)
++
++/*
+  * BBP 109
+  */
+ #define BBP109_TX0_POWER		FIELD8(0x0f)
diff '--exclude=.svn' -Nur package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch ../openwrt-trunk/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch
--- package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch	2012-08-17 15:40:46.501971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/700-mwl8k-missing-pci-id-for-WNR854T.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/mwl8k.c
 +++ b/drivers/net/wireless/mwl8k.c
-@@ -5193,6 +5193,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
+@@ -5299,6 +5299,7 @@ MODULE_FIRMWARE("mwl8k/fmimage_8366.fw")
  MODULE_FIRMWARE(MWL8K_8366_AP_FW(MWL8K_8366_AP_FW_API));
  
  static DEFINE_PCI_DEVICE_TABLE(mwl8k_pci_id_table) = {
diff '--exclude=.svn' -Nur package/mac80211/patches/800-b43-gpio-mask-module-option.patch ../openwrt-trunk/package/mac80211/patches/800-b43-gpio-mask-module-option.patch
--- package/mac80211/patches/800-b43-gpio-mask-module-option.patch	2012-08-17 15:40:46.511971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/800-b43-gpio-mask-module-option.patch	2012-08-18 14:47:33.125458002 +0200
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/b43/b43.h
 +++ b/drivers/net/wireless/b43/b43.h
-@@ -791,6 +791,7 @@ struct b43_wldev {
+@@ -803,6 +803,7 @@ struct b43_wldev {
  	bool qos_enabled;		/* TRUE, if QoS is used. */
  	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
  	bool use_pio;			/* TRUE if next init should use PIO */
@@ -22,12 +22,12 @@
  static int modparam_bad_frames_preempt;
  module_param_named(bad_frames_preempt, modparam_bad_frames_preempt, int, 0444);
  MODULE_PARM_DESC(bad_frames_preempt,
-@@ -2686,10 +2691,10 @@ static int b43_gpio_init(struct b43_wlde
- 		    & ~B43_MACCTL_GPOUTSMSK);
+@@ -2690,10 +2695,10 @@ static int b43_gpio_init(struct b43_wlde
+ 	u32 mask, set;
  
- 	b43_write16(dev, B43_MMIO_GPIO_MASK, b43_read16(dev, B43_MMIO_GPIO_MASK)
--		    | 0x000F);
-+		    | modparam_gpiomask);
+ 	b43_maskset32(dev, B43_MMIO_MACCTL, ~B43_MACCTL_GPOUTSMSK, 0);
+-	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, 0xF);
++	b43_maskset16(dev, B43_MMIO_GPIO_MASK, ~0, modparam_gpiomask);
  
  	mask = 0x0000001F;
 -	set = 0x0000000F;
diff '--exclude=.svn' -Nur package/mac80211/patches/805-fix_gpio_bcm5354.patch ../openwrt-trunk/package/mac80211/patches/805-fix_gpio_bcm5354.patch
--- package/mac80211/patches/805-fix_gpio_bcm5354.patch	2012-08-17 15:40:46.481971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/805-fix_gpio_bcm5354.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,11 +0,0 @@
---- a/drivers/net/wireless/b43/main.c
-+++ b/drivers/net/wireless/b43/main.c
-@@ -2699,6 +2699,8 @@ static int b43_gpio_init(struct b43_wlde
- 		mask |= 0x0060;
- 		set |= 0x0060;
- 	}
-+	if (dev->dev->chip_id == 0x5354)
-+		set &= 0xff02;
- 	if (0 /* FIXME: conditional unknown */ ) {
- 		b43_write16(dev, B43_MMIO_GPIO_MASK,
- 			    b43_read16(dev, B43_MMIO_GPIO_MASK)
diff '--exclude=.svn' -Nur package/mac80211/patches/810-b43_no_pio.patch ../openwrt-trunk/package/mac80211/patches/810-b43_no_pio.patch
--- package/mac80211/patches/810-b43_no_pio.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/810-b43_no_pio.patch	2012-08-18 14:47:33.115458002 +0200
@@ -11,18 +11,19 @@
  b43-$(CONFIG_B43_PCMCIA)	+= pcmcia.o
 --- a/drivers/net/wireless/b43/main.c
 +++ b/drivers/net/wireless/b43/main.c
-@@ -1893,9 +1893,11 @@ static void b43_do_interrupt_thread(stru
+@@ -1885,10 +1885,12 @@ static void b43_do_interrupt_thread(stru
+ 			       dma_reason[0], dma_reason[1],
+ 			       dma_reason[2], dma_reason[3],
  			       dma_reason[4], dma_reason[5]);
++#ifdef CONFIG_B43_PIO
  			b43err(dev->wl, "This device does not support DMA "
  			       "on your system. It will now be switched to PIO.\n");
-+#ifdef CONFIG_B43_PIO
  			/* Fall back to PIO transfers if we get fatal DMA errors! */
- 			dev->use_pio = 1;
- 			b43_controller_restart(dev, "DMA error");
+ 			dev->use_pio = true;
 +#endif
+ 			b43_controller_restart(dev, "DMA error");
  			return;
  		}
- 		if (merged_dma_reason & B43_DMAIRQ_NONFATALMASK) {
 --- a/drivers/net/wireless/b43/pio.h
 +++ b/drivers/net/wireless/b43/pio.h
 @@ -150,7 +150,7 @@ static inline void b43_piorx_write32(str
diff '--exclude=.svn' -Nur package/mac80211/patches/820-b43-add-antenna-control.patch ../openwrt-trunk/package/mac80211/patches/820-b43-add-antenna-control.patch
--- package/mac80211/patches/820-b43-add-antenna-control.patch	2012-08-17 15:40:46.461971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/820-b43-add-antenna-control.patch	2012-08-18 14:47:33.105458002 +0200
@@ -1,6 +1,6 @@
 --- a/drivers/net/wireless/b43/main.c
 +++ b/drivers/net/wireless/b43/main.c
-@@ -1535,7 +1535,7 @@ static void b43_write_beacon_template(st
+@@ -1529,7 +1529,7 @@ static void b43_write_beacon_template(st
  				  len, ram_offset, shm_size_offset, rate);
  
  	/* Write the PHY TX control parameters. */
@@ -9,7 +9,7 @@
  	antenna = b43_antenna_to_phyctl(antenna);
  	ctl = b43_shm_read16(dev, B43_SHM_SHARED, B43_SHM_SH_BEACPHYCTL);
  	/* We can't send beacons with short preamble. Would get PHY errors. */
-@@ -3052,8 +3052,8 @@ static int b43_chip_init(struct b43_wlde
+@@ -3046,8 +3046,8 @@ static int b43_chip_init(struct b43_wlde
  
  	/* Select the antennae */
  	if (phy->ops->set_rx_antenna)
@@ -20,7 +20,7 @@
  
  	if (phy->type == B43_PHYTYPE_B) {
  		value16 = b43_read16(dev, 0x005E);
-@@ -3782,7 +3782,6 @@ static int b43_op_config(struct ieee8021
+@@ -3790,7 +3790,6 @@ static int b43_op_config(struct ieee8021
  	struct b43_wldev *dev;
  	struct b43_phy *phy;
  	struct ieee80211_conf *conf = &hw->conf;
@@ -28,7 +28,7 @@
  	int err = 0;
  	bool reload_bss = false;
  
-@@ -3836,11 +3835,9 @@ static int b43_op_config(struct ieee8021
+@@ -3844,11 +3843,9 @@ static int b43_op_config(struct ieee8021
  	}
  
  	/* Antennas for RX and management frame TX. */
@@ -42,7 +42,7 @@
  
  	if (wl->radio_enabled != phy->radio_on) {
  		if (wl->radio_enabled) {
-@@ -4910,6 +4907,47 @@ static int b43_op_get_survey(struct ieee
+@@ -4941,6 +4938,47 @@ static int b43_op_get_survey(struct ieee
  	return 0;
  }
  
@@ -90,7 +90,7 @@
  static const struct ieee80211_ops b43_hw_ops = {
  	.tx			= b43_op_tx,
  	.conf_tx		= b43_op_conf_tx,
-@@ -4931,6 +4969,8 @@ static const struct ieee80211_ops b43_hw
+@@ -4962,6 +5000,8 @@ static const struct ieee80211_ops b43_hw
  	.sw_scan_complete	= b43_op_sw_scan_complete_notifier,
  	.get_survey		= b43_op_get_survey,
  	.rfkill_poll		= b43_rfkill_poll,
@@ -99,7 +99,7 @@
  };
  
  /* Hard-reset the chip. Do not call this directly.
-@@ -5177,6 +5217,8 @@ static int b43_one_core_attach(struct b4
+@@ -5208,6 +5248,8 @@ static int b43_one_core_attach(struct b4
  	if (!wldev)
  		goto out;
  
@@ -108,19 +108,19 @@
  	wldev->use_pio = b43_modparam_pio;
  	wldev->dev = dev;
  	wldev->wl = wl;
-@@ -5264,6 +5306,9 @@ static struct b43_wl *b43_wireless_init(
- 		BIT(NL80211_IFTYPE_WDS) |
- 		BIT(NL80211_IFTYPE_ADHOC);
+@@ -5298,6 +5340,9 @@ static struct b43_wl *b43_wireless_init(
+ 
+ 	hw->wiphy->flags |= WIPHY_FLAG_IBSS_RSN;
  
 +	hw->wiphy->available_antennas_rx = 0x3;
 +	hw->wiphy->available_antennas_tx = 0x3;
 +
- 	hw->queues = modparam_qos ? 4 : 1;
+ 	hw->queues = modparam_qos ? B43_QOS_QUEUE_NUM : 1;
  	wl->mac80211_initially_registered_queues = hw->queues;
- 	hw->max_rates = 2;
+ 	wl->hw_registred = false;
 --- a/drivers/net/wireless/b43/b43.h
 +++ b/drivers/net/wireless/b43/b43.h
-@@ -792,6 +792,8 @@ struct b43_wldev {
+@@ -804,6 +804,8 @@ struct b43_wldev {
  	bool hwcrypto_enabled;		/* TRUE, if HW crypto acceleration is enabled. */
  	bool use_pio;			/* TRUE if next init should use PIO */
  	int gpiomask;			/* GPIO LED mask as a module parameter */
diff '--exclude=.svn' -Nur package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch ../openwrt-trunk/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch
--- package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/830-b43-workaround-pcie-bcm4716.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,134 @@
+From 4f214b1ead0af7439921637645cb63f378516175 Mon Sep 17 00:00:00 2001
+From: Hauke Mehrtens <hauke@hauke-m.de>
+Date: Sat, 21 Jan 2012 18:48:38 +0100
+Subject: [PATCH 33/34] b43: add workaround for b43 on pcie bus of bcm4716.
+
+bcm4716 (which includes 4717 & 4718), plus 4706 on PCIe can reorder
+transactions. As a fix, a read after write is performed on certain
+places in the code. Older chips and the newer 5357 family don't require
+this fix.
+This code is based on the brcmsmac driver.
+
+Signed-off-by: Hauke Mehrtens <hauke@hauke-m.de>
+---
+ drivers/net/wireless/b43/b43.h        |   26 ++++++++++++++++++++++++++
+ drivers/net/wireless/b43/bus.h        |   10 ++++++++++
+ drivers/net/wireless/b43/phy_common.c |    6 ++++++
+ drivers/net/wireless/b43/phy_n.c      |   10 +++++-----
+ 4 files changed, 47 insertions(+), 5 deletions(-)
+
+--- a/drivers/net/wireless/b43/b43.h
++++ b/drivers/net/wireless/b43/b43.h
+@@ -1051,6 +1051,32 @@ static inline bool b43_using_pio_transfe
+ 	return dev->__using_pio_transfers;
+ }
+ 
++/*
++ * bcm4716 (which includes 4717 & 4718), plus 4706 on PCIe can reorder
++ * transactions. As a fix, a read after write is performed on certain places
++ * in the code. Older chips and the newer 5357 family don't require this fix.
++ */
++#ifdef CONFIG_BCM47XX_BCMA
++#include <asm/mach-bcm47xx/bcm47xx.h>
++static inline void b43_wflush16(struct b43_wldev *dev, u16 offset, u16 value)
++{
++	if (b43_bus_host_is_pci(dev->dev) &&
++	    bcm47xx_bus_type == BCM47XX_BUS_TYPE_BCMA &&
++	    (bcm47xx_bus.bcma.bus.chipinfo.id == 0x4716 ||
++	     bcm47xx_bus.bcma.bus.chipinfo.id == 0x5300)) {
++		b43_write16(dev, offset, value);
++		b43_read16(dev, offset);
++	} else {
++		b43_write16(dev, offset, value);
++	}
++}
++#else
++static inline void b43_wflush16(struct b43_wldev *dev, u16 offset, u16 value)
++{
++	b43_write16(dev, offset, value);
++}
++#endif
++
+ /* Message printing */
+ __printf(2, 3) void b43info(struct b43_wl *wl, const char *fmt, ...);
+ __printf(2, 3) void b43err(struct b43_wl *wl, const char *fmt, ...);
+--- a/drivers/net/wireless/b43/bus.h
++++ b/drivers/net/wireless/b43/bus.h
+@@ -60,6 +60,16 @@ static inline bool b43_bus_host_is_sdio(
+ 	return (dev->bus_type == B43_BUS_SSB &&
+ 		dev->sdev->bus->bustype == SSB_BUSTYPE_SDIO);
+ }
++static inline bool b43_bus_host_is_pci(struct b43_bus_dev *dev)
++{
++	if (dev->bus_type == B43_BUS_SSB)
++		return (dev->sdev->bus->bustype == SSB_BUSTYPE_PCI);
++#ifdef CONFIG_B43_BCMA
++	if (dev->bus_type == B43_BUS_BCMA)
++		return (dev->bdev->bus->hosttype == BCMA_HOSTTYPE_PCI);
++#endif
++	return false;
++}
+ 
+ struct b43_bus_dev *b43_bus_dev_bcma_init(struct bcma_device *core);
+ struct b43_bus_dev *b43_bus_dev_ssb_init(struct ssb_device *sdev);
+--- a/drivers/net/wireless/b43/phy_common.c
++++ b/drivers/net/wireless/b43/phy_common.c
+@@ -251,6 +251,12 @@ void b43_phy_write(struct b43_wldev *dev
+ {
+ 	assert_mac_suspended(dev);
+ 	dev->phy.ops->phy_write(dev, reg, value);
++#ifdef CONFIG_BCM47XX
++	if (b43_bus_host_is_pci(dev->dev) && reg == 0x72) {
++		b43_read16(dev, B43_MMIO_PHY_VER);
++		return;
++	}
++#endif
+ 	if (++dev->phy.writes_counter == B43_MAX_WRITES_IN_ROW) {
+ 		b43_read16(dev, B43_MMIO_PHY_VER);
+ 		dev->phy.writes_counter = 0;
+--- a/drivers/net/wireless/b43/phy_n.c
++++ b/drivers/net/wireless/b43/phy_n.c
+@@ -4838,14 +4838,14 @@ static inline void check_phyreg(struct b
+ static u16 b43_nphy_op_read(struct b43_wldev *dev, u16 reg)
+ {
+ 	check_phyreg(dev, reg);
+-	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
++	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
+ 	return b43_read16(dev, B43_MMIO_PHY_DATA);
+ }
+ 
+ static void b43_nphy_op_write(struct b43_wldev *dev, u16 reg, u16 value)
+ {
+ 	check_phyreg(dev, reg);
+-	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
++	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
+ 	b43_write16(dev, B43_MMIO_PHY_DATA, value);
+ }
+ 
+@@ -4853,7 +4853,7 @@ static void b43_nphy_op_maskset(struct b
+ 				 u16 set)
+ {
+ 	check_phyreg(dev, reg);
+-	b43_write16(dev, B43_MMIO_PHY_CONTROL, reg);
++	b43_wflush16(dev, B43_MMIO_PHY_CONTROL, reg);
+ 	b43_maskset16(dev, B43_MMIO_PHY_DATA, mask, set);
+ }
+ 
+@@ -4864,7 +4864,7 @@ static u16 b43_nphy_op_radio_read(struct
+ 	/* N-PHY needs 0x100 for read access */
+ 	reg |= 0x100;
+ 
+-	b43_write16(dev, B43_MMIO_RADIO_CONTROL, reg);
++	b43_wflush16(dev, B43_MMIO_RADIO_CONTROL, reg);
+ 	return b43_read16(dev, B43_MMIO_RADIO_DATA_LOW);
+ }
+ 
+@@ -4873,7 +4873,7 @@ static void b43_nphy_op_radio_write(stru
+ 	/* Register 1 is a 32-bit register. */
+ 	B43_WARN_ON(reg == 1);
+ 
+-	b43_write16(dev, B43_MMIO_RADIO_CONTROL, reg);
++	b43_wflush16(dev, B43_MMIO_RADIO_CONTROL, reg);
+ 	b43_write16(dev, B43_MMIO_RADIO_DATA_LOW, value);
+ }
+ 
diff '--exclude=.svn' -Nur package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch ../openwrt-trunk/package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch
--- package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/849-brcmsmac-add-device-found-on-some-SoCs-like-the-bcm4.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,39 @@
+--- a/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+@@ -92,6 +92,7 @@ MODULE_LICENSE("Dual BSD/GPL");
+ 
+ /* recognized BCMA Core IDs */
+ static struct bcma_device_id brcms_coreid_table[] = {
++//	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 17, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 23, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 24, BCMA_ANY_CLASS),
+ 	BCMA_CORETABLE_END
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -734,7 +734,7 @@ static void brcms_c_ucode_bsinit(struct 
+ 	brcms_c_write_mhf(wlc_hw, wlc_hw->band->mhfs);
+ 
+ 	/* do band-specific ucode IHR, SHM, and SCR inits */
+-	if (D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0bsinitvals16);
+ 		else
+@@ -2259,7 +2259,7 @@ static void brcms_ucode_download(struct 
+ 	if (wlc_hw->ucode_loaded)
+ 		return;
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band)) {
+ 			brcms_ucode_write(wlc_hw, ucode->bcm43xx_16_mimo,
+ 					  ucode->bcm43xx_16_mimosz);
+@@ -3221,7 +3221,7 @@ static void brcms_b_coreinit(struct brcm
+ 
+ 	sflags = bcma_aread32(core, BCMA_IOST);
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0initvals16);
+ 		else
diff '--exclude=.svn' -Nur package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch ../openwrt-trunk/package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch
--- package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/850-brcmsmac-add-support-for-BCM43224.patch	2012-08-18 14:47:33.115458002 +0200
@@ -0,0 +1,29 @@
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -4135,6 +4135,7 @@ void brcms_c_wme_setparams(struct brcms_
+ 					  M_EDCF_QINFO +
+ 					  wme_ac2fifo[aci] * M_EDCF_QLEN + i,
+ 					  *shm_entry++);
++		printk("dummy\n");
+ 	}
+ 
+ 	if (suspend) {
+@@ -4537,7 +4538,8 @@ static int brcms_b_attach(struct brcms_c
+ 
+ 	/* check device id(srom, nvram etc.) to set bands */
+ 	if (wlc_hw->deviceid == BCM43224_D11N_ID ||
+-	    wlc_hw->deviceid == BCM43224_D11N_ID_VEN1)
++	    wlc_hw->deviceid == BCM43224_D11N_ID_VEN1 ||
++	    wlc_hw->deviceid == BCM43224_CHIP_ID)
+ 		/* Dualband boards */
+ 		wlc_hw->_nbands = 2;
+ 	else
+@@ -5797,7 +5799,7 @@ static bool brcms_c_chipmatch_pci(struct
+ 		return false;
+ 	}
+ 
+-	if (device == BCM43224_D11N_ID_VEN1)
++	if (device == BCM43224_D11N_ID_VEN1 || device == BCM43224_CHIP_ID)
+ 		return true;
+ 	if ((device == BCM43224_D11N_ID) || (device == BCM43225_D11N2G_ID))
+ 		return true;
diff '--exclude=.svn' -Nur package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch ../openwrt-trunk/package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch
--- package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch	1970-01-01 01:00:00.000000000 +0100
+++ ../openwrt-trunk/package/mac80211/patches/851-brcmsmac-start-adding-support-for-core-rev-28.patch	2012-08-18 14:47:33.125458002 +0200
@@ -0,0 +1,75 @@
+--- a/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/mac80211_if.c
+@@ -95,6 +95,7 @@ static struct bcma_device_id brcms_corei
+ //	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 17, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 23, BCMA_ANY_CLASS),
+ 	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 24, BCMA_ANY_CLASS),
++//	BCMA_CORE(BCMA_MANUF_BCM, BCMA_CORE_80211, 28, BCMA_ANY_CLASS),
+ 	BCMA_CORETABLE_END
+ };
+ MODULE_DEVICE_TABLE(bcma, brcms_coreid_table);
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.c
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.c
+@@ -734,7 +734,7 @@ static void brcms_c_ucode_bsinit(struct 
+ 	brcms_c_write_mhf(wlc_hw, wlc_hw->band->mhfs);
+ 
+ 	/* do band-specific ucode IHR, SHM, and SCR inits */
+-	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23) || D11REV_IS(wlc_hw->corerev, 28)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0bsinitvals16);
+ 		else
+@@ -2259,7 +2259,7 @@ static void brcms_ucode_download(struct 
+ 	if (wlc_hw->ucode_loaded)
+ 		return;
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23) || D11REV_IS(wlc_hw->corerev, 28)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band)) {
+ 			brcms_ucode_write(wlc_hw, ucode->bcm43xx_16_mimo,
+ 					  ucode->bcm43xx_16_mimosz);
+@@ -3221,7 +3221,7 @@ static void brcms_b_coreinit(struct brcm
+ 
+ 	sflags = bcma_aread32(core, BCMA_IOST);
+ 
+-	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23)) {
++	if (D11REV_IS(wlc_hw->corerev, 17) || D11REV_IS(wlc_hw->corerev, 23) || D11REV_IS(wlc_hw->corerev, 28)) {
+ 		if (BRCMS_ISNPHY(wlc_hw->band))
+ 			brcms_c_write_inits(wlc_hw, ucode->d11n0initvals16);
+ 		else
+@@ -5818,6 +5818,8 @@ static bool brcms_c_chipmatch_soc(struct
+ 
+ 	if (chipinfo->id == BCMA_CHIP_ID_BCM4716)
+ 		return true;
++	if (chipinfo->id == BCMA_CHIP_ID_BCM5357)
++		return true;
+ 
+ 	pr_err("unknown chip id %04x\n", chipinfo->id);
+ 	return false;
+--- a/drivers/net/wireless/brcm80211/brcmsmac/main.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/main.h
+@@ -65,7 +65,7 @@
+ #define	SW_TIMER_MAC_STAT_UPD		30	/* periodic MAC stats update */
+ 
+ /* max # supported core revisions (0 .. MAXCOREREV - 1) */
+-#define	MAXCOREREV		28
++#define	MAXCOREREV		29
+ 
+ /* Double check that unsupported cores are not enabled */
+ #if CONF_MSK(D11CONF, 0x4f) || CONF_GE(D11CONF, MAXCOREREV)
+--- a/drivers/net/wireless/brcm80211/brcmsmac/types.h
++++ b/drivers/net/wireless/brcm80211/brcmsmac/types.h
+@@ -93,11 +93,11 @@
+ #define BOARD_GPIO_13		0x2000
+ 
+ /* **** Core type/rev defaults **** */
+-#define D11CONF		0x0fffffb0	/* Supported  D11 revs: 4, 5, 7-27
++#define D11CONF		0x1fffffb0	/* Supported  D11 revs: 4, 5, 7-27
+ 					 * also need to update wlc.h MAXCOREREV
+ 					 */
+ 
+-#define NCONF		0x000001ff	/* Supported nphy revs:
++#define NCONF		0x000002ff	/* Supported nphy revs:
+ 					 *      0       4321a0
+ 					 *      1       4321a1
+ 					 *      2       4321b0/b1/c0/c1
diff '--exclude=.svn' -Nur package/mac80211/patches/900-bash-location.patch ../openwrt-trunk/package/mac80211/patches/900-bash-location.patch
--- package/mac80211/patches/900-bash-location.patch	2012-08-17 15:40:46.491971001 +0200
+++ ../openwrt-trunk/package/mac80211/patches/900-bash-location.patch	1970-01-01 01:00:00.000000000 +0100
@@ -1,61 +0,0 @@
---- a/scripts/admin-clean.sh
-+++ b/scripts/admin-clean.sh
-@@ -1,4 +1,4 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- if [ -d net ] ; then
- 	make clean
- fi
---- a/scripts/admin-refresh.sh
-+++ b/scripts/admin-refresh.sh
-@@ -1,3 +1,3 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- ./scripts/admin-clean.sh $@
- ./scripts/admin-update.sh $@
---- a/scripts/admin-update.sh
-+++ b/scripts/admin-update.sh
-@@ -1,4 +1,4 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- # 
- # Copyright 2007, 2008, 2010	Luis R. Rodriguez <mcgrof@winlab.rutgers.edu>
- #
---- a/scripts/check_config.sh
-+++ b/scripts/check_config.sh
-@@ -1,4 +1,4 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- # This script checks the compat-wireless configuration file and if changes were made
- # regenerates the compat_autoconf header.
- 
---- a/scripts/driver-select
-+++ b/scripts/driver-select
-@@ -1,4 +1,4 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- # Copyright 2009        Luis R. Rodriguez <mcgrof@gmail.com>
- #
- # This script allows you to select your compat-wireless driver and
---- a/scripts/gen-compat-autoconf.sh
-+++ b/scripts/gen-compat-autoconf.sh
-@@ -1,4 +1,4 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- # 
- # Copyright 2007	Luis R. Rodriguez <mcgrof@winlab.rutgers.edu>
- #
---- a/scripts/gen-stable-release.sh
-+++ b/scripts/gen-stable-release.sh
-@@ -1,4 +1,4 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- # Copyright 2009  Luis R. Rodriguez <mcgrof@gmail.com>
- #
- # You can use this to make stable compat-wireless releases
---- a/scripts/skip-colors
-+++ b/scripts/skip-colors
-@@ -1,2 +1,2 @@
--#!/bin/bash
-+#!/usr/bin/env bash
- perl -pe 's|(\e)\[(\d+)(;*)(\d*)(\w)||g'
