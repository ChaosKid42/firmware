diff -Nru -x .svn package/iwinfo/Makefile package/iwinfo/Makefile
--- package/iwinfo/Makefile	2012-02-25 18:41:41.316147398 +0100
+++ package/iwinfo/Makefile	2012-02-25 18:58:52.394896667 +0100
@@ -7,9 +7,15 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=libiwinfo
-PKG_RELEASE:=18.2
+PKG_RELEASE:=31
 
 PKG_BUILD_DIR := $(BUILD_DIR)/$(PKG_NAME)
+PKG_CONFIG_DEPENDS := \
+	CONFIG_PACKAGE_kmod-brcm-wl \
+	CONFIG_PACKAGE_kmod-brcm-wl-mini \
+	CONFIG_PACKAGE_kmod-brcm-wl-mimo \
+	CONFIG_PACKAGE_kmod-madwifi \
+	CONFIG_PACKAGE_kmod-mac80211
 
 include $(INCLUDE_DIR)/package.mk
 
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/api/broadcom.h package/iwinfo/src/include/iwinfo/api/broadcom.h
--- package/iwinfo/src/include/iwinfo/api/broadcom.h	2011-12-12 14:23:17.799312590 +0100
+++ package/iwinfo/src/include/iwinfo/api/broadcom.h	2012-02-25 18:58:52.251145626 +0100
@@ -64,6 +64,30 @@
 	uint16_t				foo;
 } wl_sta_rssi_t;
 
+#define WL_NUMRATES     255 /* max # of rates in a rateset */
+typedef struct wl_rateset {
+    uint32_t  				count;          /* # rates in this set */
+    uint8_t   				rates[WL_NUMRATES]; /* rates in 500kbps units w/hi bit set if basic */
+} wl_rateset_t;
+
+typedef struct wl_sta_info {
+    uint16_t				ver;        /* version of this struct */
+    uint16_t				len;        /* length in bytes of this structure */
+    uint16_t				cap;        /* sta's advertised capabilities */
+    uint32_t				flags;      /* flags defined below */
+    uint32_t				idle;       /* time since data pkt rx'd from sta */
+    unsigned char			ea[6];      /* Station address */
+    wl_rateset_t			rateset;    /* rateset in use */
+    uint32_t				in;   		/* seconds elapsed since associated */
+    uint32_t				listen_interval_inms; /* Min Listen interval in ms for this STA */
+    uint32_t				tx_pkts;    /* # of packets transmitted */
+    uint32_t				tx_failures;    /* # of packets failed */
+    uint32_t				rx_ucast_pkts;  /* # of unicast packets received */
+    uint32_t				rx_mcast_pkts;  /* # of multicast packets received */
+    uint32_t				tx_rate;    /* Rate of last successful tx frame */
+    uint32_t				rx_rate;    /* Rate of last successful rx frame */
+} wl_sta_info_t;
+
 typedef struct wlc_ssid {
 	uint32_t				ssid_len;
 	unsigned char			ssid[32];
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/api/madwifi.h package/iwinfo/src/include/iwinfo/api/madwifi.h
--- package/iwinfo/src/include/iwinfo/api/madwifi.h	2011-12-12 14:23:17.798312070 +0100
+++ package/iwinfo/src/include/iwinfo/api/madwifi.h	2012-02-25 18:58:52.250145746 +0100
@@ -22,8 +22,10 @@
 #define _MADWIFI_H
 
 /* ieee80211.h */
-#define	IEEE80211_ADDR_LEN		6
-#define	IEEE80211_RATE_VAL		0x7f
+#define	IEEE80211_ADDR_LEN			6
+#define	IEEE80211_RATE_VAL			0x7f
+#define	IEEE80211_SEQ_SEQ_MASK		0xfff0
+#define	IEEE80211_SEQ_SEQ_SHIFT		4
 
 
 /* ieee80211_crypto.h */
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/api/nl80211.h package/iwinfo/src/include/iwinfo/api/nl80211.h
--- package/iwinfo/src/include/iwinfo/api/nl80211.h	2011-12-12 14:23:17.799312590 +0100
+++ package/iwinfo/src/include/iwinfo/api/nl80211.h	2012-02-25 18:58:52.251145626 +0100
@@ -6,7 +6,7 @@
  * Copyright 2006-2010 Johannes Berg <johannes@sipsolutions.net>
  * Copyright 2008 Michael Wu <flamingice@sourmilk.net>
  * Copyright 2008 Luis Carlos Cobo <luisca@cozybit.com>
- * Copyright 2008 Michael Buesch <mb@bu3sch.de>
+ * Copyright 2008 Michael Buesch <m@bues.ch>
  * Copyright 2008, 2009 Luis R. Rodriguez <lrodriguez@atheros.com>
  * Copyright 2008 Jouni Malinen <jouni.malinen@atheros.com>
  * Copyright 2008 Colin McCabe <colin@cozybit.com>
@@ -77,6 +77,39 @@
  */
 
 /**
+ * DOC: Virtual interface / concurrency capabilities
+ *
+ * Some devices are able to operate with virtual MACs, they can have
+ * more than one virtual interface. The capability handling for this
+ * is a bit complex though, as there may be a number of restrictions
+ * on the types of concurrency that are supported.
+ *
+ * To start with, each device supports the interface types listed in
+ * the %NL80211_ATTR_SUPPORTED_IFTYPES attribute, but by listing the
+ * types there no concurrency is implied.
+ *
+ * Once concurrency is desired, more attributes must be observed:
+ * To start with, since some interface types are purely managed in
+ * software, like the AP-VLAN type in mac80211 for example, there's
+ * an additional list of these, they can be added at any time and
+ * are only restricted by some semantic restrictions (e.g. AP-VLAN
+ * cannot be added without a corresponding AP interface). This list
+ * is exported in the %NL80211_ATTR_SOFTWARE_IFTYPES attribute.
+ *
+ * Further, the list of supported combinations is exported. This is
+ * in the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute. Basically,
+ * it exports a list of "groups", and at any point in time the
+ * interfaces that are currently active must fall into any one of
+ * the advertised groups. Within each group, there are restrictions
+ * on the number of interfaces of different types that are supported
+ * and also the number of different channels, along with potentially
+ * some other restrictions. See &enum nl80211_if_combination_attrs.
+ *
+ * All together, these attributes define the concurrency of virtual
+ * interfaces that a given device supports.
+ */
+
+/**
  * enum nl80211_commands - supported nl80211 commands
  *
  * @NL80211_CMD_UNSPEC: unspecified command to catch errors
@@ -128,6 +161,13 @@
  * @NL80211_CMD_SET_BEACON: set the beacon on an access point interface
  *	using the %NL80211_ATTR_BEACON_INTERVAL, %NL80211_ATTR_DTIM_PERIOD,
  *	%NL80211_ATTR_BEACON_HEAD and %NL80211_ATTR_BEACON_TAIL attributes.
+ *	Following attributes are provided for drivers that generate full Beacon
+ *	and Probe Response frames internally: %NL80211_ATTR_SSID,
+ *	%NL80211_ATTR_HIDDEN_SSID, %NL80211_ATTR_CIPHERS_PAIRWISE,
+ *	%NL80211_ATTR_CIPHER_GROUP, %NL80211_ATTR_WPA_VERSIONS,
+ *	%NL80211_ATTR_AKM_SUITES, %NL80211_ATTR_PRIVACY,
+ *	%NL80211_ATTR_AUTH_TYPE, %NL80211_ATTR_IE, %NL80211_ATTR_IE_PROBE_RESP,
+ *	%NL80211_ATTR_IE_ASSOC_RESP.
  * @NL80211_CMD_NEW_BEACON: add a new beacon to an access point interface,
  *	parameters are like for %NL80211_CMD_SET_BEACON.
  * @NL80211_CMD_DEL_BEACON: remove the beacon, stop sending it
@@ -148,6 +188,10 @@
  * @NL80211_CMD_SET_MPATH:  Set mesh path attributes for mesh path to
  * 	destination %NL80211_ATTR_MAC on the interface identified by
  * 	%NL80211_ATTR_IFINDEX.
+ * @NL80211_CMD_NEW_MPATH: Create a new mesh path for the destination given by
+ *	%NL80211_ATTR_MAC via %NL80211_ATTR_MPATH_NEXT_HOP.
+ * @NL80211_CMD_DEL_MPATH: Delete a mesh path to the destination given by
+ *	%NL80211_ATTR_MAC.
  * @NL80211_CMD_NEW_PATH: Add a mesh path with given attributes to the
  *	the interface identified by %NL80211_ATTR_IFINDEX.
  * @NL80211_CMD_DEL_PATH: Remove a mesh path identified by %NL80211_ATTR_MAC
@@ -172,10 +216,10 @@
  * 	to the specified ISO/IEC 3166-1 alpha2 country code. The core will
  * 	store this as a valid request and then query userspace for it.
  *
- * @NL80211_CMD_GET_MESH_PARAMS: Get mesh networking properties for the
+ * @NL80211_CMD_GET_MESH_CONFIG: Get mesh networking properties for the
  *	interface identified by %NL80211_ATTR_IFINDEX
  *
- * @NL80211_CMD_SET_MESH_PARAMS: Set mesh networking properties for the
+ * @NL80211_CMD_SET_MESH_CONFIG: Set mesh networking properties for the
  *      interface identified by %NL80211_ATTR_IFINDEX
  *
  * @NL80211_CMD_SET_MGMT_EXTRA_IE: Set extra IEs for management frames. The
@@ -194,11 +238,36 @@
  *
  * @NL80211_CMD_GET_SCAN: get scan results
  * @NL80211_CMD_TRIGGER_SCAN: trigger a new scan with the given parameters
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	probe requests at CCK rate or not.
  * @NL80211_CMD_NEW_SCAN_RESULTS: scan notification (as a reply to
  *	NL80211_CMD_GET_SCAN and on the "scan" multicast group)
  * @NL80211_CMD_SCAN_ABORTED: scan was aborted, for unspecified reasons,
  *	partial scan results may be available
  *
+ * @NL80211_CMD_START_SCHED_SCAN: start a scheduled scan at certain
+ *	intervals, as specified by %NL80211_ATTR_SCHED_SCAN_INTERVAL.
+ *	Like with normal scans, if SSIDs (%NL80211_ATTR_SCAN_SSIDS)
+ *	are passed, they are used in the probe requests.  For
+ *	broadcast, a broadcast SSID must be passed (ie. an empty
+ *	string).  If no SSID is passed, no probe requests are sent and
+ *	a passive scan is performed.  %NL80211_ATTR_SCAN_FREQUENCIES,
+ *	if passed, define which channels should be scanned; if not
+ *	passed, all channels allowed for the current regulatory domain
+ *	are used.  Extra IEs can also be passed from the userspace by
+ *	using the %NL80211_ATTR_IE attribute.
+ * @NL80211_CMD_STOP_SCHED_SCAN: stop a scheduled scan.  Returns -ENOENT
+ *	if scheduled scan is not running.
+ * @NL80211_CMD_SCHED_SCAN_RESULTS: indicates that there are scheduled scan
+ *	results available.
+ * @NL80211_CMD_SCHED_SCAN_STOPPED: indicates that the scheduled scan has
+ *	stopped.  The driver may issue this event at any time during a
+ *	scheduled scan.  One reason for stopping the scan is if the hardware
+ *	does not support starting an association or a normal scan while running
+ *	a scheduled scan.  This event is also sent when the
+ *	%NL80211_CMD_STOP_SCHED_SCAN command is received or when the interface
+ *	is brought down while a scheduled scan was running.
+ *
  * @NL80211_CMD_GET_SURVEY: get survey resuls, e.g. channel occupation
  *      or noise level
  * @NL80211_CMD_NEW_SURVEY_RESULTS: survey data notification (as a reply to
@@ -358,11 +427,18 @@
  *	user space application). %NL80211_ATTR_FRAME is used to specify the
  *	frame contents (including header). %NL80211_ATTR_WIPHY_FREQ (and
  *	optionally %NL80211_ATTR_WIPHY_CHANNEL_TYPE) is used to indicate on
- *	which channel the frame is to be transmitted or was received. This
- *	channel has to be the current channel (remain-on-channel or the
- *	operational channel). When called, this operation returns a cookie
- *	(%NL80211_ATTR_COOKIE) that will be included with the TX status event
- *	pertaining to the TX request.
+ *	which channel the frame is to be transmitted or was received. If this
+ *	channel is not the current channel (remain-on-channel or the
+ *	operational channel) the device will switch to the given channel and
+ *	transmit the frame, optionally waiting for a response for the time
+ *	specified using %NL80211_ATTR_DURATION. When called, this operation
+ *	returns a cookie (%NL80211_ATTR_COOKIE) that will be included with the
+ *	TX status event pertaining to the TX request.
+ *	%NL80211_ATTR_TX_NO_CCK_RATE is used to decide whether to send the
+ *	management frames at CCK rate or not in 2GHz band.
+ * @NL80211_CMD_FRAME_WAIT_CANCEL: When an off-channel TX was requested, this
+ *	command may be used with the corresponding cookie to cancel the wait
+ *	time if it is known that it is no longer necessary.
  * @NL80211_CMD_ACTION: Alias for @NL80211_CMD_FRAME for backward compatibility.
  * @NL80211_CMD_FRAME_TX_STATUS: Report TX status of a management frame
  *	transmitted with %NL80211_CMD_FRAME. %NL80211_ATTR_COOKIE identifies
@@ -389,11 +465,87 @@
  *
  * @NL80211_CMD_SET_WDS_PEER: Set the MAC address of the peer on a WDS interface.
  *
+ * @NL80211_CMD_JOIN_MESH: Join a mesh. The mesh ID must be given, and initial
+ *	mesh config parameters may be given.
+ * @NL80211_CMD_LEAVE_MESH: Leave the mesh network -- no special arguments, the
+ *	network is determined by the network interface.
+ *
+ * @NL80211_CMD_UNPROT_DEAUTHENTICATE: Unprotected deauthentication frame
+ *	notification. This event is used to indicate that an unprotected
+ *	deauthentication frame was dropped when MFP is in use.
+ * @NL80211_CMD_UNPROT_DISASSOCIATE: Unprotected disassociation frame
+ *	notification. This event is used to indicate that an unprotected
+ *	disassociation frame was dropped when MFP is in use.
+ *
+ * @NL80211_CMD_NEW_PEER_CANDIDATE: Notification on the reception of a
+ *      beacon or probe response from a compatible mesh peer.  This is only
+ *      sent while no station information (sta_info) exists for the new peer
+ *      candidate and when @NL80211_MESH_SETUP_USERSPACE_AUTH is set.  On
+ *      reception of this notification, userspace may decide to create a new
+ *      station (@NL80211_CMD_NEW_STATION).  To stop this notification from
+ *      reoccurring, the userspace authentication daemon may want to create the
+ *      new station with the AUTHENTICATED flag unset and maybe change it later
+ *      depending on the authentication result.
+ *
+ * @NL80211_CMD_GET_WOWLAN: get Wake-on-Wireless-LAN (WoWLAN) settings.
+ * @NL80211_CMD_SET_WOWLAN: set Wake-on-Wireless-LAN (WoWLAN) settings.
+ *	Since wireless is more complex than wired ethernet, it supports
+ *	various triggers. These triggers can be configured through this
+ *	command with the %NL80211_ATTR_WOWLAN_TRIGGERS attribute. For
+ *	more background information, see
+ *	http://wireless.kernel.org/en/users/Documentation/WoWLAN.
+ *
+ * @NL80211_CMD_SET_REKEY_OFFLOAD: This command is used give the driver
+ *	the necessary information for supporting GTK rekey offload. This
+ *	feature is typically used during WoWLAN. The configuration data
+ *	is contained in %NL80211_ATTR_REKEY_DATA (which is nested and
+ *	contains the data in sub-attributes). After rekeying happened,
+ *	this command may also be sent by the driver as an MLME event to
+ *	inform userspace of the new replay counter.
+ *
+ * @NL80211_CMD_PMKSA_CANDIDATE: This is used as an event to inform userspace
+ *	of PMKSA caching dandidates.
+ *
+ * @NL80211_CMD_TDLS_OPER: Perform a high-level TDLS command (e.g. link setup).
+ * @NL80211_CMD_TDLS_MGMT: Send a TDLS management frame.
+ *
+ * @NL80211_CMD_UNEXPECTED_FRAME: Used by an application controlling an AP
+ *	(or GO) interface (i.e. hostapd) to ask for unexpected frames to
+ *	implement sending deauth to stations that send unexpected class 3
+ *	frames. Also used as the event sent by the kernel when such a frame
+ *	is received.
+ *	For the event, the %NL80211_ATTR_MAC attribute carries the TA and
+ *	other attributes like the interface index are present.
+ *	If used as the command it must have an interface index and you can
+ *	only unsubscribe from the event by closing the socket. Subscription
+ *	is also for %NL80211_CMD_UNEXPECTED_4ADDR_FRAME events.
+ *
+ * @NL80211_CMD_UNEXPECTED_4ADDR_FRAME: Sent as an event indicating that the
+ *	associated station identified by %NL80211_ATTR_MAC sent a 4addr frame
+ *	and wasn't already in a 4-addr VLAN. The event will be sent similarly
+ *	to the %NL80211_CMD_UNEXPECTED_FRAME event, to the same listener.
+ *
+ * @NL80211_CMD_PROBE_CLIENT: Probe an associated station on an AP interface
+ *	by sending a null data frame to it and reporting when the frame is
+ *	acknowleged. This is used to allow timing out inactive clients. Uses
+ *	%NL80211_ATTR_IFINDEX and %NL80211_ATTR_MAC. The command returns a
+ *	direct reply with an %NL80211_ATTR_COOKIE that is later used to match
+ *	up the event with the request. The event includes the same data and
+ *	has %NL80211_ATTR_ACK set if the frame was ACKed.
+ *
+ * @NL80211_CMD_REGISTER_BEACONS: Register this socket to receive beacons from
+ *	other BSSes when any interfaces are in AP mode. This helps implement
+ *	OLBC handling in hostapd. Beacons are reported in %NL80211_CMD_FRAME
+ *	messages. Note that per PHY only one application may register.
+ *
+ * @NL80211_CMD_SET_NOACK_MAP: sets a bitmap for the individual TIDs whether
+ *      No Acknowledgement Policy should be applied.
+ *
  * @NL80211_CMD_MAX: highest used command number
  * @__NL80211_CMD_AFTER_LAST: internal use
  */
 enum nl80211_commands {
-/* don't change the order or add anything inbetween, this is ABI! */
+/* don't change the order or add anything between, this is ABI! */
 	NL80211_CMD_UNSPEC,
 
 	NL80211_CMD_GET_WIPHY,		/* can dump */
@@ -431,8 +583,8 @@
 	NL80211_CMD_SET_REG,
 	NL80211_CMD_REQ_SET_REG,
 
-	NL80211_CMD_GET_MESH_PARAMS,
-	NL80211_CMD_SET_MESH_PARAMS,
+	NL80211_CMD_GET_MESH_CONFIG,
+	NL80211_CMD_SET_MESH_CONFIG,
 
 	NL80211_CMD_SET_MGMT_EXTRA_IE /* reserved; not used */,
 
@@ -493,6 +645,41 @@
 	NL80211_CMD_SET_CHANNEL,
 	NL80211_CMD_SET_WDS_PEER,
 
+	NL80211_CMD_FRAME_WAIT_CANCEL,
+
+	NL80211_CMD_JOIN_MESH,
+	NL80211_CMD_LEAVE_MESH,
+
+	NL80211_CMD_UNPROT_DEAUTHENTICATE,
+	NL80211_CMD_UNPROT_DISASSOCIATE,
+
+	NL80211_CMD_NEW_PEER_CANDIDATE,
+
+	NL80211_CMD_GET_WOWLAN,
+	NL80211_CMD_SET_WOWLAN,
+
+	NL80211_CMD_START_SCHED_SCAN,
+	NL80211_CMD_STOP_SCHED_SCAN,
+	NL80211_CMD_SCHED_SCAN_RESULTS,
+	NL80211_CMD_SCHED_SCAN_STOPPED,
+
+	NL80211_CMD_SET_REKEY_OFFLOAD,
+
+	NL80211_CMD_PMKSA_CANDIDATE,
+
+	NL80211_CMD_TDLS_OPER,
+	NL80211_CMD_TDLS_MGMT,
+
+	NL80211_CMD_UNEXPECTED_FRAME,
+
+	NL80211_CMD_PROBE_CLIENT,
+
+	NL80211_CMD_REGISTER_BEACONS,
+
+	NL80211_CMD_UNEXPECTED_4ADDR_FRAME,
+
+	NL80211_CMD_SET_NOACK_MAP,
+
 	/* add new commands above here */
 
 	/* used to define NL80211_CMD_MAX below */
@@ -513,6 +700,13 @@
 #define NL80211_CMD_DISASSOCIATE NL80211_CMD_DISASSOCIATE
 #define NL80211_CMD_REG_BEACON_HINT NL80211_CMD_REG_BEACON_HINT
 
+#define NL80211_ATTR_FEATURE_FLAGS NL80211_ATTR_FEATURE_FLAGS
+
+/* source-level API compatibility */
+#define NL80211_CMD_GET_MESH_PARAMS NL80211_CMD_GET_MESH_CONFIG
+#define NL80211_CMD_SET_MESH_PARAMS NL80211_CMD_SET_MESH_CONFIG
+#define NL80211_MESH_SETUP_VENDOR_PATH_SEL_IE NL80211_MESH_SETUP_IE
+
 /**
  * enum nl80211_attrs - nl80211 netlink attributes
  *
@@ -583,7 +777,7 @@
  *	consisting of a nested array.
  *
  * @NL80211_ATTR_MESH_ID: mesh id (1-32 bytes).
- * @NL80211_ATTR_PLINK_ACTION: action to perform on the mesh peer link.
+ * @NL80211_ATTR_STA_PLINK_ACTION: action to perform on the mesh peer link.
  * @NL80211_ATTR_MPATH_NEXT_HOP: MAC address of the next hop for a mesh path.
  * @NL80211_ATTR_MPATH_INFO: information about a mesh_path, part of mesh path
  * 	info given for %NL80211_CMD_GET_MPATH, nested attribute described at
@@ -628,8 +822,14 @@
  *
  * @NL80211_ATTR_MAX_NUM_SCAN_SSIDS: number of SSIDs you can scan with
  *	a single scan request, a wiphy attribute.
+ * @NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS: number of SSIDs you can
+ *	scan with a single scheduled scan request, a wiphy attribute.
  * @NL80211_ATTR_MAX_SCAN_IE_LEN: maximum length of information elements
  *	that can be added to a scan request
+ * @NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN: maximum length of information
+ *	elements that can be added to a scheduled scan request
+ * @NL80211_ATTR_MAX_MATCH_SETS: maximum number of sets that can be
+ *	used with @NL80211_ATTR_SCHED_SCAN_MATCH, a wiphy attribute.
  *
  * @NL80211_ATTR_SCAN_FREQUENCIES: nested attribute with frequencies (in MHz)
  * @NL80211_ATTR_SCAN_SSIDS: nested attribute with SSIDs, leave out for passive
@@ -710,18 +910,20 @@
  * @NL80211_ATTR_STATUS_CODE: StatusCode for the %NL80211_CMD_CONNECT
  *	event (u16)
  * @NL80211_ATTR_PRIVACY: Flag attribute, used with connect(), indicating
- *	that protected APs should be used.
+ *	that protected APs should be used. This is also used with NEW_BEACON to
+ *	indicate that the BSS is to use protection.
  *
- * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT and ASSOCIATE to
- *	indicate which unicast key ciphers will be used with the connection
+ * @NL80211_ATTR_CIPHERS_PAIRWISE: Used with CONNECT, ASSOCIATE, and NEW_BEACON
+ *	to indicate which unicast key ciphers will be used with the connection
  *	(an array of u32).
- * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT and ASSOCIATE to indicate
- *	which group key cipher will be used with the connection (a u32).
- * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT and ASSOCIATE to indicate
- *	which WPA version(s) the AP we want to associate with is using
+ * @NL80211_ATTR_CIPHER_GROUP: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which group key cipher will be used with the connection (a
+ *	u32).
+ * @NL80211_ATTR_WPA_VERSIONS: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which WPA version(s) the AP we want to associate with is using
  *	(a u32 with flags from &enum nl80211_wpa_versions).
- * @NL80211_ATTR_AKM_SUITES: Used with CONNECT and ASSOCIATE to indicate
- *	which key management algorithm(s) to use (an array of u32).
+ * @NL80211_ATTR_AKM_SUITES: Used with CONNECT, ASSOCIATE, and NEW_BEACON to
+ *	indicate which key management algorithm(s) to use (an array of u32).
  *
  * @NL80211_ATTR_REQ_IE: (Re)association request information elements as
  *	sent out by the card, for ROAM and successful CONNECT events.
@@ -758,6 +960,9 @@
  *	cache, a wiphy attribute.
  *
  * @NL80211_ATTR_DURATION: Duration of an operation in milliseconds, u32.
+ * @NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION: Device attribute that
+ *	specifies the maximum duration that can be requested with the
+ *	remain-on-channel operation, in milliseconds, u32.
  *
  * @NL80211_ATTR_COOKIE: Generic 64-bit cookie to identify objects.
  *
@@ -804,13 +1009,195 @@
  * @NL80211_ATTR_SUPPORT_IBSS_RSN: The device supports IBSS RSN, which mostly
  *	means support for per-station GTKs.
  *
+ * @NL80211_ATTR_WIPHY_ANTENNA_TX: Bitmap of allowed antennas for transmitting.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for transmitting. If an antenna is not selected in this
+ *	bitmap the hardware is not allowed to transmit on this antenna.
+ *
+ *	Each bit represents one antenna, starting with antenna 1 at the first
+ *	bit. Depending on which antennas are selected in the bitmap, 802.11n
+ *	drivers can derive which chainmasks to use (if all antennas belonging to
+ *	a particular chain are disabled this chain should be disabled) and if
+ *	a chain has diversity antennas wether diversity should be used or not.
+ *	HT capabilities (STBC, TX Beamforming, Antenna selection) can be
+ *	derived from the available chains after applying the antenna mask.
+ *	Non-802.11n drivers can derive wether to use diversity or not.
+ *	Drivers may reject configurations or RX/TX mask combinations they cannot
+ *	support by returning -EINVAL.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_RX: Bitmap of allowed antennas for receiving.
+ *	This can be used to mask out antennas which are not attached or should
+ *	not be used for receiving. If an antenna is not selected in this bitmap
+ *	the hardware should not be configured to receive on this antenna.
+ *	For a more detailed description see @NL80211_ATTR_WIPHY_ANTENNA_TX.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX: Bitmap of antennas which are available
+ *	for configuration as TX antennas via the above parameters.
+ *
+ * @NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX: Bitmap of antennas which are available
+ *	for configuration as RX antennas via the above parameters.
+ *
  * @NL80211_ATTR_MCAST_RATE: Multicast tx rate (in 100 kbps) for IBSS
  *
+ * @NL80211_ATTR_OFFCHANNEL_TX_OK: For management frame TX, the frame may be
+ *	transmitted on another channel when the channel given doesn't match
+ *	the current channel. If the current channel doesn't match and this
+ *	flag isn't set, the frame will be rejected. This is also used as an
+ *	nl80211 capability flag.
+ *
+ * @NL80211_ATTR_BSS_HTOPMODE: HT operation mode (u16)
+ *
+ * @NL80211_ATTR_KEY_DEFAULT_TYPES: A nested attribute containing flags
+ *	attributes, specifying what a key should be set as default as.
+ *	See &enum nl80211_key_default_types.
+ *
+ * @NL80211_ATTR_MESH_SETUP: Optional mesh setup parameters.  These cannot be
+ *	changed once the mesh is active.
+ * @NL80211_ATTR_MESH_CONFIG: Mesh configuration parameters, a nested attribute
+ *	containing attributes from &enum nl80211_meshconf_params.
+ * @NL80211_ATTR_SUPPORT_MESH_AUTH: Currently, this means the underlying driver
+ *	allows auth frames in a mesh to be passed to userspace for processing via
+ *	the @NL80211_MESH_SETUP_USERSPACE_AUTH flag.
+ * @NL80211_ATTR_STA_PLINK_STATE: The state of a mesh peer link as
+ *	defined in &enum nl80211_plink_state. Used when userspace is
+ *	driving the peer link management state machine.
+ *	@NL80211_MESH_SETUP_USERSPACE_AMPE must be enabled.
+ *
+ * @NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED: indicates, as part of the wiphy
+ *	capabilities, the supported WoWLAN triggers
+ * @NL80211_ATTR_WOWLAN_TRIGGERS: used by %NL80211_CMD_SET_WOWLAN to
+ *	indicate which WoW triggers should be enabled. This is also
+ *	used by %NL80211_CMD_GET_WOWLAN to get the currently enabled WoWLAN
+ *	triggers.
+
+ * @NL80211_ATTR_SCHED_SCAN_INTERVAL: Interval between scheduled scan
+ *	cycles, in msecs.
+
+ * @NL80211_ATTR_SCHED_SCAN_MATCH: Nested attribute with one or more
+ *	sets of attributes to match during scheduled scans.  Only BSSs
+ *	that match any of the sets will be reported.  These are
+ *	pass-thru filter rules.
+ *	For a match to succeed, the BSS must match all attributes of a
+ *	set.  Since not every hardware supports matching all types of
+ *	attributes, there is no guarantee that the reported BSSs are
+ *	fully complying with the match sets and userspace needs to be
+ *	able to ignore them by itself.
+ *	Thus, the implementation is somewhat hardware-dependent, but
+ *	this is only an optimization and the userspace application
+ *	needs to handle all the non-filtered results anyway.
+ *	If the match attributes don't make sense when combined with
+ *	the values passed in @NL80211_ATTR_SCAN_SSIDS (eg. if an SSID
+ *	is included in the probe request, but the match attributes
+ *	will never let it go through), -EINVAL may be returned.
+ *	If ommited, no filtering is done.
+ *
+ * @NL80211_ATTR_INTERFACE_COMBINATIONS: Nested attribute listing the supported
+ *	interface combinations. In each nested item, it contains attributes
+ *	defined in &enum nl80211_if_combination_attrs.
+ * @NL80211_ATTR_SOFTWARE_IFTYPES: Nested attribute (just like
+ *	%NL80211_ATTR_SUPPORTED_IFTYPES) containing the interface types that
+ *	are managed in software: interfaces of these types aren't subject to
+ *	any restrictions in their number or combinations.
+ *
+ * @%NL80211_ATTR_REKEY_DATA: nested attribute containing the information
+ *	necessary for GTK rekeying in the device, see &enum nl80211_rekey_data.
+ *
+ * @NL80211_ATTR_SCAN_SUPP_RATES: rates per to be advertised as supported in scan,
+ *	nested array attribute containing an entry for each band, with the entry
+ *	being a list of supported rates as defined by IEEE 802.11 7.3.2.2 but
+ *	without the length restriction (at most %NL80211_MAX_SUPP_RATES).
+ *
+ * @NL80211_ATTR_HIDDEN_SSID: indicates whether SSID is to be hidden from Beacon
+ *	and Probe Response (when response to wildcard Probe Request); see
+ *	&enum nl80211_hidden_ssid, represented as a u32
+ *
+ * @NL80211_ATTR_IE_PROBE_RESP: Information element(s) for Probe Response frame.
+ *	This is used with %NL80211_CMD_NEW_BEACON and %NL80211_CMD_SET_BEACON to
+ *	provide extra IEs (e.g., WPS/P2P IE) into Probe Response frames when the
+ *	driver (or firmware) replies to Probe Request frames.
+ * @NL80211_ATTR_IE_ASSOC_RESP: Information element(s) for (Re)Association
+ *	Response frames. This is used with %NL80211_CMD_NEW_BEACON and
+ *	%NL80211_CMD_SET_BEACON to provide extra IEs (e.g., WPS/P2P IE) into
+ *	(Re)Association Response frames when the driver (or firmware) replies to
+ *	(Re)Association Request frames.
+ *
+ * @NL80211_ATTR_STA_WME: Nested attribute containing the wme configuration
+ *	of the station, see &enum nl80211_sta_wme_attr.
+ * @NL80211_ATTR_SUPPORT_AP_UAPSD: the device supports uapsd when working
+ *	as AP.
+ *
+ * @NL80211_ATTR_ROAM_SUPPORT: Indicates whether the firmware is capable of
+ *	roaming to another AP in the same ESS if the signal lever is low.
+ *
+ * @NL80211_ATTR_PMKSA_CANDIDATE: Nested attribute containing the PMKSA caching
+ *	candidate information, see &enum nl80211_pmksa_candidate_attr.
+ *
+ * @NL80211_ATTR_TX_NO_CCK_RATE: Indicates whether to use CCK rate or not
+ *	for management frames transmission. In order to avoid p2p probe/action
+ *	frames are being transmitted at CCK rate in 2GHz band, the user space
+ *	applications use this attribute.
+ *	This attribute is used with %NL80211_CMD_TRIGGER_SCAN and
+ *	%NL80211_CMD_FRAME commands.
+ *
+ * @NL80211_ATTR_TDLS_ACTION: Low level TDLS action code (e.g. link setup
+ *	request, link setup confirm, link teardown, etc.). Values are
+ *	described in the TDLS (802.11z) specification.
+ * @NL80211_ATTR_TDLS_DIALOG_TOKEN: Non-zero token for uniquely identifying a
+ *	TDLS conversation between two devices.
+ * @NL80211_ATTR_TDLS_OPERATION: High level TDLS operation; see
+ *	&enum nl80211_tdls_operation, represented as a u8.
+ * @NL80211_ATTR_TDLS_SUPPORT: A flag indicating the device can operate
+ *	as a TDLS peer sta.
+ * @NL80211_ATTR_TDLS_EXTERNAL_SETUP: The TDLS discovery/setup and teardown
+ *	procedures should be performed by sending TDLS packets via
+ *	%NL80211_CMD_TDLS_MGMT. Otherwise %NL80211_CMD_TDLS_OPER should be
+ *	used for asking the driver to perform a TDLS operation.
+ *
+ * @NL80211_ATTR_DEVICE_AP_SME: This u32 attribute may be listed for devices
+ *	that have AP support to indicate that they have the AP SME integrated
+ *	with support for the features listed in this attribute, see
+ *	&enum nl80211_ap_sme_features.
+ *
+ * @NL80211_ATTR_DONT_WAIT_FOR_ACK: Used with %NL80211_CMD_FRAME, this tells
+ *	the driver to not wait for an acknowledgement. Note that due to this,
+ *	it will also not give a status callback nor return a cookie. This is
+ *	mostly useful for probe responses to save airtime.
+ *
+ * @NL80211_ATTR_FEATURE_FLAGS: This u32 attribute contains flags from
+ *	&enum nl80211_feature_flags and is advertised in wiphy information.
+ * @NL80211_ATTR_PROBE_RESP_OFFLOAD: Indicates that the HW responds to probe
+ *
+ *	requests while operating in AP-mode.
+ *	This attribute holds a bitmap of the supported protocols for
+ *	offloading (see &enum nl80211_probe_resp_offload_support_attr).
+ *
+ * @NL80211_ATTR_PROBE_RESP: Probe Response template data. Contains the entire
+ *	probe-response frame. The DA field in the 802.11 header is zero-ed out,
+ *	to be filled by the FW.
+ * @NL80211_ATTR_DISABLE_HT:  Force HT capable interfaces to disable
+ *      this feature.  Currently, only supported in mac80211 drivers.
+ * @NL80211_ATTR_HT_CAPABILITY_MASK: Specify which bits of the
+ *      ATTR_HT_CAPABILITY to which attention should be paid.
+ *      Currently, only mac80211 NICs support this feature.
+ *      The values that may be configured are:
+ *       MCS rates, MAX-AMSDU, HT-20-40 and HT_CAP_SGI_40
+ *       AMPDU density and AMPDU factor.
+ *      All values are treated as suggestions and may be ignored
+ *      by the driver as required.  The actual values may be seen in
+ *      the station debugfs ht_caps file.
+ *
+ * @NL80211_ATTR_DFS_REGION: region for regulatory rules which this country
+ *    abides to when initiating radiation on DFS channels. A country maps
+ *    to one DFS region.
+ *
+ * @NL80211_ATTR_NOACK_MAP: This u16 bitmap contains the No Ack Policy of
+ *      up to 16 TIDs.
+ *
  * @NL80211_ATTR_MAX: highest attribute number currently defined
  * @__NL80211_ATTR_AFTER_LAST: internal use
  */
 enum nl80211_attrs {
-/* don't change the order or add anything inbetween, this is ABI! */
+/* don't change the order or add anything between, this is ABI! */
 	NL80211_ATTR_UNSPEC,
 
 	NL80211_ATTR_WIPHY,
@@ -860,7 +1247,7 @@
 	NL80211_ATTR_REG_ALPHA2,
 	NL80211_ATTR_REG_RULES,
 
-	NL80211_ATTR_MESH_PARAMS,
+	NL80211_ATTR_MESH_CONFIG,
 
 	NL80211_ATTR_BSS_BASIC_RATES,
 
@@ -975,8 +1362,82 @@
 
 	NL80211_ATTR_SUPPORT_IBSS_RSN,
 
+	NL80211_ATTR_WIPHY_ANTENNA_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_RX,
+
 	NL80211_ATTR_MCAST_RATE,
 
+	NL80211_ATTR_OFFCHANNEL_TX_OK,
+
+	NL80211_ATTR_BSS_HT_OPMODE,
+
+	NL80211_ATTR_KEY_DEFAULT_TYPES,
+
+	NL80211_ATTR_MAX_REMAIN_ON_CHANNEL_DURATION,
+
+	NL80211_ATTR_MESH_SETUP,
+
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_TX,
+	NL80211_ATTR_WIPHY_ANTENNA_AVAIL_RX,
+
+	NL80211_ATTR_SUPPORT_MESH_AUTH,
+	NL80211_ATTR_STA_PLINK_STATE,
+
+	NL80211_ATTR_WOWLAN_TRIGGERS,
+	NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED,
+
+	NL80211_ATTR_SCHED_SCAN_INTERVAL,
+
+	NL80211_ATTR_INTERFACE_COMBINATIONS,
+	NL80211_ATTR_SOFTWARE_IFTYPES,
+
+	NL80211_ATTR_REKEY_DATA,
+
+	NL80211_ATTR_MAX_NUM_SCHED_SCAN_SSIDS,
+	NL80211_ATTR_MAX_SCHED_SCAN_IE_LEN,
+
+	NL80211_ATTR_SCAN_SUPP_RATES,
+
+	NL80211_ATTR_HIDDEN_SSID,
+
+	NL80211_ATTR_IE_PROBE_RESP,
+	NL80211_ATTR_IE_ASSOC_RESP,
+
+	NL80211_ATTR_STA_WME,
+	NL80211_ATTR_SUPPORT_AP_UAPSD,
+
+	NL80211_ATTR_ROAM_SUPPORT,
+
+	NL80211_ATTR_SCHED_SCAN_MATCH,
+	NL80211_ATTR_MAX_MATCH_SETS,
+
+	NL80211_ATTR_PMKSA_CANDIDATE,
+
+	NL80211_ATTR_TX_NO_CCK_RATE,
+
+	NL80211_ATTR_TDLS_ACTION,
+	NL80211_ATTR_TDLS_DIALOG_TOKEN,
+	NL80211_ATTR_TDLS_OPERATION,
+	NL80211_ATTR_TDLS_SUPPORT,
+	NL80211_ATTR_TDLS_EXTERNAL_SETUP,
+
+	NL80211_ATTR_DEVICE_AP_SME,
+
+	NL80211_ATTR_DONT_WAIT_FOR_ACK,
+
+	NL80211_ATTR_FEATURE_FLAGS,
+
+	NL80211_ATTR_PROBE_RESP_OFFLOAD,
+
+	NL80211_ATTR_PROBE_RESP,
+
+	NL80211_ATTR_DFS_REGION,
+
+	NL80211_ATTR_DISABLE_HT,
+	NL80211_ATTR_HT_CAPABILITY_MASK,
+
+	NL80211_ATTR_NOACK_MAP,
+
 	/* add attributes here, update the policy in nl80211.c */
 
 	__NL80211_ATTR_AFTER_LAST,
@@ -985,6 +1446,7 @@
 
 /* source-level API compatibility */
 #define NL80211_ATTR_SCAN_GENERATION NL80211_ATTR_GENERATION
+#define	NL80211_ATTR_MESH_PARAMS NL80211_ATTR_MESH_CONFIG
 
 /*
  * Allow user space programs to use #ifdef on new attributes by defining them
@@ -1010,8 +1472,10 @@
 #define NL80211_ATTR_AKM_SUITES NL80211_ATTR_AKM_SUITES
 #define NL80211_ATTR_KEY NL80211_ATTR_KEY
 #define NL80211_ATTR_KEYS NL80211_ATTR_KEYS
+#define NL80211_ATTR_FEATURE_FLAGS NL80211_ATTR_FEATURE_FLAGS
 
 #define NL80211_MAX_SUPP_RATES			32
+#define NL80211_MAX_SUPP_HT_RATES		77
 #define NL80211_MAX_SUPP_REG_RULES		32
 #define NL80211_TKIP_DATA_OFFSET_ENCR_KEY	0
 #define NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY	16
@@ -1028,7 +1492,9 @@
  * @NL80211_IFTYPE_ADHOC: independent BSS member
  * @NL80211_IFTYPE_STATION: managed BSS member
  * @NL80211_IFTYPE_AP: access point
- * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points
+ * @NL80211_IFTYPE_AP_VLAN: VLAN interface for access points; VLAN interfaces
+ *	are a bit special in that they must always be tied to a pre-existing
+ *	AP type interface.
  * @NL80211_IFTYPE_WDS: wireless distribution interface
  * @NL80211_IFTYPE_MONITOR: monitor interface receiving all frames
  * @NL80211_IFTYPE_MESH_POINT: mesh point
@@ -1070,6 +1536,12 @@
  *	with short barker preamble
  * @NL80211_STA_FLAG_WME: station is WME/QoS capable
  * @NL80211_STA_FLAG_MFP: station uses management frame protection
+ * @NL80211_STA_FLAG_AUTHENTICATED: station is authenticated
+ * @NL80211_STA_FLAG_TDLS_PEER: station is a TDLS peer -- this flag should
+ *	only be used in managed mode (even in the flags mask). Note that the
+ *	flag can't be changed, it is only valid while adding a station, and
+ *	attempts to change it will silently be ignored (rather than rejected
+ *	as errors.)
  * @NL80211_STA_FLAG_MAX: highest station flag number currently defined
  * @__NL80211_STA_FLAG_AFTER_LAST: internal use
  */
@@ -1079,6 +1551,8 @@
 	NL80211_STA_FLAG_SHORT_PREAMBLE,
 	NL80211_STA_FLAG_WME,
 	NL80211_STA_FLAG_MFP,
+	NL80211_STA_FLAG_AUTHENTICATED,
+	NL80211_STA_FLAG_TDLS_PEER,
 
 	/* keep last */
 	__NL80211_STA_FLAG_AFTER_LAST,
@@ -1124,6 +1598,36 @@
 };
 
 /**
+ * enum nl80211_sta_bss_param - BSS information collected by STA
+ *
+ * These attribute types are used with %NL80211_STA_INFO_BSS_PARAM
+ * when getting information about the bitrate of a station.
+ *
+ * @__NL80211_STA_BSS_PARAM_INVALID: attribute number 0 is reserved
+ * @NL80211_STA_BSS_PARAM_CTS_PROT: whether CTS protection is enabled (flag)
+ * @NL80211_STA_BSS_PARAM_SHORT_PREAMBLE:  whether short preamble is enabled
+ *	(flag)
+ * @NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME:  whether short slot time is enabled
+ *	(flag)
+ * @NL80211_STA_BSS_PARAM_DTIM_PERIOD: DTIM period for beaconing (u8)
+ * @NL80211_STA_BSS_PARAM_BEACON_INTERVAL: Beacon interval (u16)
+ * @NL80211_STA_BSS_PARAM_MAX: highest sta_bss_param number currently defined
+ * @__NL80211_STA_BSS_PARAM_AFTER_LAST: internal use
+ */
+enum nl80211_sta_bss_param {
+	__NL80211_STA_BSS_PARAM_INVALID,
+	NL80211_STA_BSS_PARAM_CTS_PROT,
+	NL80211_STA_BSS_PARAM_SHORT_PREAMBLE,
+	NL80211_STA_BSS_PARAM_SHORT_SLOT_TIME,
+	NL80211_STA_BSS_PARAM_DTIM_PERIOD,
+	NL80211_STA_BSS_PARAM_BEACON_INTERVAL,
+
+	/* keep last */
+	__NL80211_STA_BSS_PARAM_AFTER_LAST,
+	NL80211_STA_BSS_PARAM_MAX = __NL80211_STA_BSS_PARAM_AFTER_LAST - 1
+};
+
+/**
  * enum nl80211_sta_info - station information
  *
  * These attribute types are used with %NL80211_ATTR_STA_INFO
@@ -1133,16 +1637,30 @@
  * @NL80211_STA_INFO_INACTIVE_TIME: time since last activity (u32, msecs)
  * @NL80211_STA_INFO_RX_BYTES: total received bytes (u32, from this station)
  * @NL80211_STA_INFO_TX_BYTES: total transmitted bytes (u32, to this station)
- * @__NL80211_STA_INFO_AFTER_LAST: internal
- * @NL80211_STA_INFO_MAX: highest possible station info attribute
  * @NL80211_STA_INFO_SIGNAL: signal strength of last received PPDU (u8, dBm)
  * @NL80211_STA_INFO_TX_BITRATE: current unicast tx rate, nested attribute
- * 	containing info as possible, see &enum nl80211_sta_info_txrate.
+ * 	containing info as possible, see &enum nl80211_rate_info
  * @NL80211_STA_INFO_RX_PACKETS: total received packet (u32, from this station)
  * @NL80211_STA_INFO_TX_PACKETS: total transmitted packets (u32, to this
  *	station)
  * @NL80211_STA_INFO_TX_RETRIES: total retries (u32, to this station)
  * @NL80211_STA_INFO_TX_FAILED: total failed packets (u32, to this station)
+ * @NL80211_STA_INFO_SIGNAL_AVG: signal strength average (u8, dBm)
+ * @NL80211_STA_INFO_LLID: the station's mesh LLID
+ * @NL80211_STA_INFO_PLID: the station's mesh PLID
+ * @NL80211_STA_INFO_PLINK_STATE: peer link state for the station
+ *	(see %enum nl80211_plink_state)
+ * @NL80211_STA_INFO_RX_BITRATE: last unicast data frame rx rate, nested
+ *	attribute, like NL80211_STA_INFO_TX_BITRATE.
+ * @NL80211_STA_INFO_BSS_PARAM: current station's view of BSS, nested attribute
+ *     containing info as possible, see &enum nl80211_sta_bss_param
+ * @NL80211_STA_INFO_CONNECTED_TIME: time since the station is last connected
+ * @NL80211_STA_INFO_STA_FLAGS: Contains a struct nl80211_sta_flag_update.
+ * @NL80211_STA_INFO_BEACON_LOSS: count of times beacon loss was detected (u32)
+ * @NL80211_STA_INFO_CHAIN_SIGNAL: per-chain signal strength of last PPDU
+ * @NL80211_STA_INFO_CHAIN_SIGNAL_AVG: per-chain signal strength average
+ * @__NL80211_STA_INFO_AFTER_LAST: internal
+ * @NL80211_STA_INFO_MAX: highest possible station info attribute
  */
 enum nl80211_sta_info {
 	__NL80211_STA_INFO_INVALID,
@@ -1158,6 +1676,14 @@
 	NL80211_STA_INFO_TX_PACKETS,
 	NL80211_STA_INFO_TX_RETRIES,
 	NL80211_STA_INFO_TX_FAILED,
+	NL80211_STA_INFO_SIGNAL_AVG,
+	NL80211_STA_INFO_RX_BITRATE,
+	NL80211_STA_INFO_BSS_PARAM,
+	NL80211_STA_INFO_CONNECTED_TIME,
+	NL80211_STA_INFO_STA_FLAGS,
+	NL80211_STA_INFO_BEACON_LOSS,
+	NL80211_STA_INFO_CHAIN_SIGNAL,
+	NL80211_STA_INFO_CHAIN_SIGNAL_AVG,
 
 	/* keep last */
 	__NL80211_STA_INFO_AFTER_LAST,
@@ -1311,7 +1837,11 @@
  * 	wireless core it thinks its knows the regulatory domain we should be in.
  * @NL80211_REGDOM_SET_BY_COUNTRY_IE: the wireless core has received an
  * 	802.11 country information element with regulatory information it
- * 	thinks we should consider.
+ * 	thinks we should consider. cfg80211 only processes the country
+ *	code from the IE, and relies on the regulatory domain information
+ *	structure passed by userspace (CRDA) from our wireless-regdb.
+ *	If a channel is enabled but the country code indicates it should
+ *	be disabled we disable the channel and re-enable it upon disassociation.
  */
 enum nl80211_reg_initiator {
 	NL80211_REGDOM_SET_BY_CORE,
@@ -1383,6 +1913,26 @@
 };
 
 /**
+ * enum nl80211_sched_scan_match_attr - scheduled scan match attributes
+ * @__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID: attribute number 0 is reserved
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_SSID: SSID to be used for matching,
+ * only report BSS with matching SSID.
+ * @NL80211_SCHED_SCAN_MATCH_ATTR_MAX: highest scheduled scan filter
+ *	attribute number currently defined
+ * @__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST: internal use
+ */
+enum nl80211_sched_scan_match_attr {
+	__NL80211_SCHED_SCAN_MATCH_ATTR_INVALID,
+
+	NL80211_ATTR_SCHED_SCAN_MATCH_SSID,
+
+	/* keep last */
+	__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST,
+	NL80211_SCHED_SCAN_MATCH_ATTR_MAX =
+		__NL80211_SCHED_SCAN_MATCH_ATTR_AFTER_LAST - 1
+};
+
+/**
  * enum nl80211_reg_rule_flags - regulatory rule flags
  *
  * @NL80211_RRF_NO_OFDM: OFDM modulation not allowed
@@ -1408,6 +1958,21 @@
 };
 
 /**
+ * enum nl80211_dfs_regions - regulatory DFS regions
+ *
+ * @NL80211_DFS_UNSET: Country has no DFS master region specified
+ * @NL80211_DFS_FCC_: Country follows DFS master rules from FCC
+ * @NL80211_DFS_FCC_: Country follows DFS master rules from ETSI
+ * @NL80211_DFS_JP_: Country follows DFS master rules from JP/MKK/Telec
+ */
+enum nl80211_dfs_regions {
+	NL80211_DFS_UNSET	= 0,
+	NL80211_DFS_FCC		= 1,
+	NL80211_DFS_ETSI	= 2,
+	NL80211_DFS_JP		= 3,
+};
+
+/**
  * enum nl80211_survey_info - survey information
  *
  * These attribute types are used with %NL80211_ATTR_SURVEY_INFO
@@ -1480,14 +2045,15 @@
 /**
  * enum nl80211_meshconf_params - mesh configuration parameters
  *
- * Mesh configuration parameters
+ * Mesh configuration parameters. These can be changed while the mesh is
+ * active.
  *
  * @__NL80211_MESHCONF_INVALID: internal use
  *
  * @NL80211_MESHCONF_RETRY_TIMEOUT: specifies the initial retry timeout in
  * millisecond units, used by the Peer Link Open message
  *
- * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the inital confirm timeout, in
+ * @NL80211_MESHCONF_CONFIRM_TIMEOUT: specifies the initial confirm timeout, in
  * millisecond units, used by the peer link management to close a peer link
  *
  * @NL80211_MESHCONF_HOLDING_TIMEOUT: specifies the holding timeout, in
@@ -1527,7 +2093,24 @@
  * @NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME: The interval of time (in TUs)
  * that it takes for an HWMP information element to propagate across the mesh
  *
- * @NL80211_MESHCONF_ROOTMODE: whether root mode is enabled or not
+ * @NL80211_MESHCONF_HWMP_ROOTMODE: whether root mode is enabled or not
+ *
+ * @NL80211_MESHCONF_ELEMENT_TTL: specifies the value of TTL field set at a
+ * source mesh point for path selection elements.
+ *
+ * @NL80211_MESHCONF_HWMP_RANN_INTERVAL:  The interval of time (in TUs) between
+ * root announcements are transmitted.
+ *
+ * @NL80211_MESHCONF_GATE_ANNOUNCEMENTS: Advertise that this mesh station has
+ * access to a broader network beyond the MBSS.  This is done via Root
+ * Announcement frames.
+ *
+ * @NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL: The minimum interval of time (in
+ * TUs) during which a mesh STA can send only one Action frame containing a
+ * PERR element.
+ *
+ * @NL80211_MESHCONF_FORWARDING: set Mesh STA as forwarding or non-forwarding
+ * or forwarding entity (default is TRUE - forwarding entity)
  *
  * @NL80211_MESHCONF_ATTR_MAX: highest possible mesh configuration attribute
  *
@@ -1549,6 +2132,11 @@
 	NL80211_MESHCONF_HWMP_PREQ_MIN_INTERVAL,
 	NL80211_MESHCONF_HWMP_NET_DIAM_TRVS_TIME,
 	NL80211_MESHCONF_HWMP_ROOTMODE,
+	NL80211_MESHCONF_ELEMENT_TTL,
+	NL80211_MESHCONF_HWMP_RANN_INTERVAL,
+	NL80211_MESHCONF_GATE_ANNOUNCEMENTS,
+	NL80211_MESHCONF_HWMP_PERR_MIN_INTERVAL,
+	NL80211_MESHCONF_FORWARDING,
 
 	/* keep last */
 	__NL80211_MESHCONF_ATTR_AFTER_LAST,
@@ -1556,6 +2144,54 @@
 };
 
 /**
+ * enum nl80211_mesh_setup_params - mesh setup parameters
+ *
+ * Mesh setup parameters.  These are used to start/join a mesh and cannot be
+ * changed while the mesh is active.
+ *
+ * @__NL80211_MESH_SETUP_INVALID: Internal use
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL: Enable this option to use a
+ * vendor specific path selection algorithm or disable it to use the default
+ * HWMP.
+ *
+ * @NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC: Enable this option to use a
+ * vendor specific path metric or disable it to use the default Airtime
+ * metric.
+ *
+ * @NL80211_MESH_SETUP_IE: Information elements for this mesh, for instance, a
+ * robust security network ie, or a vendor specific information element that
+ * vendors will use to identify the path selection methods and metrics in use.
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_AUTH: Enable this option if an authentication
+ * daemon will be authenticating mesh candidates.
+ *
+ * @NL80211_MESH_SETUP_USERSPACE_AMPE: Enable this option if an authentication
+ * daemon will be securing peer link frames.  AMPE is a secured version of Mesh
+ * Peering Management (MPM) and is implemented with the assistance of a
+ * userspace daemon.  When this flag is set, the kernel will send peer
+ * management frames to a userspace daemon that will implement AMPE
+ * functionality (security capabilities selection, key confirmation, and key
+ * management).  When the flag is unset (default), the kernel can autonomously
+ * complete (unsecured) mesh peering without the need of a userspace daemon.
+ *
+ * @NL80211_MESH_SETUP_ATTR_MAX: highest possible mesh setup attribute number
+ * @__NL80211_MESH_SETUP_ATTR_AFTER_LAST: Internal use
+ */
+enum nl80211_mesh_setup_params {
+	__NL80211_MESH_SETUP_INVALID,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_PATH_SEL,
+	NL80211_MESH_SETUP_ENABLE_VENDOR_METRIC,
+	NL80211_MESH_SETUP_IE,
+	NL80211_MESH_SETUP_USERSPACE_AUTH,
+	NL80211_MESH_SETUP_USERSPACE_AMPE,
+
+	/* keep last */
+	__NL80211_MESH_SETUP_ATTR_AFTER_LAST,
+	NL80211_MESH_SETUP_ATTR_MAX = __NL80211_MESH_SETUP_ATTR_AFTER_LAST - 1
+};
+
+/**
  * enum nl80211_txq_attr - TX queue parameter attributes
  * @__NL80211_TXQ_ATTR_INVALID: Attribute number 0 is reserved
  * @NL80211_TXQ_ATTR_QUEUE: TX queue identifier (NL80211_TXQ_Q_*)
@@ -1713,6 +2349,23 @@
 };
 
 /**
+ * enum nl80211_key_default_types - key default types
+ * @__NL80211_KEY_DEFAULT_TYPE_INVALID: invalid
+ * @NL80211_KEY_DEFAULT_TYPE_UNICAST: key should be used as default
+ *	unicast key
+ * @NL80211_KEY_DEFAULT_TYPE_MULTICAST: key should be used as default
+ *	multicast key
+ * @NUM_NL80211_KEY_DEFAULT_TYPES: number of default types
+ */
+enum nl80211_key_default_types {
+	__NL80211_KEY_DEFAULT_TYPE_INVALID,
+	NL80211_KEY_DEFAULT_TYPE_UNICAST,
+	NL80211_KEY_DEFAULT_TYPE_MULTICAST,
+
+	NUM_NL80211_KEY_DEFAULT_TYPES
+};
+
+/**
  * enum nl80211_key_attributes - key attributes
  * @__NL80211_KEY_INVALID: invalid
  * @NL80211_KEY_DATA: (temporal) key data; for TKIP this consists of
@@ -1728,6 +2381,9 @@
  * @NL80211_KEY_TYPE: the key type from enum nl80211_key_type, if not
  *	specified the default depends on whether a MAC address was
  *	given with the command using the key or not (u32)
+ * @NL80211_KEY_DEFAULT_TYPES: A nested attribute containing flags
+ *	attributes, specifying what a key should be set as default as.
+ *	See &enum nl80211_key_default_types.
  * @__NL80211_KEY_AFTER_LAST: internal
  * @NL80211_KEY_MAX: highest key attribute
  */
@@ -1740,6 +2396,7 @@
 	NL80211_KEY_DEFAULT,
 	NL80211_KEY_DEFAULT_MGMT,
 	NL80211_KEY_TYPE,
+	NL80211_KEY_DEFAULT_TYPES,
 
 	/* keep last */
 	__NL80211_KEY_AFTER_LAST,
@@ -1753,12 +2410,15 @@
  *	in an array of rates as defined in IEEE 802.11 7.3.2.2 (u8 values with
  *	1 = 500 kbps) but without the IE length restriction (at most
  *	%NL80211_MAX_SUPP_RATES in a single array).
+ * @NL80211_TXRATE_MCS: HT (MCS) rates allowed for TX rate selection
+ *	in an array of MCS numbers.
  * @__NL80211_TXRATE_AFTER_LAST: internal
  * @NL80211_TXRATE_MAX: highest TX rate attribute
  */
 enum nl80211_tx_rate_attributes {
 	__NL80211_TXRATE_INVALID,
 	NL80211_TXRATE_LEGACY,
+	NL80211_TXRATE_MCS,
 
 	/* keep last */
 	__NL80211_TXRATE_AFTER_LAST,
@@ -1790,6 +2450,8 @@
  *	the minimum amount the RSSI level must change after an event before a
  *	new event may be issued (to reduce effects of RSSI oscillation).
  * @NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT: RSSI threshold event
+ * @NL80211_ATTR_CQM_PKT_LOSS_EVENT: a u32 value indicating that this many
+ *	consecutive packets were not acknowledged by the peer
  * @__NL80211_ATTR_CQM_AFTER_LAST: internal
  * @NL80211_ATTR_CQM_MAX: highest key attribute
  */
@@ -1798,6 +2460,7 @@
 	NL80211_ATTR_CQM_RSSI_THOLD,
 	NL80211_ATTR_CQM_RSSI_HYST,
 	NL80211_ATTR_CQM_RSSI_THRESHOLD_EVENT,
+	NL80211_ATTR_CQM_PKT_LOSS_EVENT,
 
 	/* keep last */
 	__NL80211_ATTR_CQM_AFTER_LAST,
@@ -1829,4 +2492,343 @@
 	NL80211_TX_POWER_FIXED,
 };
 
+/**
+ * enum nl80211_wowlan_packet_pattern_attr - WoWLAN packet pattern attribute
+ * @__NL80211_WOWLAN_PKTPAT_INVALID: invalid number for nested attribute
+ * @NL80211_WOWLAN_PKTPAT_PATTERN: the pattern, values where the mask has
+ *	a zero bit are ignored
+ * @NL80211_WOWLAN_PKTPAT_MASK: pattern mask, must be long enough to have
+ *	a bit for each byte in the pattern. The lowest-order bit corresponds
+ *	to the first byte of the pattern, but the bytes of the pattern are
+ *	in a little-endian-like format, i.e. the 9th byte of the pattern
+ *	corresponds to the lowest-order bit in the second byte of the mask.
+ *	For example: The match 00:xx:00:00:xx:00:00:00:00:xx:xx:xx (where
+ *	xx indicates "don't care") would be represented by a pattern of
+ *	twelve zero bytes, and a mask of "0xed,0x07".
+ *	Note that the pattern matching is done as though frames were not
+ *	802.11 frames but 802.3 frames, i.e. the frame is fully unpacked
+ *	first (including SNAP header unpacking) and then matched.
+ * @NUM_NL80211_WOWLAN_PKTPAT: number of attributes
+ * @MAX_NL80211_WOWLAN_PKTPAT: max attribute number
+ */
+enum nl80211_wowlan_packet_pattern_attr {
+	__NL80211_WOWLAN_PKTPAT_INVALID,
+	NL80211_WOWLAN_PKTPAT_MASK,
+	NL80211_WOWLAN_PKTPAT_PATTERN,
+
+	NUM_NL80211_WOWLAN_PKTPAT,
+	MAX_NL80211_WOWLAN_PKTPAT = NUM_NL80211_WOWLAN_PKTPAT - 1,
+};
+
+/**
+ * struct nl80211_wowlan_pattern_support - pattern support information
+ * @max_patterns: maximum number of patterns supported
+ * @min_pattern_len: minimum length of each pattern
+ * @max_pattern_len: maximum length of each pattern
+ *
+ * This struct is carried in %NL80211_WOWLAN_TRIG_PKT_PATTERN when
+ * that is part of %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED in the
+ * capability information given by the kernel to userspace.
+ */
+struct nl80211_wowlan_pattern_support {
+	__u32 max_patterns;
+	__u32 min_pattern_len;
+	__u32 max_pattern_len;
+} __attribute__((packed));
+
+/**
+ * enum nl80211_wowlan_triggers - WoWLAN trigger definitions
+ * @__NL80211_WOWLAN_TRIG_INVALID: invalid number for nested attributes
+ * @NL80211_WOWLAN_TRIG_ANY: wake up on any activity, do not really put
+ *	the chip into a special state -- works best with chips that have
+ *	support for low-power operation already (flag)
+ * @NL80211_WOWLAN_TRIG_DISCONNECT: wake up on disconnect, the way disconnect
+ *	is detected is implementation-specific (flag)
+ * @NL80211_WOWLAN_TRIG_MAGIC_PKT: wake up on magic packet (6x 0xff, followed
+ *	by 16 repetitions of MAC addr, anywhere in payload) (flag)
+ * @NL80211_WOWLAN_TRIG_PKT_PATTERN: wake up on the specified packet patterns
+ *	which are passed in an array of nested attributes, each nested attribute
+ *	defining a with attributes from &struct nl80211_wowlan_trig_pkt_pattern.
+ *	Each pattern defines a wakeup packet. The matching is done on the MSDU,
+ *	i.e. as though the packet was an 802.3 packet, so the pattern matching
+ *	is done after the packet is converted to the MSDU.
+ *
+ *	In %NL80211_ATTR_WOWLAN_TRIGGERS_SUPPORTED, it is a binary attribute
+ *	carrying a &struct nl80211_wowlan_pattern_support.
+ * @NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED: Not a real trigger, and cannot be
+ *	used when setting, used only to indicate that GTK rekeying is supported
+ *	by the device (flag)
+ * @NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE: wake up on GTK rekey failure (if
+ *	done by the device) (flag)
+ * @NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST: wake up on EAP Identity Request
+ *	packet (flag)
+ * @NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE: wake up on 4-way handshake (flag)
+ * @NL80211_WOWLAN_TRIG_RFKILL_RELEASE: wake up when rfkill is released
+ *	(on devices that have rfkill in the device) (flag)
+ * @NUM_NL80211_WOWLAN_TRIG: number of wake on wireless triggers
+ * @MAX_NL80211_WOWLAN_TRIG: highest wowlan trigger attribute number
+ */
+enum nl80211_wowlan_triggers {
+	__NL80211_WOWLAN_TRIG_INVALID,
+	NL80211_WOWLAN_TRIG_ANY,
+	NL80211_WOWLAN_TRIG_DISCONNECT,
+	NL80211_WOWLAN_TRIG_MAGIC_PKT,
+	NL80211_WOWLAN_TRIG_PKT_PATTERN,
+	NL80211_WOWLAN_TRIG_GTK_REKEY_SUPPORTED,
+	NL80211_WOWLAN_TRIG_GTK_REKEY_FAILURE,
+	NL80211_WOWLAN_TRIG_EAP_IDENT_REQUEST,
+	NL80211_WOWLAN_TRIG_4WAY_HANDSHAKE,
+	NL80211_WOWLAN_TRIG_RFKILL_RELEASE,
+
+	/* keep last */
+	NUM_NL80211_WOWLAN_TRIG,
+	MAX_NL80211_WOWLAN_TRIG = NUM_NL80211_WOWLAN_TRIG - 1
+};
+
+/**
+ * enum nl80211_iface_limit_attrs - limit attributes
+ * @NL80211_IFACE_LIMIT_UNSPEC: (reserved)
+ * @NL80211_IFACE_LIMIT_MAX: maximum number of interfaces that
+ *	can be chosen from this set of interface types (u32)
+ * @NL80211_IFACE_LIMIT_TYPES: nested attribute containing a
+ *	flag attribute for each interface type in this set
+ * @NUM_NL80211_IFACE_LIMIT: number of attributes
+ * @MAX_NL80211_IFACE_LIMIT: highest attribute number
+ */
+enum nl80211_iface_limit_attrs {
+	NL80211_IFACE_LIMIT_UNSPEC,
+	NL80211_IFACE_LIMIT_MAX,
+	NL80211_IFACE_LIMIT_TYPES,
+
+	/* keep last */
+	NUM_NL80211_IFACE_LIMIT,
+	MAX_NL80211_IFACE_LIMIT = NUM_NL80211_IFACE_LIMIT - 1
+};
+
+/**
+ * enum nl80211_if_combination_attrs -- interface combination attributes
+ *
+ * @NL80211_IFACE_COMB_UNSPEC: (reserved)
+ * @NL80211_IFACE_COMB_LIMITS: Nested attributes containing the limits
+ *	for given interface types, see &enum nl80211_iface_limit_attrs.
+ * @NL80211_IFACE_COMB_MAXNUM: u32 attribute giving the total number of
+ *	interfaces that can be created in this group. This number doesn't
+ *	apply to interfaces purely managed in software, which are listed
+ *	in a separate attribute %NL80211_ATTR_INTERFACES_SOFTWARE.
+ * @NL80211_IFACE_COMB_STA_AP_BI_MATCH: flag attribute specifying that
+ *	beacon intervals within this group must be all the same even for
+ *	infrastructure and AP/GO combinations, i.e. the GO(s) must adopt
+ *	the infrastructure network's beacon interval.
+ * @NL80211_IFACE_COMB_NUM_CHANNELS: u32 attribute specifying how many
+ *	different channels may be used within this group.
+ * @NUM_NL80211_IFACE_COMB: number of attributes
+ * @MAX_NL80211_IFACE_COMB: highest attribute number
+ *
+ * Examples:
+ *	limits = [ #{STA} <= 1, #{AP} <= 1 ], matching BI, channels = 1, max = 2
+ *	=> allows an AP and a STA that must match BIs
+ *
+ *	numbers = [ #{AP, P2P-GO} <= 8 ], channels = 1, max = 8
+ *	=> allows 8 of AP/GO
+ *
+ *	numbers = [ #{STA} <= 2 ], channels = 2, max = 2
+ *	=> allows two STAs on different channels
+ *
+ *	numbers = [ #{STA} <= 1, #{P2P-client,P2P-GO} <= 3 ], max = 4
+ *	=> allows a STA plus three P2P interfaces
+ *
+ * The list of these four possiblities could completely be contained
+ * within the %NL80211_ATTR_INTERFACE_COMBINATIONS attribute to indicate
+ * that any of these groups must match.
+ *
+ * "Combinations" of just a single interface will not be listed here,
+ * a single interface of any valid interface type is assumed to always
+ * be possible by itself. This means that implicitly, for each valid
+ * interface type, the following group always exists:
+ *	numbers = [ #{<type>} <= 1 ], channels = 1, max = 1
+ */
+enum nl80211_if_combination_attrs {
+	NL80211_IFACE_COMB_UNSPEC,
+	NL80211_IFACE_COMB_LIMITS,
+	NL80211_IFACE_COMB_MAXNUM,
+	NL80211_IFACE_COMB_STA_AP_BI_MATCH,
+	NL80211_IFACE_COMB_NUM_CHANNELS,
+
+	/* keep last */
+	NUM_NL80211_IFACE_COMB,
+	MAX_NL80211_IFACE_COMB = NUM_NL80211_IFACE_COMB - 1
+};
+
+
+/**
+ * enum nl80211_plink_state - state of a mesh peer link finite state machine
+ *
+ * @NL80211_PLINK_LISTEN: initial state, considered the implicit
+ *	state of non existant mesh peer links
+ * @NL80211_PLINK_OPN_SNT: mesh plink open frame has been sent to
+ *	this mesh peer
+ * @NL80211_PLINK_OPN_RCVD: mesh plink open frame has been received
+ *	from this mesh peer
+ * @NL80211_PLINK_CNF_RCVD: mesh plink confirm frame has been
+ *	received from this mesh peer
+ * @NL80211_PLINK_ESTAB: mesh peer link is established
+ * @NL80211_PLINK_HOLDING: mesh peer link is being closed or cancelled
+ * @NL80211_PLINK_BLOCKED: all frames transmitted from this mesh
+ *	plink are discarded
+ * @NUM_NL80211_PLINK_STATES: number of peer link states
+ * @MAX_NL80211_PLINK_STATES: highest numerical value of plink states
+ */
+enum nl80211_plink_state {
+	NL80211_PLINK_LISTEN,
+	NL80211_PLINK_OPN_SNT,
+	NL80211_PLINK_OPN_RCVD,
+	NL80211_PLINK_CNF_RCVD,
+	NL80211_PLINK_ESTAB,
+	NL80211_PLINK_HOLDING,
+	NL80211_PLINK_BLOCKED,
+
+	/* keep last */
+	NUM_NL80211_PLINK_STATES,
+	MAX_NL80211_PLINK_STATES = NUM_NL80211_PLINK_STATES - 1
+};
+
+#define NL80211_KCK_LEN			16
+#define NL80211_KEK_LEN			16
+#define NL80211_REPLAY_CTR_LEN		8
+
+/**
+ * enum nl80211_rekey_data - attributes for GTK rekey offload
+ * @__NL80211_REKEY_DATA_INVALID: invalid number for nested attributes
+ * @NL80211_REKEY_DATA_KEK: key encryption key (binary)
+ * @NL80211_REKEY_DATA_KCK: key confirmation key (binary)
+ * @NL80211_REKEY_DATA_REPLAY_CTR: replay counter (binary)
+ * @NUM_NL80211_REKEY_DATA: number of rekey attributes (internal)
+ * @MAX_NL80211_REKEY_DATA: highest rekey attribute (internal)
+ */
+enum nl80211_rekey_data {
+	__NL80211_REKEY_DATA_INVALID,
+	NL80211_REKEY_DATA_KEK,
+	NL80211_REKEY_DATA_KCK,
+	NL80211_REKEY_DATA_REPLAY_CTR,
+
+	/* keep last */
+	NUM_NL80211_REKEY_DATA,
+	MAX_NL80211_REKEY_DATA = NUM_NL80211_REKEY_DATA - 1
+};
+
+/**
+ * enum nl80211_hidden_ssid - values for %NL80211_ATTR_HIDDEN_SSID
+ * @NL80211_HIDDEN_SSID_NOT_IN_USE: do not hide SSID (i.e., broadcast it in
+ *	Beacon frames)
+ * @NL80211_HIDDEN_SSID_ZERO_LEN: hide SSID by using zero-length SSID element
+ *	in Beacon frames
+ * @NL80211_HIDDEN_SSID_ZERO_CONTENTS: hide SSID by using correct length of SSID
+ *	element in Beacon frames but zero out each byte in the SSID
+ */
+enum nl80211_hidden_ssid {
+	NL80211_HIDDEN_SSID_NOT_IN_USE,
+	NL80211_HIDDEN_SSID_ZERO_LEN,
+	NL80211_HIDDEN_SSID_ZERO_CONTENTS
+};
+
+/**
+ * enum nl80211_sta_wme_attr - station WME attributes
+ * @__NL80211_STA_WME_INVALID: invalid number for nested attribute
+ * @NL80211_STA_WME_UAPSD_QUEUES: bitmap of uapsd queues. the format
+ *	is the same as the AC bitmap in the QoS info field.
+ * @NL80211_STA_WME_MAX_SP: max service period. the format is the same
+ *	as the MAX_SP field in the QoS info field (but already shifted down).
+ * @__NL80211_STA_WME_AFTER_LAST: internal
+ * @NL80211_STA_WME_MAX: highest station WME attribute
+ */
+enum nl80211_sta_wme_attr {
+	__NL80211_STA_WME_INVALID,
+	NL80211_STA_WME_UAPSD_QUEUES,
+	NL80211_STA_WME_MAX_SP,
+
+	/* keep last */
+	__NL80211_STA_WME_AFTER_LAST,
+	NL80211_STA_WME_MAX = __NL80211_STA_WME_AFTER_LAST - 1
+};
+
+/**
+ * enum nl80211_pmksa_candidate_attr - attributes for PMKSA caching candidates
+ * @__NL80211_PMKSA_CANDIDATE_INVALID: invalid number for nested attributes
+ * @NL80211_PMKSA_CANDIDATE_INDEX: candidate index (u32; the smaller, the higher
+ *	priority)
+ * @NL80211_PMKSA_CANDIDATE_BSSID: candidate BSSID (6 octets)
+ * @NL80211_PMKSA_CANDIDATE_PREAUTH: RSN pre-authentication supported (flag)
+ * @NUM_NL80211_PMKSA_CANDIDATE: number of PMKSA caching candidate attributes
+ *	(internal)
+ * @MAX_NL80211_PMKSA_CANDIDATE: highest PMKSA caching candidate attribute
+ *	(internal)
+ */
+enum nl80211_pmksa_candidate_attr {
+	__NL80211_PMKSA_CANDIDATE_INVALID,
+	NL80211_PMKSA_CANDIDATE_INDEX,
+	NL80211_PMKSA_CANDIDATE_BSSID,
+	NL80211_PMKSA_CANDIDATE_PREAUTH,
+
+	/* keep last */
+	NUM_NL80211_PMKSA_CANDIDATE,
+	MAX_NL80211_PMKSA_CANDIDATE = NUM_NL80211_PMKSA_CANDIDATE - 1
+};
+
+/**
+ * enum nl80211_tdls_operation - values for %NL80211_ATTR_TDLS_OPERATION
+ * @NL80211_TDLS_DISCOVERY_REQ: Send a TDLS discovery request
+ * @NL80211_TDLS_SETUP: Setup TDLS link
+ * @NL80211_TDLS_TEARDOWN: Teardown a TDLS link which is already established
+ * @NL80211_TDLS_ENABLE_LINK: Enable TDLS link
+ * @NL80211_TDLS_DISABLE_LINK: Disable TDLS link
+ */
+enum nl80211_tdls_operation {
+	NL80211_TDLS_DISCOVERY_REQ,
+	NL80211_TDLS_SETUP,
+	NL80211_TDLS_TEARDOWN,
+	NL80211_TDLS_ENABLE_LINK,
+	NL80211_TDLS_DISABLE_LINK,
+};
+
+/*
+ * enum nl80211_ap_sme_features - device-integrated AP features
+ * Reserved for future use, no bits are defined in
+ * NL80211_ATTR_DEVICE_AP_SME yet.
+enum nl80211_ap_sme_features {
+};
+ */
+
+/**
+ * enum nl80211_feature_flags - device/driver features
+ * @NL80211_FEATURE_SK_TX_STATUS: This driver supports reflecting back
+ *	TX status to the socket error queue when requested with the
+ *	socket option.
+ * @NL80211_FEATURE_HT_IBSS: This driver supports IBSS with HT datarates.
+ */
+enum nl80211_feature_flags {
+	NL80211_FEATURE_SK_TX_STATUS	= 1 << 0,
+	NL80211_FEATURE_HT_IBSS		= 1 << 1,
+};
+
+/**
+ * enum nl80211_probe_resp_offload_support_attr - optional supported
+ *	protocols for probe-response offloading by the driver/FW.
+ *	To be used with the %NL80211_ATTR_PROBE_RESP_OFFLOAD attribute.
+ *	Each enum value represents a bit in the bitmap of supported
+ *	protocols. Typically a subset of probe-requests belonging to a
+ *	supported protocol will be excluded from offload and uploaded
+ *	to the host.
+ *
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS: Support for WPS ver. 1
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2: Support for WPS ver. 2
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P: Support for P2P
+ * @NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U: Support for 802.11u
+ */
+enum nl80211_probe_resp_offload_support_attr {
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS =	1<<0,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_WPS2 =	1<<1,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_P2P =	1<<2,
+	NL80211_PROBE_RESP_OFFLOAD_SUPPORT_80211U =	1<<3,
+};
+
 #endif /* __LINUX_NL80211_H */
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/lua.h package/iwinfo/src/include/iwinfo/lua.h
--- package/iwinfo/src/include/iwinfo/lua.h	2012-01-13 22:34:25.062365948 +0100
+++ package/iwinfo/src/include/iwinfo/lua.h	2012-01-03 22:37:23.045993613 +0100
@@ -71,11 +71,10 @@
 		return 1;										\
 	}
 
-#define LUA_WRAP_LIST(type,op)							\
+#define LUA_WRAP_STRUCT(type,op)						\
 	static int iwinfo_L_##type##_##op(lua_State *L)		\
 	{													\
 		return iwinfo_L_##op(L, type##_get_##op);		\
 	}
 
 #endif
-
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/madwifi.h package/iwinfo/src/include/iwinfo/madwifi.h
--- package/iwinfo/src/include/iwinfo/madwifi.h	2012-01-13 22:34:25.053005870 +0100
+++ package/iwinfo/src/include/iwinfo/madwifi.h	2012-02-25 18:58:52.276145724 +0100
@@ -26,13 +26,15 @@
 #include "iwinfo/api/madwifi.h"
 
 int madwifi_probe(const char *ifname);
-int madwifi_get_mode(const char *ifname, char *buf);
+int madwifi_get_mode(const char *ifname, int *buf);
 int madwifi_get_ssid(const char *ifname, char *buf);
 int madwifi_get_bssid(const char *ifname, char *buf);
 int madwifi_get_country(const char *ifname, char *buf);
 int madwifi_get_channel(const char *ifname, int *buf);
 int madwifi_get_frequency(const char *ifname, int *buf);
+int madwifi_get_frequency_offset(const char *ifname, int *buf);
 int madwifi_get_txpower(const char *ifname, int *buf);
+int madwifi_get_txpower_offset(const char *ifname, int *buf);
 int madwifi_get_bitrate(const char *ifname, int *buf);
 int madwifi_get_signal(const char *ifname, int *buf);
 int madwifi_get_noise(const char *ifname, int *buf);
@@ -46,30 +48,36 @@
 int madwifi_get_countrylist(const char *ifname, char *buf, int *len);
 int madwifi_get_hwmodelist(const char *ifname, int *buf);
 int madwifi_get_mbssid_support(const char *ifname, int *buf);
+int madwifi_get_hardware_id(const char *ifname, char *buf);
+int madwifi_get_hardware_name(const char *ifname, char *buf);
 void madwifi_close(void);
 
 static const struct iwinfo_ops madwifi_ops = {
-	.channel        = madwifi_get_channel,
-	.frequency      = madwifi_get_frequency,
-	.txpower        = madwifi_get_txpower,
-	.bitrate        = madwifi_get_bitrate,
-	.signal         = madwifi_get_signal,
-	.noise          = madwifi_get_noise,
-	.quality        = madwifi_get_quality,
-	.quality_max    = madwifi_get_quality_max,
-	.mbssid_support = madwifi_get_mbssid_support,
-	.hwmodelist     = madwifi_get_hwmodelist,
-	.mode           = madwifi_get_mode,
-	.ssid           = madwifi_get_ssid,
-	.bssid          = madwifi_get_bssid,
-	.country        = madwifi_get_country,
-	.encryption     = madwifi_get_encryption,
-	.assoclist      = madwifi_get_assoclist,
-	.txpwrlist      = madwifi_get_txpwrlist,
-	.scanlist       = madwifi_get_scanlist,
-	.freqlist       = madwifi_get_freqlist,
-	.countrylist    = madwifi_get_countrylist,
-	.close          = madwifi_close
+	.channel          = madwifi_get_channel,
+	.frequency        = madwifi_get_frequency,
+	.frequency_offset = madwifi_get_frequency_offset,
+	.txpower          = madwifi_get_txpower,
+	.txpower_offset   = madwifi_get_txpower_offset,
+	.bitrate          = madwifi_get_bitrate,
+	.signal           = madwifi_get_signal,
+	.noise            = madwifi_get_noise,
+	.quality          = madwifi_get_quality,
+	.quality_max      = madwifi_get_quality_max,
+	.mbssid_support   = madwifi_get_mbssid_support,
+	.hwmodelist       = madwifi_get_hwmodelist,
+	.mode             = madwifi_get_mode,
+	.ssid             = madwifi_get_ssid,
+	.bssid            = madwifi_get_bssid,
+	.country          = madwifi_get_country,
+	.hardware_id      = madwifi_get_hardware_id,
+	.hardware_name    = madwifi_get_hardware_name,
+	.encryption       = madwifi_get_encryption,
+	.assoclist        = madwifi_get_assoclist,
+	.txpwrlist        = madwifi_get_txpwrlist,
+	.scanlist         = madwifi_get_scanlist,
+	.freqlist         = madwifi_get_freqlist,
+	.countrylist      = madwifi_get_countrylist,
+	.close            = madwifi_close
 };
 
 #endif
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/nl80211.h package/iwinfo/src/include/iwinfo/nl80211.h
--- package/iwinfo/src/include/iwinfo/nl80211.h	2012-01-13 22:34:25.099005771 +0100
+++ package/iwinfo/src/include/iwinfo/nl80211.h	2012-02-25 18:58:52.277146565 +0100
@@ -39,6 +39,7 @@
 	struct nl_sock *nl_sock;
 	struct nl_cache *nl_cache;
 	struct genl_family *nl80211;
+	struct genl_family *nlctrl;
 };
 
 struct nl80211_msg_conveyor {
@@ -46,6 +47,16 @@
 	struct nl_cb *cb;
 };
 
+struct nl80211_event_conveyor {
+	int wait;
+	int recv;
+};
+
+struct nl80211_group_conveyor {
+	const char *name;
+	int id;
+};
+
 struct nl80211_rssi_rate {
 	int16_t rate;
 	int8_t  rssi;
@@ -57,13 +68,15 @@
 };
 
 int nl80211_probe(const char *ifname);
-int nl80211_get_mode(const char *ifname, char *buf);
+int nl80211_get_mode(const char *ifname, int *buf);
 int nl80211_get_ssid(const char *ifname, char *buf);
 int nl80211_get_bssid(const char *ifname, char *buf);
 int nl80211_get_country(const char *ifname, char *buf);
 int nl80211_get_channel(const char *ifname, int *buf);
 int nl80211_get_frequency(const char *ifname, int *buf);
+int nl80211_get_frequency_offset(const char *ifname, int *buf);
 int nl80211_get_txpower(const char *ifname, int *buf);
+int nl80211_get_txpower_offset(const char *ifname, int *buf);
 int nl80211_get_bitrate(const char *ifname, int *buf);
 int nl80211_get_signal(const char *ifname, int *buf);
 int nl80211_get_noise(const char *ifname, int *buf);
@@ -77,30 +90,36 @@
 int nl80211_get_countrylist(const char *ifname, char *buf, int *len);
 int nl80211_get_hwmodelist(const char *ifname, int *buf);
 int nl80211_get_mbssid_support(const char *ifname, int *buf);
+int nl80211_get_hardware_id(const char *ifname, char *buf);
+int nl80211_get_hardware_name(const char *ifname, char *buf);
 void nl80211_close(void);
 
 static const struct iwinfo_ops nl80211_ops = {
-	.channel        = nl80211_get_channel,
-	.frequency      = nl80211_get_frequency,
-	.txpower        = nl80211_get_txpower,
-	.bitrate        = nl80211_get_bitrate,
-	.signal         = nl80211_get_signal,
-	.noise          = nl80211_get_noise,
-	.quality        = nl80211_get_quality,
-	.quality_max    = nl80211_get_quality_max,
-	.mbssid_support = nl80211_get_mbssid_support,
-	.hwmodelist     = nl80211_get_hwmodelist,
-	.mode           = nl80211_get_mode,
-	.ssid           = nl80211_get_ssid,
-	.bssid          = nl80211_get_bssid,
-	.country        = nl80211_get_country,
-	.encryption     = nl80211_get_encryption,
-	.assoclist      = nl80211_get_assoclist,
-	.txpwrlist      = nl80211_get_txpwrlist,
-	.scanlist       = nl80211_get_scanlist,
-	.freqlist       = nl80211_get_freqlist,
-	.countrylist    = nl80211_get_countrylist,
-	.close          = nl80211_close
+	.channel          = nl80211_get_channel,
+	.frequency        = nl80211_get_frequency,
+	.frequency_offset = nl80211_get_frequency_offset,
+	.txpower          = nl80211_get_txpower,
+	.txpower_offset   = nl80211_get_txpower_offset,
+	.bitrate          = nl80211_get_bitrate,
+	.signal           = nl80211_get_signal,
+	.noise            = nl80211_get_noise,
+	.quality          = nl80211_get_quality,
+	.quality_max      = nl80211_get_quality_max,
+	.mbssid_support   = nl80211_get_mbssid_support,
+	.hwmodelist       = nl80211_get_hwmodelist,
+	.mode             = nl80211_get_mode,
+	.ssid             = nl80211_get_ssid,
+	.bssid            = nl80211_get_bssid,
+	.country          = nl80211_get_country,
+	.hardware_id      = nl80211_get_hardware_id,
+	.hardware_name    = nl80211_get_hardware_name,
+	.encryption       = nl80211_get_encryption,
+	.assoclist        = nl80211_get_assoclist,
+	.txpwrlist        = nl80211_get_txpwrlist,
+	.scanlist         = nl80211_get_scanlist,
+	.freqlist         = nl80211_get_freqlist,
+	.countrylist      = nl80211_get_countrylist,
+	.close            = nl80211_close
 };
 
 #endif
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/utils.h package/iwinfo/src/include/iwinfo/utils.h
--- package/iwinfo/src/include/iwinfo/utils.h	2012-01-13 22:34:25.062365948 +0100
+++ package/iwinfo/src/include/iwinfo/utils.h	2012-02-25 18:58:52.277146565 +0100
@@ -37,4 +37,11 @@
 
 void iwinfo_close(void);
 
+struct iwinfo_hardware_entry * iwinfo_hardware(struct iwinfo_hardware_id *id);
+
+int iwinfo_hardware_id_from_mtd(struct iwinfo_hardware_id *id);
+
+void iwinfo_parse_rsn(struct iwinfo_crypto_entry *c, uint8_t *data, uint8_t len,
+					  uint8_t defcipher, uint8_t defauth);
+
 #endif
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/wext.h package/iwinfo/src/include/iwinfo/wext.h
--- package/iwinfo/src/include/iwinfo/wext.h	2012-01-13 22:34:25.100005651 +0100
+++ package/iwinfo/src/include/iwinfo/wext.h	2012-02-25 18:58:52.278145966 +0100
@@ -27,13 +27,15 @@
 
 
 int wext_probe(const char *ifname);
-int wext_get_mode(const char *ifname, char *buf);
+int wext_get_mode(const char *ifname, int *buf);
 int wext_get_ssid(const char *ifname, char *buf);
 int wext_get_bssid(const char *ifname, char *buf);
 int wext_get_country(const char *ifname, char *buf);
 int wext_get_channel(const char *ifname, int *buf);
 int wext_get_frequency(const char *ifname, int *buf);
+int wext_get_frequency_offset(const char *ifname, int *buf);
 int wext_get_txpower(const char *ifname, int *buf);
+int wext_get_txpower_offset(const char *ifname, int *buf);
 int wext_get_bitrate(const char *ifname, int *buf);
 int wext_get_signal(const char *ifname, int *buf);
 int wext_get_noise(const char *ifname, int *buf);
@@ -47,30 +49,36 @@
 int wext_get_countrylist(const char *ifname, char *buf, int *len);
 int wext_get_hwmodelist(const char *ifname, int *buf);
 int wext_get_mbssid_support(const char *ifname, int *buf);
+int wext_get_hardware_id(const char *ifname, char *buf);
+int wext_get_hardware_name(const char *ifname, char *buf);
 void wext_close(void);
 
 static const struct iwinfo_ops wext_ops = {
-	.channel        = wext_get_channel,
-	.frequency      = wext_get_frequency,
-	.txpower        = wext_get_txpower,
-	.bitrate        = wext_get_bitrate,
-	.signal         = wext_get_signal,
-	.noise          = wext_get_noise,
-	.quality        = wext_get_quality,
-	.quality_max    = wext_get_quality_max,
-	.mbssid_support = wext_get_mbssid_support,
-	.hwmodelist     = wext_get_hwmodelist,
-	.mode           = wext_get_mode,
-	.ssid           = wext_get_ssid,
-	.bssid          = wext_get_bssid,
-	.country        = wext_get_country,
-	.encryption     = wext_get_encryption,
-	.assoclist      = wext_get_assoclist,
-	.txpwrlist      = wext_get_txpwrlist,
-	.scanlist       = wext_get_scanlist,
-	.freqlist       = wext_get_freqlist,
-	.countrylist    = wext_get_countrylist,
-	.close          = wext_close
+	.channel          = wext_get_channel,
+	.frequency        = wext_get_frequency,
+	.frequency_offset = wext_get_frequency_offset,
+	.txpower          = wext_get_txpower,
+	.txpower_offset   = wext_get_txpower_offset,
+	.bitrate          = wext_get_bitrate,
+	.signal           = wext_get_signal,
+	.noise            = wext_get_noise,
+	.quality          = wext_get_quality,
+	.quality_max      = wext_get_quality_max,
+	.mbssid_support   = wext_get_mbssid_support,
+	.hwmodelist       = wext_get_hwmodelist,
+	.mode             = wext_get_mode,
+	.ssid             = wext_get_ssid,
+	.bssid            = wext_get_bssid,
+	.country          = wext_get_country,
+	.hardware_id      = wext_get_hardware_id,
+	.hardware_name    = wext_get_hardware_name,
+	.encryption       = wext_get_encryption,
+	.assoclist        = wext_get_assoclist,
+	.txpwrlist        = wext_get_txpwrlist,
+	.scanlist         = wext_get_scanlist,
+	.freqlist         = wext_get_freqlist,
+	.countrylist      = wext_get_countrylist,
+	.close            = wext_close
 };
 
 #endif
diff -Nru -x .svn package/iwinfo/src/include/iwinfo/wl.h package/iwinfo/src/include/iwinfo/wl.h
--- package/iwinfo/src/include/iwinfo/wl.h	2012-01-13 22:34:25.093387493 +0100
+++ package/iwinfo/src/include/iwinfo/wl.h	2012-02-25 18:58:52.277146565 +0100
@@ -26,13 +26,15 @@
 #include "iwinfo/api/broadcom.h"
 
 int wl_probe(const char *ifname);
-int wl_get_mode(const char *ifname, char *buf);
+int wl_get_mode(const char *ifname, int *buf);
 int wl_get_ssid(const char *ifname, char *buf);
 int wl_get_bssid(const char *ifname, char *buf);
 int wl_get_country(const char *ifname, char *buf);
 int wl_get_channel(const char *ifname, int *buf);
 int wl_get_frequency(const char *ifname, int *buf);
+int wl_get_frequency_offset(const char *ifname, int *buf);
 int wl_get_txpower(const char *ifname, int *buf);
+int wl_get_txpower_offset(const char *ifname, int *buf);
 int wl_get_bitrate(const char *ifname, int *buf);
 int wl_get_signal(const char *ifname, int *buf);
 int wl_get_noise(const char *ifname, int *buf);
@@ -47,30 +49,36 @@
 int wl_get_countrylist(const char *ifname, char *buf, int *len);
 int wl_get_hwmodelist(const char *ifname, int *buf);
 int wl_get_mbssid_support(const char *ifname, int *buf);
+int wl_get_hardware_id(const char *ifname, char *buf);
+int wl_get_hardware_name(const char *ifname, char *buf);
 void wl_close(void);
 
 static const struct iwinfo_ops wl_ops = {
-	.channel        = wl_get_channel,
-	.frequency      = wl_get_frequency,
-	.txpower        = wl_get_txpower,
-	.bitrate        = wl_get_bitrate,
-	.signal         = wl_get_signal,
-	.noise          = wl_get_noise,
-	.quality        = wl_get_quality,
-	.quality_max    = wl_get_quality_max,
-	.mbssid_support = wl_get_mbssid_support,
-	.hwmodelist     = wl_get_hwmodelist,
-	.mode           = wl_get_mode,
-	.ssid           = wl_get_ssid,
-	.bssid          = wl_get_bssid,
-	.country        = wl_get_country,
-	.encryption     = wl_get_encryption,
-	.assoclist      = wl_get_assoclist,
-	.txpwrlist      = wl_get_txpwrlist,
-	.scanlist       = wl_get_scanlist,
-	.freqlist       = wl_get_freqlist,
-	.countrylist    = wl_get_countrylist,
-	.close          = wl_close
+	.channel          = wl_get_channel,
+	.frequency        = wl_get_frequency,
+	.frequency_offset = wl_get_frequency_offset,
+	.txpower          = wl_get_txpower,
+	.txpower_offset   = wl_get_txpower_offset,
+	.bitrate          = wl_get_bitrate,
+	.signal           = wl_get_signal,
+	.noise            = wl_get_noise,
+	.quality          = wl_get_quality,
+	.quality_max      = wl_get_quality_max,
+	.mbssid_support   = wl_get_mbssid_support,
+	.hwmodelist       = wl_get_hwmodelist,
+	.mode             = wl_get_mode,
+	.ssid             = wl_get_ssid,
+	.bssid            = wl_get_bssid,
+	.country          = wl_get_country,
+	.hardware_id      = wl_get_hardware_id,
+	.hardware_name    = wl_get_hardware_name,
+	.encryption       = wl_get_encryption,
+	.assoclist        = wl_get_assoclist,
+	.txpwrlist        = wl_get_txpwrlist,
+	.scanlist         = wl_get_scanlist,
+	.freqlist         = wl_get_freqlist,
+	.countrylist      = wl_get_countrylist,
+	.close            = wl_close
 };
 
 #endif
diff -Nru -x .svn package/iwinfo/src/include/iwinfo.h package/iwinfo/src/include/iwinfo.h
--- package/iwinfo/src/include/iwinfo.h	2012-01-13 22:34:25.032605994 +0100
+++ package/iwinfo/src/include/iwinfo.h	2012-02-25 18:58:52.279147486 +0100
@@ -15,6 +15,7 @@
 #include <stdint.h>
 
 #include <sys/ioctl.h>
+#include <sys/mman.h>
 #include <net/if.h>
 #include <errno.h>
 
@@ -48,10 +49,33 @@
 extern const char *IWINFO_AUTH_NAMES[];
 
 
+enum iwinfo_opmode {
+	IWINFO_OPMODE_UNKNOWN = 0,
+	IWINFO_OPMODE_MASTER  = 1,
+	IWINFO_OPMODE_ADHOC   = 2,
+	IWINFO_OPMODE_CLIENT  = 3,
+	IWINFO_OPMODE_MONITOR = 4,
+};
+
+extern const char *IWINFO_OPMODE_NAMES[];
+
+
+struct iwinfo_rate_entry {
+	uint16_t rate;
+	int8_t mcs;
+	uint8_t is_40mhz:1;
+	uint8_t is_short_gi:1;
+};
+
 struct iwinfo_assoclist_entry {
 	uint8_t	mac[6];
 	int8_t signal;
 	int8_t noise;
+	uint32_t inactive;
+	uint32_t rx_packets;
+	uint32_t tx_packets;
+	struct iwinfo_rate_entry rx_rate;
+	struct iwinfo_rate_entry tx_rate;
 };
 
 struct iwinfo_txpwrlist_entry {
@@ -77,7 +101,7 @@
 struct iwinfo_scanlist_entry {
 	uint8_t mac[6];
 	uint8_t ssid[IWINFO_ESSID_MAX_SIZE+1];
-	uint8_t mode[8];
+	enum iwinfo_opmode mode;
 	uint8_t channel;
 	uint8_t signal;
 	uint8_t quality;
@@ -95,13 +119,35 @@
 	uint8_t  name[28];
 };
 
+struct iwinfo_hardware_id {
+	uint16_t vendor_id;
+	uint16_t device_id;
+	uint16_t subsystem_vendor_id;
+	uint16_t subsystem_device_id;
+};
+
+struct iwinfo_hardware_entry {
+	const char *vendor_name;
+	const char *device_name;
+	uint16_t vendor_id;
+	uint16_t device_id;
+	uint16_t subsystem_vendor_id;
+	uint16_t subsystem_device_id;
+	int16_t txpower_offset;
+	int16_t frequency_offset;
+};
+
 extern const struct iwinfo_iso3166_label IWINFO_ISO3166_NAMES[];
+extern const struct iwinfo_hardware_entry IWINFO_HARDWARE_ENTRIES[];
 
 
 struct iwinfo_ops {
+	int (*mode)(const char *, int *);
 	int (*channel)(const char *, int *);
 	int (*frequency)(const char *, int *);
+	int (*frequency_offset)(const char *, int *);
 	int (*txpower)(const char *, int *);
+	int (*txpower_offset)(const char *, int *);
 	int (*bitrate)(const char *, int *);
 	int (*signal)(const char *, int *);
 	int (*noise)(const char *, int *);
@@ -109,10 +155,11 @@
 	int (*quality_max)(const char *, int *);
 	int (*mbssid_support)(const char *, int *);
 	int (*hwmodelist)(const char *, int *);
-	int (*mode)(const char *, char *);
 	int (*ssid)(const char *, char *);
 	int (*bssid)(const char *, char *);
 	int (*country)(const char *, char *);
+	int (*hardware_id)(const char *, char *);
+	int (*hardware_name)(const char *, char *);
 	int (*encryption)(const char *, char *);
 	int (*assoclist)(const char *, char *, int *);
 	int (*txpwrlist)(const char *, char *, int *);
diff -Nru -x .svn package/iwinfo/src/iwinfo_cli.c package/iwinfo/src/iwinfo_cli.c
--- package/iwinfo/src/iwinfo_cli.c	2012-01-13 22:34:25.113156043 +0100
+++ package/iwinfo/src/iwinfo_cli.c	2012-02-25 18:58:52.333897236 +0100
@@ -230,19 +230,19 @@
 				case 3:
 					snprintf(buf, sizeof(buf), "mixed WPA/WPA2 %s (%s)",
 						format_enc_suites(c->auth_suites),
-						format_enc_ciphers(c->pair_ciphers & c->group_ciphers));
+						format_enc_ciphers(c->pair_ciphers | c->group_ciphers));
 					break;
 
 				case 2:
 					snprintf(buf, sizeof(buf), "WPA2 %s (%s)",
 						format_enc_suites(c->auth_suites),
-						format_enc_ciphers(c->pair_ciphers & c->group_ciphers));
+						format_enc_ciphers(c->pair_ciphers | c->group_ciphers));
 					break;
 
 				case 1:
 					snprintf(buf, sizeof(buf), "WPA %s (%s)",
 						format_enc_suites(c->auth_suites),
-						format_enc_ciphers(c->pair_ciphers & c->group_ciphers));
+						format_enc_ciphers(c->pair_ciphers | c->group_ciphers));
 					break;
 			}
 		}
@@ -275,6 +275,34 @@
 	return buf;
 }
 
+static char * format_assocrate(struct iwinfo_rate_entry *r)
+{
+	static char buf[40];
+	char *p = buf;
+	int l = sizeof(buf);
+
+	if (r->rate <= 0)
+	{
+		snprintf(buf, sizeof(buf), "unknown");
+	}
+	else
+	{
+		p += snprintf(p, l, "%s", format_rate(r->rate));
+		l = sizeof(buf) - (p - buf);
+
+		if (r->mcs >= 0)
+		{
+			p += snprintf(p, l, ", MCS %d, %dMHz", r->mcs, 20 + r->is_40mhz*20);
+			l = sizeof(buf) - (p - buf);
+
+			if (r->is_short_gi)
+				p += snprintf(p, l, ", short GI");
+		}
+	}
+
+	return buf;
+}
+
 
 static const char * print_type(const struct iwinfo_ops *iw, const char *ifname)
 {
@@ -282,6 +310,65 @@
 	return type ? type : "unknown";
 }
 
+static char * print_hardware_id(const struct iwinfo_ops *iw, const char *ifname)
+{
+	static char buf[20];
+	struct iwinfo_hardware_id ids;
+
+	if (!iw->hardware_id(ifname, (char *)&ids))
+	{
+		snprintf(buf, sizeof(buf), "%04X:%04X %04X:%04X",
+			ids.vendor_id, ids.device_id,
+			ids.subsystem_vendor_id, ids.subsystem_device_id);
+	}
+	else
+	{
+		snprintf(buf, sizeof(buf), "unknown");
+	}
+
+	return buf;
+}
+
+static char * print_hardware_name(const struct iwinfo_ops *iw, const char *ifname)
+{
+	static char buf[128];
+
+	if (iw->hardware_name(ifname, buf))
+		snprintf(buf, sizeof(buf), "unknown");
+
+	return buf;
+}
+
+static char * print_txpower_offset(const struct iwinfo_ops *iw, const char *ifname)
+{
+	int off;
+	static char buf[12];
+
+	if (iw->txpower_offset(ifname, &off))
+		snprintf(buf, sizeof(buf), "unknown");
+	else if (off != 0)
+		snprintf(buf, sizeof(buf), "%d dB", off);
+	else
+		snprintf(buf, sizeof(buf), "none");
+
+	return buf;
+}
+
+static char * print_frequency_offset(const struct iwinfo_ops *iw, const char *ifname)
+{
+	int off;
+	static char buf[12];
+
+	if (iw->frequency_offset(ifname, &off))
+		snprintf(buf, sizeof(buf), "unknown");
+	else if (off != 0)
+		snprintf(buf, sizeof(buf), "%.3f GHz", ((float)off / 1000.0));
+	else
+		snprintf(buf, sizeof(buf), "none");
+
+	return buf;
+}
+
 static char * print_ssid(const struct iwinfo_ops *iw, const char *ifname)
 {
 	char buf[IWINFO_ESSID_MAX_SIZE+1] = { 0 };
@@ -304,10 +391,13 @@
 
 static char * print_mode(const struct iwinfo_ops *iw, const char *ifname)
 {
+	int mode;
 	static char buf[128];
 
-	if (iw->mode(ifname, buf))
-		snprintf(buf, sizeof(buf), "unknown");
+	if (iw->mode(ifname, &mode))
+		mode = IWINFO_OPMODE_UNKNOWN;
+
+	snprintf(buf, sizeof(buf), "%s", IWINFO_OPMODE_NAMES[mode]);
 
 	return buf;
 }
@@ -332,9 +422,14 @@
 
 static char * print_txpower(const struct iwinfo_ops *iw, const char *ifname)
 {
-	int pwr;
+	int pwr, off;
+	if (iw->txpower_offset(ifname, &off))
+		off = 0;
+
 	if (iw->txpower(ifname, &pwr))
 		pwr = -1;
+	else
+		pwr += off;
 
 	return format_txpower(pwr);
 }
@@ -423,9 +518,6 @@
 		print_ssid(iw, ifname));
 	printf("          Access Point: %s\n",
 		print_bssid(iw, ifname));
-	printf("          Type: %s  HW Mode(s): %s\n",
-		print_type(iw, ifname),
-		print_hwmodes(iw, ifname));
 	printf("          Mode: %s  Channel: %s (%s)\n",
 		print_mode(iw, ifname),
 		print_channel(iw, ifname),
@@ -441,6 +533,16 @@
 		print_rate(iw, ifname));
 	printf("          Encryption: %s\n",
 		print_encryption(iw, ifname));
+	printf("          Type: %s  HW Mode(s): %s\n",
+		print_type(iw, ifname),
+		print_hwmodes(iw, ifname));
+	printf("          Hardware: %s [%s]\n",
+		print_hardware_id(iw, ifname),
+		print_hardware_name(iw, ifname));
+	printf("          TX power offset: %s\n",
+		print_txpower_offset(iw, ifname));
+	printf("          Frequency offset: %s\n",
+		print_frequency_offset(iw, ifname));
 	printf("          Supports VAPs: %s\n",
 		print_mbssid_supp(iw, ifname));
 }
@@ -473,7 +575,7 @@
 		printf("          ESSID: %s\n",
 			format_ssid(e->ssid));
 		printf("          Mode: %s  Channel: %s\n",
-			e->mode ? (char *)e->mode : "unknown",
+			IWINFO_OPMODE_NAMES[e->mode],
 			format_channel(e->channel));
 		printf("          Signal: %s  Quality: %s/%s\n",
 			format_signal(e->signal - 0x100),
@@ -487,7 +589,7 @@
 
 static void print_txpwrlist(const struct iwinfo_ops *iw, const char *ifname)
 {
-	int len, pwr, i;
+	int len, pwr, off, i;
 	char buf[IWINFO_BUFSIZE];
 	struct iwinfo_txpwrlist_entry *e;
 
@@ -500,14 +602,17 @@
 	if (iw->txpower(ifname, &pwr))
 		pwr = -1;
 
+	if (iw->txpower_offset(ifname, &off))
+		off = 0;
+
 	for (i = 0; i < len; i += sizeof(struct iwinfo_txpwrlist_entry))
 	{
 		e = (struct iwinfo_txpwrlist_entry *) &buf[i];
 
 		printf("%s%3d dBm (%4d mW)\n",
 			(pwr == e->dbm) ? "*" : " ",
-			e->dbm,
-			e->mw);
+			e->dbm + off,
+			iwinfo_dbm2mw(e->dbm + off));
 	}
 }
 
@@ -561,11 +666,22 @@
 	{
 		e = (struct iwinfo_assoclist_entry *) &buf[i];
 
-		printf("%s  %s / %s (SNR %d)\n",
+		printf("%s  %s / %s (SNR %d)  %d ms ago\n",
 			format_bssid(e->mac),
 			format_signal(e->signal),
 			format_noise(e->noise),
-			(e->signal - e->noise));
+			(e->signal - e->noise),
+			e->inactive);
+
+		printf("	RX: %-38s  %8d Pkts.\n",
+			format_assocrate(&e->rx_rate),
+			e->rx_packets
+		);
+
+		printf("	TX: %-38s  %8d Pkts.\n\n",
+			format_assocrate(&e->tx_rate),
+			e->tx_packets
+		);
 	}
 }
 
diff -Nru -x .svn package/iwinfo/src/iwinfo_lib.c package/iwinfo/src/iwinfo_lib.c
--- package/iwinfo/src/iwinfo_lib.c	2012-01-13 22:34:25.014235637 +0100
+++ package/iwinfo/src/iwinfo_lib.c	2012-02-25 18:58:52.333897236 +0100
@@ -44,6 +44,14 @@
 	"SHARED",
 };
 
+const char *IWINFO_OPMODE_NAMES[] = {
+	"Unknown",
+	"Master",
+	"Ad-Hoc",
+	"Client",
+	"Monitor",
+};
+
 
 /*
  * ISO3166 country labels
@@ -300,6 +308,68 @@
 	{ 0,               "" }
 };
 
+/*
+ * hardware database
+ */
+
+const char VENDOR_UBNT[] = "Ubiquiti";
+const char VENDOR_ATH[]  = "Atheros";
+
+const struct iwinfo_hardware_entry IWINFO_HARDWARE_ENTRIES[] = {
+/*	{ vendor, model, vendorid, deviceid, subsys vendorid, subsys deviceid, poweroff, freqoff } */
+#if defined(USE_MADWIFI) || defined(USE_NL80211)
+	{ VENDOR_UBNT, "PowerStation2 (18V)", 	0xffff, 0xffff, 0xffff, 0xb102,  0,     0 },
+	{ VENDOR_UBNT, "PowerStation2 (16D)", 	0xffff, 0xffff, 0xffff, 0xb202,  0,     0 },
+	{ VENDOR_UBNT, "PowerStation2 (EXT)", 	0xffff, 0xffff, 0xffff, 0xb302,  0,     0 },
+	{ VENDOR_UBNT, "PowerStation5 (22V)", 	0xffff, 0xffff, 0xffff, 0xb105,  0,     0 },
+	{ VENDOR_UBNT, "PowerStation5 (EXT)", 	0xffff, 0xffff, 0xffff, 0xb305,  0,     0 },
+	{ VENDOR_UBNT, "PicoStation2",        	0xffff, 0xffff, 0xffff, 0xc302,  0,     0 },
+	{ VENDOR_UBNT, "PicoStation2 HP",     	0xffff, 0xffff, 0xffff, 0xc3a2, 10,     0 },
+	{ VENDOR_UBNT, "WispStation5",        	0xffff, 0xffff, 0xffff, 0xa105,  0,     0 },
+	{ VENDOR_UBNT, "LiteStation2",        	0xffff, 0xffff, 0xffff, 0xa002, 10,     0 },
+	{ VENDOR_UBNT, "LiteStation5",        	0xffff, 0xffff, 0xffff, 0xa005,  5,     0 },
+	{ VENDOR_UBNT, "NanoStation2",        	0xffff, 0xffff, 0xffff, 0xc002, 10,     0 },
+	{ VENDOR_UBNT, "NanoStation5",        	0xffff, 0xffff, 0xffff, 0xc005,  5,     0 },
+	{ VENDOR_UBNT, "NanoStation Loco2",   	0xffff, 0xffff, 0xffff, 0xc102, 10,     0 },
+	{ VENDOR_UBNT, "NanoStation Loco5",   	0xffff, 0xffff, 0xffff, 0xc105,  5,     0 },
+	{ VENDOR_UBNT, "Bullet2",             	0xffff, 0xffff, 0xffff, 0xc202, 10,     0 },
+	{ VENDOR_UBNT, "Bullet5",             	0xffff, 0xffff, 0xffff, 0xc205,  5,     0 },
+	{ VENDOR_UBNT, "XR2",                   0x168c, 0x001b, 0x0777, 0x3002, 10,     0 },
+	{ VENDOR_UBNT, "XR2",                   0x168c, 0x001b, 0x7777, 0x3002, 10,     0 },
+	{ VENDOR_UBNT, "XR2.3",                 0x168c, 0x001b, 0x0777, 0x3b02, 10,     0 },
+	{ VENDOR_UBNT, "XR2.6",                 0x168c, 0x001b, 0x0777, 0x3c02, 10,     0 },
+	{ VENDOR_UBNT, "XR3-2.8",               0x168c, 0x001b, 0x0777, 0x3b03, 10,     0 },
+	{ VENDOR_UBNT, "XR3-3.6",               0x168c, 0x001b, 0x0777, 0x3c03, 10,     0 },
+	{ VENDOR_UBNT, "XR3",                   0x168c, 0x001b, 0x0777, 0x3003, 10,     0 },
+	{ VENDOR_UBNT, "XR4",                   0x168c, 0x001b, 0x0777, 0x3004, 10,     0 },
+	{ VENDOR_UBNT, "XR5",                   0x168c, 0x001b, 0x0777, 0x3005, 10,     0 },
+	{ VENDOR_UBNT, "XR5",                   0x168c, 0x001b, 0x7777, 0x3005, 10,     0 },
+	{ VENDOR_UBNT, "XR7",                   0x168c, 0x001b, 0x0777, 0x3007, 10,     0 },
+	{ VENDOR_UBNT, "XR9",                   0x168c, 0x001b, 0x0777, 0x3009, 10, -1520 },
+	{ VENDOR_UBNT, "SRC",                   0x168c, 0x0013, 0x168c, 0x1042,  1,     0 },
+	{ VENDOR_UBNT, "SR2",                   0x168c, 0x0013, 0x0777, 0x2041, 10,     0 },
+	{ VENDOR_UBNT, "SR4",                   0x168c, 0x0013, 0x0777, 0x2004,  6,     0 },
+	{ VENDOR_UBNT, "SR4",                   0x168c, 0x0013, 0x7777, 0x2004,  6,     0 },
+	{ VENDOR_UBNT, "SR4C",                  0x168c, 0x0013, 0x0777, 0x1004,  6,     0 },
+	{ VENDOR_UBNT, "SR4C",                  0x168c, 0x0013, 0x7777, 0x1004,  6,     0 },
+	{ VENDOR_UBNT, "SR5",                   0x168c, 0x0013, 0x168c, 0x2042,  7,     0 },
+	{ VENDOR_UBNT, "SR9",                   0x168c, 0x0013, 0x7777, 0x2009, 12, -1500 },
+	{ VENDOR_UBNT, "SR71A",                 0x168c, 0x0027, 0x168c, 0x2082, 10,     0 },
+	{ VENDOR_UBNT, "SR71",                  0x168c, 0x0027, 0x0777, 0x4082, 10,     0 },
+#endif
+#ifdef USE_NL80211
+	{ VENDOR_UBNT, "PicoStation M2",        0x168c, 0x002a, 0x0777, 0xe302, 12,     0 }, /* ToDo: confirm offset */
+	{ VENDOR_UBNT, "NanoStation M2",        0x168c, 0x002a, 0x0777, 0xe012, 12,     0 }, /* ToDo: confirm offset */
+	{ VENDOR_UBNT, "NanoStation M5",        0x168c, 0x002a, 0x0777, 0xe005,  5,     0 }, /* ToDo: confirm offset */
+	{ VENDOR_UBNT, "Bullet M2",             0x168c, 0x002a, 0x0777, 0xe202, 12,     0 },
+	{ VENDOR_UBNT, "Bullet M5",             0x168c, 0x002a, 0x0777, 0xe805,  5,     0 },
+
+	{ VENDOR_ATH,  "AR9220",                0x168c, 0x0029, 0x168c, 0xa094,  0,     0 },
+	{ VENDOR_ATH,  "AR9223",                0x168c, 0x0029, 0x168c, 0xa095,  0,     0 },
+#endif
+	{ NULL }
+};
+
 
 const char * iwinfo_type(const char *ifname)
 {
diff -Nru -x .svn package/iwinfo/src/iwinfo_lua.c package/iwinfo/src/iwinfo_lua.c
--- package/iwinfo/src/iwinfo_lua.c	2012-01-13 22:34:25.164003483 +0100
+++ package/iwinfo/src/iwinfo_lua.c	2012-02-25 18:58:52.336895278 +0100
@@ -235,6 +235,19 @@
 }
 
 
+/* Wrapper for mode */
+static int iwinfo_L_mode(lua_State *L, int (*func)(const char *, int *))
+{
+	int mode;
+	const char *ifname = luaL_checkstring(L, 1);
+
+	if ((*func)(ifname, &mode))
+		mode = IWINFO_OPMODE_UNKNOWN;
+
+	lua_pushstring(L, IWINFO_OPMODE_NAMES[mode]);
+	return 1;
+}
+
 /* Wrapper for assoclist */
 static int iwinfo_L_assoclist(lua_State *L, int (*func)(const char *, char *, int *))
 {
@@ -265,6 +278,45 @@
 			lua_pushnumber(L, e->noise);
 			lua_setfield(L, -2, "noise");
 
+			lua_pushnumber(L, e->inactive);
+			lua_setfield(L, -2, "inactive");
+
+			lua_pushnumber(L, e->rx_packets);
+			lua_setfield(L, -2, "rx_packets");
+
+			lua_pushnumber(L, e->tx_packets);
+			lua_setfield(L, -2, "tx_packets");
+
+			lua_pushnumber(L, e->rx_rate.rate);
+			lua_setfield(L, -2, "rx_rate");
+
+			lua_pushnumber(L, e->tx_rate.rate);
+			lua_setfield(L, -2, "tx_rate");
+
+			if (e->rx_rate.mcs >= 0)
+			{
+				lua_pushnumber(L, e->rx_rate.mcs);
+				lua_setfield(L, -2, "rx_mcs");
+
+				lua_pushboolean(L, e->rx_rate.is_40mhz);
+				lua_setfield(L, -2, "rx_40mhz");
+
+				lua_pushboolean(L, e->rx_rate.is_short_gi);
+				lua_setfield(L, -2, "rx_short_gi");
+			}
+
+			if (e->tx_rate.mcs >= 0)
+			{
+				lua_pushnumber(L, e->tx_rate.mcs);
+				lua_setfield(L, -2, "tx_mcs");
+
+				lua_pushboolean(L, e->tx_rate.is_40mhz);
+				lua_setfield(L, -2, "tx_40mhz");
+
+				lua_pushboolean(L, e->tx_rate.is_short_gi);
+				lua_setfield(L, -2, "tx_short_gi");
+			}
+
 			lua_setfield(L, -2, macstr);
 		}
 	}
@@ -344,7 +396,7 @@
 			lua_setfield(L, -2, "channel");
 
 			/* Mode */
-			lua_pushstring(L, (char *) e->mode);
+			lua_pushstring(L, IWINFO_OPMODE_NAMES[e->mode]);
 			lua_setfield(L, -2, "mode");
 
 			/* Quality, Signal */
@@ -451,7 +503,7 @@
 	return 1;
 }
 
-/* Wrapper for mbbsid_support */
+/* Wrapper for mbssid_support */
 static int iwinfo_L_mbssid_support(lua_State *L, int (*func)(const char *, int *))
 {
 	const char *ifname = luaL_checkstring(L, 1);
@@ -467,6 +519,36 @@
 	return 1;
 }
 
+/* Wrapper for hardware_id */
+static int iwinfo_L_hardware_id(lua_State *L, int (*func)(const char *, char *))
+{
+	const char *ifname = luaL_checkstring(L, 1);
+	struct iwinfo_hardware_id ids;
+
+	if (!(*func)(ifname, (char *)&ids))
+	{
+		lua_newtable(L);
+
+		lua_pushnumber(L, ids.vendor_id);
+		lua_setfield(L, -2, "vendor_id");
+
+		lua_pushnumber(L, ids.device_id);
+		lua_setfield(L, -2, "device_id");
+
+		lua_pushnumber(L, ids.subsystem_vendor_id);
+		lua_setfield(L, -2, "subsystem_vendor_id");
+
+		lua_pushnumber(L, ids.subsystem_device_id);
+		lua_setfield(L, -2, "subsystem_device_id");
+	}
+	else
+	{
+		lua_pushnil(L);
+	}
+
+	return 1;
+}
+
 /* Wrapper for country list */
 static char * iwinfo_L_country_lookup(char *buf, int len, int iso3166)
 {
@@ -528,102 +610,120 @@
 /* Broadcom */
 LUA_WRAP_INT(wl,channel)
 LUA_WRAP_INT(wl,frequency)
+LUA_WRAP_INT(wl,frequency_offset)
 LUA_WRAP_INT(wl,txpower)
+LUA_WRAP_INT(wl,txpower_offset)
 LUA_WRAP_INT(wl,bitrate)
 LUA_WRAP_INT(wl,signal)
 LUA_WRAP_INT(wl,noise)
 LUA_WRAP_INT(wl,quality)
 LUA_WRAP_INT(wl,quality_max)
-LUA_WRAP_STRING(wl,mode)
 LUA_WRAP_STRING(wl,ssid)
 LUA_WRAP_STRING(wl,bssid)
 LUA_WRAP_STRING(wl,country)
-LUA_WRAP_LIST(wl,assoclist)
-LUA_WRAP_LIST(wl,txpwrlist)
-LUA_WRAP_LIST(wl,scanlist)
-LUA_WRAP_LIST(wl,freqlist)
-LUA_WRAP_LIST(wl,countrylist)
-LUA_WRAP_LIST(wl,hwmodelist)
-LUA_WRAP_LIST(wl,encryption)
-LUA_WRAP_LIST(wl,mbssid_support)
+LUA_WRAP_STRING(wl,hardware_name)
+LUA_WRAP_STRUCT(wl,mode)
+LUA_WRAP_STRUCT(wl,assoclist)
+LUA_WRAP_STRUCT(wl,txpwrlist)
+LUA_WRAP_STRUCT(wl,scanlist)
+LUA_WRAP_STRUCT(wl,freqlist)
+LUA_WRAP_STRUCT(wl,countrylist)
+LUA_WRAP_STRUCT(wl,hwmodelist)
+LUA_WRAP_STRUCT(wl,encryption)
+LUA_WRAP_STRUCT(wl,mbssid_support)
+LUA_WRAP_STRUCT(wl,hardware_id)
 #endif
 
 #ifdef USE_MADWIFI
 /* Madwifi */
 LUA_WRAP_INT(madwifi,channel)
 LUA_WRAP_INT(madwifi,frequency)
+LUA_WRAP_INT(madwifi,frequency_offset)
 LUA_WRAP_INT(madwifi,txpower)
+LUA_WRAP_INT(madwifi,txpower_offset)
 LUA_WRAP_INT(madwifi,bitrate)
 LUA_WRAP_INT(madwifi,signal)
 LUA_WRAP_INT(madwifi,noise)
 LUA_WRAP_INT(madwifi,quality)
 LUA_WRAP_INT(madwifi,quality_max)
-LUA_WRAP_STRING(madwifi,mode)
 LUA_WRAP_STRING(madwifi,ssid)
 LUA_WRAP_STRING(madwifi,bssid)
 LUA_WRAP_STRING(madwifi,country)
-LUA_WRAP_LIST(madwifi,assoclist)
-LUA_WRAP_LIST(madwifi,txpwrlist)
-LUA_WRAP_LIST(madwifi,scanlist)
-LUA_WRAP_LIST(madwifi,freqlist)
-LUA_WRAP_LIST(madwifi,countrylist)
-LUA_WRAP_LIST(madwifi,hwmodelist)
-LUA_WRAP_LIST(madwifi,encryption)
-LUA_WRAP_LIST(madwifi,mbssid_support)
+LUA_WRAP_STRING(madwifi,hardware_name)
+LUA_WRAP_STRUCT(madwifi,mode)
+LUA_WRAP_STRUCT(madwifi,assoclist)
+LUA_WRAP_STRUCT(madwifi,txpwrlist)
+LUA_WRAP_STRUCT(madwifi,scanlist)
+LUA_WRAP_STRUCT(madwifi,freqlist)
+LUA_WRAP_STRUCT(madwifi,countrylist)
+LUA_WRAP_STRUCT(madwifi,hwmodelist)
+LUA_WRAP_STRUCT(madwifi,encryption)
+LUA_WRAP_STRUCT(madwifi,mbssid_support)
+LUA_WRAP_STRUCT(madwifi,hardware_id)
 #endif
 
 #ifdef USE_NL80211
 /* NL80211 */
 LUA_WRAP_INT(nl80211,channel)
 LUA_WRAP_INT(nl80211,frequency)
+LUA_WRAP_INT(nl80211,frequency_offset)
 LUA_WRAP_INT(nl80211,txpower)
+LUA_WRAP_INT(nl80211,txpower_offset)
 LUA_WRAP_INT(nl80211,bitrate)
 LUA_WRAP_INT(nl80211,signal)
 LUA_WRAP_INT(nl80211,noise)
 LUA_WRAP_INT(nl80211,quality)
 LUA_WRAP_INT(nl80211,quality_max)
-LUA_WRAP_STRING(nl80211,mode)
 LUA_WRAP_STRING(nl80211,ssid)
 LUA_WRAP_STRING(nl80211,bssid)
 LUA_WRAP_STRING(nl80211,country)
-LUA_WRAP_LIST(nl80211,assoclist)
-LUA_WRAP_LIST(nl80211,txpwrlist)
-LUA_WRAP_LIST(nl80211,scanlist)
-LUA_WRAP_LIST(nl80211,freqlist)
-LUA_WRAP_LIST(nl80211,countrylist)
-LUA_WRAP_LIST(nl80211,hwmodelist)
-LUA_WRAP_LIST(nl80211,encryption)
-LUA_WRAP_LIST(nl80211,mbssid_support)
+LUA_WRAP_STRING(nl80211,hardware_name)
+LUA_WRAP_STRUCT(nl80211,mode)
+LUA_WRAP_STRUCT(nl80211,assoclist)
+LUA_WRAP_STRUCT(nl80211,txpwrlist)
+LUA_WRAP_STRUCT(nl80211,scanlist)
+LUA_WRAP_STRUCT(nl80211,freqlist)
+LUA_WRAP_STRUCT(nl80211,countrylist)
+LUA_WRAP_STRUCT(nl80211,hwmodelist)
+LUA_WRAP_STRUCT(nl80211,encryption)
+LUA_WRAP_STRUCT(nl80211,mbssid_support)
+LUA_WRAP_STRUCT(nl80211,hardware_id)
 #endif
 
 /* Wext */
 LUA_WRAP_INT(wext,channel)
 LUA_WRAP_INT(wext,frequency)
+LUA_WRAP_INT(wext,frequency_offset)
 LUA_WRAP_INT(wext,txpower)
+LUA_WRAP_INT(wext,txpower_offset)
 LUA_WRAP_INT(wext,bitrate)
 LUA_WRAP_INT(wext,signal)
 LUA_WRAP_INT(wext,noise)
 LUA_WRAP_INT(wext,quality)
 LUA_WRAP_INT(wext,quality_max)
-LUA_WRAP_STRING(wext,mode)
 LUA_WRAP_STRING(wext,ssid)
 LUA_WRAP_STRING(wext,bssid)
 LUA_WRAP_STRING(wext,country)
-LUA_WRAP_LIST(wext,assoclist)
-LUA_WRAP_LIST(wext,txpwrlist)
-LUA_WRAP_LIST(wext,scanlist)
-LUA_WRAP_LIST(wext,freqlist)
-LUA_WRAP_LIST(wext,countrylist)
-LUA_WRAP_LIST(wext,hwmodelist)
-LUA_WRAP_LIST(wext,encryption)
-LUA_WRAP_LIST(wext,mbssid_support)
+LUA_WRAP_STRING(wext,hardware_name)
+LUA_WRAP_STRUCT(wext,mode)
+LUA_WRAP_STRUCT(wext,assoclist)
+LUA_WRAP_STRUCT(wext,txpwrlist)
+LUA_WRAP_STRUCT(wext,scanlist)
+LUA_WRAP_STRUCT(wext,freqlist)
+LUA_WRAP_STRUCT(wext,countrylist)
+LUA_WRAP_STRUCT(wext,hwmodelist)
+LUA_WRAP_STRUCT(wext,encryption)
+LUA_WRAP_STRUCT(wext,mbssid_support)
+LUA_WRAP_STRUCT(wext,hardware_id)
 
 #ifdef USE_WL
 /* Broadcom table */
 static const luaL_reg R_wl[] = {
 	LUA_REG(wl,channel),
 	LUA_REG(wl,frequency),
+	LUA_REG(wl,frequency_offset),
 	LUA_REG(wl,txpower),
+	LUA_REG(wl,txpower_offset),
 	LUA_REG(wl,bitrate),
 	LUA_REG(wl,signal),
 	LUA_REG(wl,noise),
@@ -641,6 +741,8 @@
 	LUA_REG(wl,hwmodelist),
 	LUA_REG(wl,encryption),
 	LUA_REG(wl,mbssid_support),
+	LUA_REG(wl,hardware_id),
+	LUA_REG(wl,hardware_name),
 	{ NULL, NULL }
 };
 #endif
@@ -650,7 +752,9 @@
 static const luaL_reg R_madwifi[] = {
 	LUA_REG(madwifi,channel),
 	LUA_REG(madwifi,frequency),
+	LUA_REG(madwifi,frequency_offset),
 	LUA_REG(madwifi,txpower),
+	LUA_REG(madwifi,txpower_offset),
 	LUA_REG(madwifi,bitrate),
 	LUA_REG(madwifi,signal),
 	LUA_REG(madwifi,noise),
@@ -668,6 +772,8 @@
 	LUA_REG(madwifi,hwmodelist),
 	LUA_REG(madwifi,encryption),
 	LUA_REG(madwifi,mbssid_support),
+	LUA_REG(madwifi,hardware_id),
+	LUA_REG(madwifi,hardware_name),
 	{ NULL, NULL }
 };
 #endif
@@ -677,7 +783,9 @@
 static const luaL_reg R_nl80211[] = {
 	LUA_REG(nl80211,channel),
 	LUA_REG(nl80211,frequency),
+	LUA_REG(nl80211,frequency_offset),
 	LUA_REG(nl80211,txpower),
+	LUA_REG(nl80211,txpower_offset),
 	LUA_REG(nl80211,bitrate),
 	LUA_REG(nl80211,signal),
 	LUA_REG(nl80211,noise),
@@ -695,6 +803,8 @@
 	LUA_REG(nl80211,hwmodelist),
 	LUA_REG(nl80211,encryption),
 	LUA_REG(nl80211,mbssid_support),
+	LUA_REG(nl80211,hardware_id),
+	LUA_REG(nl80211,hardware_name),
 	{ NULL, NULL }
 };
 #endif
@@ -703,7 +813,9 @@
 static const luaL_reg R_wext[] = {
 	LUA_REG(wext,channel),
 	LUA_REG(wext,frequency),
+	LUA_REG(wext,frequency_offset),
 	LUA_REG(wext,txpower),
+	LUA_REG(wext,txpower_offset),
 	LUA_REG(wext,bitrate),
 	LUA_REG(wext,signal),
 	LUA_REG(wext,noise),
@@ -721,6 +833,8 @@
 	LUA_REG(wext,hwmodelist),
 	LUA_REG(wext,encryption),
 	LUA_REG(wext,mbssid_support),
+	LUA_REG(wext,hardware_id),
+	LUA_REG(wext,hardware_name),
 	{ NULL, NULL }
 };
 
diff -Nru -x .svn package/iwinfo/src/iwinfo_madwifi.c package/iwinfo/src/iwinfo_madwifi.c
--- package/iwinfo/src/iwinfo_madwifi.c	2012-01-13 22:34:25.142290582 +0100
+++ package/iwinfo/src/iwinfo_madwifi.c	2012-02-25 18:58:52.335897238 +0100
@@ -333,7 +333,7 @@
 	/* Nop */
 }
 
-int madwifi_get_mode(const char *ifname, char *buf)
+int madwifi_get_mode(const char *ifname, int *buf)
 {
 	return wext_get_mode(ifname, buf);
 }
@@ -726,9 +726,29 @@
 		do {
 			si = (struct ieee80211req_sta_info *) cp;
 
+			memset(&entry, 0, sizeof(entry));
+
 			entry.signal = (si->isi_rssi - 95);
 			entry.noise  = noise;
 			memcpy(entry.mac, &si->isi_macaddr, 6);
+
+			entry.inactive = si->isi_inact * 1000;
+
+			entry.tx_packets = (si->isi_txseqs[0] & IEEE80211_SEQ_SEQ_MASK)
+				>> IEEE80211_SEQ_SEQ_SHIFT;
+
+			entry.rx_packets = (si->isi_rxseqs[0] & IEEE80211_SEQ_SEQ_MASK)
+				>> IEEE80211_SEQ_SEQ_SHIFT;
+
+			entry.tx_rate.rate =
+				(si->isi_rates[si->isi_txrate] & IEEE80211_RATE_VAL) * 500;
+
+			/* XXX: this is just a guess */
+			entry.rx_rate.rate = entry.tx_rate.rate;
+
+			entry.rx_rate.mcs = -1;
+			entry.tx_rate.mcs = -1;
+
 			memcpy(&buf[bl], &entry, sizeof(struct iwinfo_assoclist_entry));
 
 			bl += sizeof(struct iwinfo_assoclist_entry);
@@ -987,3 +1007,61 @@
 
 	return -1;
 }
+
+int madwifi_get_hardware_id(const char *ifname, char *buf)
+{
+	char vendor[64];
+	char device[64];
+	struct iwinfo_hardware_id *ids;
+	struct iwinfo_hardware_entry *e;
+
+	if (wext_get_hardware_id(ifname, buf))
+		return iwinfo_hardware_id_from_mtd((struct iwinfo_hardware_id *)buf);
+
+	return 0;
+}
+
+static const struct iwinfo_hardware_entry *
+madwifi_get_hardware_entry(const char *ifname)
+{
+	struct iwinfo_hardware_id id;
+
+	if (madwifi_get_hardware_id(ifname, (char *)&id))
+		return NULL;
+
+	return iwinfo_hardware(&id);
+}
+
+int madwifi_get_hardware_name(const char *ifname, char *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = madwifi_get_hardware_entry(ifname)))
+		sprintf(buf, "Generic Atheros");
+	else
+		sprintf(buf, "%s %s", hw->vendor_name, hw->device_name);
+
+	return 0;
+}
+
+int madwifi_get_txpower_offset(const char *ifname, int *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = madwifi_get_hardware_entry(ifname)))
+		return -1;
+
+	*buf = hw->txpower_offset;
+	return 0;
+}
+
+int madwifi_get_frequency_offset(const char *ifname, int *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = madwifi_get_hardware_entry(ifname)))
+		return -1;
+
+	*buf = hw->frequency_offset;
+	return 0;
+}
diff -Nru -x .svn package/iwinfo/src/iwinfo_nl80211.c package/iwinfo/src/iwinfo_nl80211.c
--- package/iwinfo/src/iwinfo_nl80211.c	2012-02-25 18:41:41.315147317 +0100
+++ package/iwinfo/src/iwinfo_nl80211.c	2012-02-25 18:58:52.332897477 +0100
@@ -47,26 +47,30 @@
 			goto err;
 		}
 
-		if( genl_connect(nls->nl_sock)) {
+		if (genl_connect(nls->nl_sock)) {
 			err = -ENOLINK;
 			goto err;
 		}
 
 		fd = nl_socket_get_fd(nls->nl_sock);
-		if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC) < 0)
-		{
+		if (fcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC) < 0) {
 			err = -EINVAL;
 			goto err;
 		}
 
-		if( genl_ctrl_alloc_cache(nls->nl_sock, &nls->nl_cache)) {
+		if (genl_ctrl_alloc_cache(nls->nl_sock, &nls->nl_cache)) {
 			err = -ENOMEM;
 			goto err;
 		}
 
 		nls->nl80211 = genl_ctrl_search_by_name(nls->nl_cache, "nl80211");
-		if (!nls->nl80211)
-		{
+		if (!nls->nl80211) {
+			err = -ENOENT;
+			goto err;
+		}
+
+		nls->nlctrl = genl_ctrl_search_by_name(nls->nl_cache, "nlctrl");
+		if (!nls->nlctrl) {
 			err = -ENOENT;
 			goto err;
 		}
@@ -80,6 +84,7 @@
 	return err;
 }
 
+
 static int nl80211_msg_error(struct sockaddr_nl *nla,
 	struct nlmsgerr *err, void *arg)
 {
@@ -122,29 +127,14 @@
 	}
 }
 
-static struct nl80211_msg_conveyor * nl80211_msg(const char *ifname, int cmd, int flags)
+static struct nl80211_msg_conveyor * nl80211_new(struct genl_family *family,
+                                                 int cmd, int flags)
 {
 	static struct nl80211_msg_conveyor cv;
 
-	int ifidx = -1, phyidx = -1;
 	struct nl_msg *req = NULL;
 	struct nl_cb *cb = NULL;
 
-	if (nl80211_init() < 0)
-		goto err;
-
-	if (!strncmp(ifname, "phy", 3))
-		phyidx = atoi(&ifname[3]);
-	else if (!strncmp(ifname, "radio", 5))
-		phyidx = atoi(&ifname[5]);
-	else if (!strncmp(ifname, "mon.", 4))
-		ifidx = if_nametoindex(&ifname[4]);
-	else
-		ifidx = if_nametoindex(ifname);
-
-	if ((ifidx < 0) && (phyidx < 0))
-		return NULL;
-
 	req = nlmsg_alloc();
 	if (!req)
 		goto err;
@@ -153,14 +143,7 @@
 	if (!cb)
 		goto err;
 
-	genlmsg_put(req, 0, 0, genl_family_get_id(nls->nl80211), 0,
-		flags, cmd, 0);
-
-	if (ifidx > -1)
-		NLA_PUT_U32(req, NL80211_ATTR_IFINDEX, ifidx);
-
-	if (phyidx > -1)
-		NLA_PUT_U32(req, NL80211_ATTR_WIPHY, phyidx);
+	genlmsg_put(req, 0, 0, genl_family_get_id(family), 0, flags, cmd, 0);
 
 	cv.msg = req;
 	cv.cb  = cb;
@@ -178,6 +161,52 @@
 	return NULL;
 }
 
+static struct nl80211_msg_conveyor * nl80211_ctl(int cmd, int flags)
+{
+	if (nl80211_init() < 0)
+		return NULL;
+
+	return nl80211_new(nls->nlctrl, cmd, flags);
+}
+
+static struct nl80211_msg_conveyor * nl80211_msg(const char *ifname,
+                                                 int cmd, int flags)
+{
+	int ifidx = -1, phyidx = -1;
+	struct nl80211_msg_conveyor *cv;
+
+	if (nl80211_init() < 0)
+		return NULL;
+
+	if (!strncmp(ifname, "phy", 3))
+		phyidx = atoi(&ifname[3]);
+	else if (!strncmp(ifname, "radio", 5))
+		phyidx = atoi(&ifname[5]);
+	else if (!strncmp(ifname, "mon.", 4))
+		ifidx = if_nametoindex(&ifname[4]);
+	else
+		ifidx = if_nametoindex(ifname);
+
+	if ((ifidx < 0) && (phyidx < 0))
+		return NULL;
+
+	cv = nl80211_new(nls->nl80211, cmd, flags);
+	if (!cv)
+		return NULL;
+
+	if (ifidx > -1)
+		NLA_PUT_U32(cv->msg, NL80211_ATTR_IFINDEX, ifidx);
+
+	if (phyidx > -1)
+		NLA_PUT_U32(cv->msg, NL80211_ATTR_WIPHY, phyidx);
+
+	return cv;
+
+nla_put_failure:
+	nl80211_free(cv);
+	return NULL;
+}
+
 static struct nl80211_msg_conveyor * nl80211_send(
 	struct nl80211_msg_conveyor *cv,
 	int (*cb_func)(struct nl_msg *, void *), void *cb_arg
@@ -215,20 +244,111 @@
 	static struct nlattr *attr[NL80211_ATTR_MAX + 1];
 
 	nla_parse(attr, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
-		genlmsg_attrlen(gnlh, 0), NULL);
+	          genlmsg_attrlen(gnlh, 0), NULL);
 
 	return attr;
 }
 
+
+static int nl80211_subscribe_cb(struct nl_msg *msg, void *arg)
+{
+	struct nl80211_group_conveyor *cv = arg;
+
+	struct nlattr **attr = nl80211_parse(msg);
+	struct nlattr *mgrpinfo[CTRL_ATTR_MCAST_GRP_MAX + 1];
+	struct nlattr *mgrp;
+	int mgrpidx;
+
+	if (!attr[CTRL_ATTR_MCAST_GROUPS])
+		return NL_SKIP;
+
+	nla_for_each_nested(mgrp, attr[CTRL_ATTR_MCAST_GROUPS], mgrpidx)
+	{
+		nla_parse(mgrpinfo, CTRL_ATTR_MCAST_GRP_MAX,
+		          nla_data(mgrp), nla_len(mgrp), NULL);
+
+		if (mgrpinfo[CTRL_ATTR_MCAST_GRP_ID] &&
+		    mgrpinfo[CTRL_ATTR_MCAST_GRP_NAME] &&
+		    !strncmp(nla_data(mgrpinfo[CTRL_ATTR_MCAST_GRP_NAME]),
+		             cv->name, nla_len(mgrpinfo[CTRL_ATTR_MCAST_GRP_NAME])))
+		{
+			cv->id = nla_get_u32(mgrpinfo[CTRL_ATTR_MCAST_GRP_ID]);
+			break;
+		}
+	}
+
+	return NL_SKIP;
+}
+
+static int nl80211_subscribe(const char *family, const char *group)
+{
+	struct nl80211_group_conveyor cv = { .name = group, .id = -ENOENT };
+	struct nl80211_msg_conveyor *req;
+
+	req = nl80211_ctl(CTRL_CMD_GETFAMILY, 0);
+	if (req)
+	{
+		NLA_PUT_STRING(req->msg, CTRL_ATTR_FAMILY_NAME, family);
+		nl80211_send(req, nl80211_subscribe_cb, &cv);
+
+nla_put_failure:
+		nl80211_free(req);
+	}
+
+	return nl_socket_add_membership(nls->nl_sock, cv.id);
+}
+
+
+static int nl80211_wait_cb(struct nl_msg *msg, void *arg)
+{
+	struct nl80211_event_conveyor *cv = arg;
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+
+	if (gnlh->cmd == cv->wait)
+		cv->recv = gnlh->cmd;
+
+	return NL_SKIP;
+}
+
+static int nl80211_wait_seq_check(struct nl_msg *msg, void *arg)
+{
+	return NL_OK;
+}
+
+static int nl80211_wait(const char *family, const char *group, int cmd)
+{
+	struct nl80211_event_conveyor cv = { .wait = cmd };
+	struct nl_cb *cb;
+
+	if (nl80211_subscribe(family, group))
+		return -ENOENT;
+
+	cb = nl_cb_alloc(NL_CB_DEFAULT);
+
+ 	if (!cb)
+		return -ENOMEM;
+
+	nl_cb_set(cb, NL_CB_SEQ_CHECK, NL_CB_CUSTOM, nl80211_wait_seq_check, NULL);
+	nl_cb_set(cb, NL_CB_VALID,     NL_CB_CUSTOM, nl80211_wait_cb,        &cv );
+
+	while (!cv.recv)
+		nl_recvmsgs(nls->nl_sock, cb);
+
+	nl_cb_put(cb);
+
+	return 0;
+}
+
+
 static int nl80211_freq2channel(int freq)
 {
-    if (freq == 2484)
-        return 14;
+	if (freq == 2484)
+		return 14;
 
-    if (freq < 2484)
-        return (freq - 2407) / 5;
+	if (freq < 2484)
+		return (freq - 2407) / 5;
 
-    return (freq / 5) - 1000;
+	return (freq / 5) - 1000;
 }
 
 static char * nl80211_getval(const char *ifname, const char *buf, const char *key)
@@ -285,7 +405,8 @@
 	struct nlattr **attr = nl80211_parse(msg);
 
 	if (attr[NL80211_ATTR_WIPHY_NAME])
-		sprintf(buf, "%s", nla_data(attr[NL80211_ATTR_WIPHY_NAME]));
+		memcpy(buf, nla_data(attr[NL80211_ATTR_WIPHY_NAME]),
+		       nla_len(attr[NL80211_ATTR_WIPHY_NAME]));
 	else
 		buf[0] = 0;
 
@@ -380,8 +501,8 @@
 		goto out;
 
 	local.sun_family = AF_UNIX;
-	local_length = sizeof(local.sun_family) + sprintf(local.sun_path,
-		"/var/run/iwinfo-%s-%d", ifname, getpid());
+	local_length = sizeof(local.sun_family) +
+		sprintf(local.sun_path, "/var/run/iwinfo-%s-%d", ifname, getpid());
 
 	if (bind(sock, (struct sockaddr *) &local, local_length))
 		goto out;
@@ -462,18 +583,18 @@
 	{
 		if ((d = opendir("/sys/class/net")) != NULL)
 		{
-			while( (e = readdir(d)) != NULL )
+			while ((e = readdir(d)) != NULL)
 			{
 				snprintf(buffer, sizeof(buffer),
-					"/sys/class/net/%s/phy80211/index", e->d_name);
+				         "/sys/class/net/%s/phy80211/index", e->d_name);
 
 				if (nl80211_readint(buffer) == phyidx)
 				{
 					snprintf(buffer, sizeof(buffer),
-						"/sys/class/net/%s/ifindex", e->d_name);
+					         "/sys/class/net/%s/ifindex", e->d_name);
 
-					if( (cifidx = nl80211_readint(buffer)) >= 0 &&
-					    ((ifidx < 0) || (cifidx < ifidx)) )
+					if ((cifidx = nl80211_readint(buffer)) >= 0 &&
+					    ((ifidx < 0) || (cifidx < ifidx)))
 					{
 						ifidx = cifidx;
 						strncpy(nif, e->d_name, sizeof(nif));
@@ -562,8 +683,8 @@
 {
 	if (nls)
 	{
-                if (nls->nl80211)
-                        genl_family_put(nls->nl80211);
+		if (nls->nlctrl)
+			genl_family_put(nls->nlctrl);
 
 		if (nls->nl80211)
 			genl_family_put(nls->nl80211);
@@ -579,7 +700,7 @@
 	}
 }
 
-int nl80211_get_mode(const char *ifname, char *buf)
+int nl80211_get_mode(const char *ifname, int *buf)
 {
 	return wext_get_mode(ifname, buf);
 }
@@ -592,8 +713,8 @@
 	{
 		return 0;
 	}
-	else if( (ssid = nl80211_hostapd_info(ifname)) &&
-	         (ssid = nl80211_getval(ifname, ssid, "ssid")) )
+	else if ((ssid = nl80211_hostapd_info(ifname)) &&
+	         (ssid = nl80211_getval(ifname, ssid, "ssid")))
 	{
 		memcpy(buf, ssid, strlen(ssid));
 		return 0;
@@ -611,7 +732,7 @@
 	{
 		return 0;
 	}
-	else if((bssid = nl80211_hostapd_info(ifname)) &&
+	else if ((bssid = nl80211_hostapd_info(ifname)) &&
 	         (bssid = nl80211_getval(ifname, bssid, "bssid")))
 	{
 		mac[0] = strtol(&bssid[0],  NULL, 16);
@@ -622,7 +743,7 @@
 		mac[5] = strtol(&bssid[15], NULL, 16);
 
 		sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
-			mac[0], mac[1], mac[2],	mac[3], mac[4], mac[5]);
+		        mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
 
 		return 0;
 	}
@@ -693,8 +814,8 @@
 
 	if (attr[NL80211_ATTR_STA_INFO])
 	{
-		if( !nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
-				attr[NL80211_ATTR_STA_INFO], stats_policy) )
+		if (!nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
+		                      attr[NL80211_ATTR_STA_INFO], stats_policy))
 		{
 			if (sinfo[NL80211_STA_INFO_SIGNAL])
 			{
@@ -704,8 +825,9 @@
 
 			if (sinfo[NL80211_STA_INFO_TX_BITRATE])
 			{
-				if( !nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
-						sinfo[NL80211_STA_INFO_TX_BITRATE], rate_policy) )
+				if (!nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
+				                      sinfo[NL80211_STA_INFO_TX_BITRATE],
+				                      rate_policy))
 				{
 					if (rinfo[NL80211_RATE_INFO_BITRATE])
 					{
@@ -735,11 +857,11 @@
 		while ((de = readdir(d)) != NULL)
 		{
 			if (!strncmp(de->d_name, ifname, strlen(ifname)) &&
-				(!de->d_name[strlen(ifname)] ||
-				 !strncmp(&de->d_name[strlen(ifname)], ".sta", 4)))
+			    (!de->d_name[strlen(ifname)] ||
+			     !strncmp(&de->d_name[strlen(ifname)], ".sta", 4)))
 			{
 				req = nl80211_msg(de->d_name, NL80211_CMD_GET_STATION,
-								  NLM_F_DUMP);
+				                  NLM_F_DUMP);
 
 				if (req)
 				{
@@ -804,7 +926,7 @@
 		return NL_SKIP;
 
 	if (nla_parse_nested(si, NL80211_SURVEY_INFO_MAX,
-						 tb[NL80211_ATTR_SURVEY_INFO], sp))
+	                     tb[NL80211_ATTR_SURVEY_INFO], sp))
 		return NL_SKIP;
 
 	if (!si[NL80211_SURVEY_INFO_NOISE])
@@ -893,8 +1015,8 @@
 	struct iwinfo_crypto_entry *c = (struct iwinfo_crypto_entry *)buf;
 
 	/* WPA supplicant */
-	if( (res = nl80211_wpactl_info(ifname, "STATUS", NULL)) &&
-	    (val = nl80211_getval(NULL, res, "pairwise_cipher")) )
+	if ((res = nl80211_wpactl_info(ifname, "STATUS", NULL)) &&
+	    (val = nl80211_getval(NULL, res, "pairwise_cipher")))
 	{
 		/* WEP */
 		if (strstr(val, "WEP"))
@@ -1024,7 +1146,7 @@
 					break;
 			}
 
-			for( i = 0; i < 4; i++ )
+			for (i = 0; i < 4; i++)
 			{
 				snprintf(k, sizeof(k), "wep_key%d", i);
 
@@ -1055,33 +1177,81 @@
 	struct iwinfo_assoclist_entry *e = arr->buf;
 	struct nlattr **attr = nl80211_parse(msg);
 	struct nlattr *sinfo[NL80211_STA_INFO_MAX + 1];
+	struct nlattr *rinfo[NL80211_RATE_INFO_MAX + 1];
 
 	static struct nla_policy stats_policy[NL80211_STA_INFO_MAX + 1] = {
 		[NL80211_STA_INFO_INACTIVE_TIME] = { .type = NLA_U32    },
-		[NL80211_STA_INFO_RX_BYTES]      = { .type = NLA_U32    },
-		[NL80211_STA_INFO_TX_BYTES]      = { .type = NLA_U32    },
 		[NL80211_STA_INFO_RX_PACKETS]    = { .type = NLA_U32    },
 		[NL80211_STA_INFO_TX_PACKETS]    = { .type = NLA_U32    },
-		[NL80211_STA_INFO_SIGNAL]        = { .type = NLA_U8     },
+		[NL80211_STA_INFO_RX_BITRATE]    = { .type = NLA_NESTED },
 		[NL80211_STA_INFO_TX_BITRATE]    = { .type = NLA_NESTED },
-		[NL80211_STA_INFO_LLID]          = { .type = NLA_U16    },
-		[NL80211_STA_INFO_PLID]          = { .type = NLA_U16    },
-		[NL80211_STA_INFO_PLINK_STATE]   = { .type = NLA_U8     },
+		[NL80211_STA_INFO_SIGNAL]        = { .type = NLA_U8     },
+	};
+
+	static struct nla_policy rate_policy[NL80211_RATE_INFO_MAX + 1] = {
+		[NL80211_RATE_INFO_BITRATE]      = { .type = NLA_U16    },
+		[NL80211_RATE_INFO_MCS]          = { .type = NLA_U8     },
+		[NL80211_RATE_INFO_40_MHZ_WIDTH] = { .type = NLA_FLAG   },
+		[NL80211_RATE_INFO_SHORT_GI]     = { .type = NLA_FLAG   },
 	};
 
 	/* advance to end of array */
 	e += arr->count;
+	memset(e, 0, sizeof(*e));
 
 	if (attr[NL80211_ATTR_MAC])
 		memcpy(e->mac, nla_data(attr[NL80211_ATTR_MAC]), 6);
 
-	if (attr[NL80211_ATTR_STA_INFO])
+	if (attr[NL80211_ATTR_STA_INFO] &&
+	    !nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
+	                      attr[NL80211_ATTR_STA_INFO], stats_policy))
 	{
-		if (!nla_parse_nested(sinfo, NL80211_STA_INFO_MAX,
-				attr[NL80211_ATTR_STA_INFO], stats_policy))
+		if (sinfo[NL80211_STA_INFO_SIGNAL])
+			e->signal = nla_get_u8(sinfo[NL80211_STA_INFO_SIGNAL]);
+
+		if (sinfo[NL80211_STA_INFO_INACTIVE_TIME])
+			e->inactive = nla_get_u32(sinfo[NL80211_STA_INFO_INACTIVE_TIME]);
+
+		if (sinfo[NL80211_STA_INFO_RX_PACKETS])
+			e->rx_packets = nla_get_u32(sinfo[NL80211_STA_INFO_RX_PACKETS]);
+
+		if (sinfo[NL80211_STA_INFO_TX_PACKETS])
+			e->tx_packets = nla_get_u32(sinfo[NL80211_STA_INFO_TX_PACKETS]);
+
+		if (sinfo[NL80211_STA_INFO_RX_BITRATE] &&
+		    !nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
+		                      sinfo[NL80211_STA_INFO_RX_BITRATE], rate_policy))
 		{
-			if (sinfo[NL80211_STA_INFO_SIGNAL])
-				e->signal = nla_get_u8(sinfo[NL80211_STA_INFO_SIGNAL]);
+			if (rinfo[NL80211_RATE_INFO_BITRATE])
+				e->rx_rate.rate =
+					nla_get_u16(rinfo[NL80211_RATE_INFO_BITRATE]) * 100;
+
+			if (rinfo[NL80211_RATE_INFO_MCS])
+				e->rx_rate.mcs = nla_get_u8(rinfo[NL80211_RATE_INFO_MCS]);
+
+			if (rinfo[NL80211_RATE_INFO_40_MHZ_WIDTH])
+				e->rx_rate.is_40mhz = 1;
+
+			if (rinfo[NL80211_RATE_INFO_SHORT_GI])
+				e->rx_rate.is_short_gi = 1;
+		}
+
+		if (sinfo[NL80211_STA_INFO_TX_BITRATE] &&
+		    !nla_parse_nested(rinfo, NL80211_RATE_INFO_MAX,
+		                      sinfo[NL80211_STA_INFO_TX_BITRATE], rate_policy))
+		{
+			if (rinfo[NL80211_RATE_INFO_BITRATE])
+				e->tx_rate.rate =
+					nla_get_u16(rinfo[NL80211_RATE_INFO_BITRATE]) * 100;
+
+			if (rinfo[NL80211_RATE_INFO_MCS])
+				e->tx_rate.mcs = nla_get_u8(rinfo[NL80211_RATE_INFO_MCS]);
+
+			if (rinfo[NL80211_RATE_INFO_40_MHZ_WIDTH])
+				e->tx_rate.is_40mhz = 1;
+
+			if (rinfo[NL80211_RATE_INFO_SHORT_GI])
+				e->tx_rate.is_short_gi = 1;
 		}
 	}
 
@@ -1105,19 +1275,17 @@
 		while ((de = readdir(d)) != NULL)
 		{
 			if (!strncmp(de->d_name, ifname, strlen(ifname)) &&
-				(!de->d_name[strlen(ifname)] ||
-				 !strncmp(&de->d_name[strlen(ifname)], ".sta", 4)))
+			    (!de->d_name[strlen(ifname)] ||
+			     !strncmp(&de->d_name[strlen(ifname)], ".sta", 4)))
 			{
 				req = nl80211_msg(de->d_name, NL80211_CMD_GET_STATION,
-								  NLM_F_DUMP);
+				                  NLM_F_DUMP);
 
 				if (req)
 				{
 					nl80211_send(req, nl80211_get_assoclist_cb, &arr);
 					nl80211_free(req);
 				}
-
-				break;
 			}
 		}
 
@@ -1159,19 +1327,18 @@
 	nla_for_each_nested(band, attr[NL80211_ATTR_WIPHY_BANDS], bands_remain)
 	{
 		nla_parse(bands, NL80211_BAND_ATTR_MAX, nla_data(band),
-			  nla_len(band), NULL);
+		          nla_len(band), NULL);
 
-		nla_for_each_nested(freq,
-			bands[NL80211_BAND_ATTR_FREQS], freqs_remain)
+		nla_for_each_nested(freq, bands[NL80211_BAND_ATTR_FREQS], freqs_remain)
 		{
 			nla_parse(freqs, NL80211_FREQUENCY_ATTR_MAX,
-				nla_data(freq), nla_len(freq), freq_policy);
+			          nla_data(freq), nla_len(freq), freq_policy);
 
-			ch_cmp = nl80211_freq2channel(
-				nla_get_u32(freqs[NL80211_FREQUENCY_ATTR_FREQ]));
+			ch_cmp = nl80211_freq2channel(nla_get_u32(
+				freqs[NL80211_FREQUENCY_ATTR_FREQ]));
 
-			if( (!ch_cur || (ch_cmp == ch_cur)) &&
-				freqs[NL80211_FREQUENCY_ATTR_MAX_TX_POWER] )
+			if ((!ch_cur || (ch_cmp == ch_cur)) &&
+			    freqs[NL80211_FREQUENCY_ATTR_MAX_TX_POWER])
 			{
 				*dbm_max = (int)(0.01 * nla_get_u32(
 					freqs[NL80211_FREQUENCY_ATTR_MAX_TX_POWER]));
@@ -1279,6 +1446,151 @@
 	}
 }
 
+
+struct nl80211_scanlist {
+	struct iwinfo_scanlist_entry *e;
+	int len;
+};
+
+
+static void nl80211_get_scanlist_ie(struct nlattr **bss,
+                                    struct iwinfo_scanlist_entry *e)
+{
+	int ielen = nla_len(bss[NL80211_BSS_INFORMATION_ELEMENTS]);
+	unsigned char *ie = nla_data(bss[NL80211_BSS_INFORMATION_ELEMENTS]);
+	static unsigned char ms_oui[3] = { 0x00, 0x50, 0xf2 };
+
+	while (ielen >= 2 && ielen >= ie[1])
+	{
+		switch (ie[0])
+		{
+		case 0: /* SSID */
+			memcpy(e->ssid, ie + 2, min(ie[1], IWINFO_ESSID_MAX_SIZE));
+			break;
+
+		case 48: /* RSN */
+			iwinfo_parse_rsn(&e->crypto, ie + 2, ie[1],
+			                 IWINFO_CIPHER_CCMP, IWINFO_KMGMT_8021x);
+			break;
+
+		case 221: /* Vendor */
+			if (ie[1] >= 4 && !memcmp(ie + 2, ms_oui, 3) && ie[5] == 1)
+				iwinfo_parse_rsn(&e->crypto, ie + 6, ie[1] - 4,
+				                 IWINFO_CIPHER_TKIP, IWINFO_KMGMT_PSK);
+			break;
+		}
+
+		ielen -= ie[1] + 2;
+		ie += ie[1] + 2;
+	}
+}
+
+static int nl80211_get_scanlist_cb(struct nl_msg *msg, void *arg)
+{
+	int8_t rssi;
+	uint16_t caps;
+
+	struct nl80211_scanlist *sl = arg;
+	struct nlattr **tb = nl80211_parse(msg);
+	struct nlattr *bss[NL80211_BSS_MAX + 1];
+
+	static struct nla_policy bss_policy[NL80211_BSS_MAX + 1] = {
+		[NL80211_BSS_TSF]                  = { .type = NLA_U64 },
+		[NL80211_BSS_FREQUENCY]            = { .type = NLA_U32 },
+		[NL80211_BSS_BSSID]                = {                 },
+		[NL80211_BSS_BEACON_INTERVAL]      = { .type = NLA_U16 },
+		[NL80211_BSS_CAPABILITY]           = { .type = NLA_U16 },
+		[NL80211_BSS_INFORMATION_ELEMENTS] = {                 },
+		[NL80211_BSS_SIGNAL_MBM]           = { .type = NLA_U32 },
+		[NL80211_BSS_SIGNAL_UNSPEC]        = { .type = NLA_U8  },
+		[NL80211_BSS_STATUS]               = { .type = NLA_U32 },
+		[NL80211_BSS_SEEN_MS_AGO]          = { .type = NLA_U32 },
+		[NL80211_BSS_BEACON_IES]           = {                 },
+	};
+
+	if (!tb[NL80211_ATTR_BSS] ||
+		nla_parse_nested(bss, NL80211_BSS_MAX, tb[NL80211_ATTR_BSS],
+		                 bss_policy) ||
+		!bss[NL80211_BSS_BSSID])
+	{
+		return NL_SKIP;
+	}
+
+	if (bss[NL80211_BSS_CAPABILITY])
+		caps = nla_get_u16(bss[NL80211_BSS_CAPABILITY]);
+	else
+		caps = 0;
+
+	memset(sl->e, 0, sizeof(*sl->e));
+	memcpy(sl->e->mac, nla_data(bss[NL80211_BSS_BSSID]), 6);
+
+	if (caps & (1<<1))
+		sl->e->mode = IWINFO_OPMODE_ADHOC;
+	else
+		sl->e->mode = IWINFO_OPMODE_MASTER;
+
+	if (caps & (1<<4))
+		sl->e->crypto.enabled = 1;
+
+	if (bss[NL80211_BSS_FREQUENCY])
+		sl->e->channel = nl80211_freq2channel(nla_get_u32(
+			bss[NL80211_BSS_FREQUENCY]));
+
+	if (bss[NL80211_BSS_INFORMATION_ELEMENTS])
+		nl80211_get_scanlist_ie(bss, sl->e);
+
+	if (bss[NL80211_BSS_SIGNAL_MBM])
+	{
+		sl->e->signal = nla_get_u32(bss[NL80211_BSS_SIGNAL_MBM]) / 100;
+
+		rssi = sl->e->signal - 0x100;
+
+		if (rssi < -110)
+			rssi = -110;
+		else if (rssi > -40)
+			rssi = -40;
+
+		sl->e->quality = (rssi + 110);
+		sl->e->quality_max = 70;
+	}
+
+	if (sl->e->crypto.enabled && !sl->e->crypto.wpa_version)
+	{
+		sl->e->crypto.auth_algs    = IWINFO_AUTH_OPEN | IWINFO_AUTH_SHARED;
+		sl->e->crypto.pair_ciphers = IWINFO_CIPHER_WEP40 | IWINFO_CIPHER_WEP104;
+	}
+
+	sl->e++;
+	sl->len++;
+
+	return NL_SKIP;
+}
+
+static int nl80211_get_scanlist_nl(const char *ifname, char *buf, int *len)
+{
+	struct nl80211_msg_conveyor *req;
+	struct nl80211_scanlist sl = { .e = (struct iwinfo_scanlist_entry *)buf };
+
+	req = nl80211_msg(ifname, NL80211_CMD_TRIGGER_SCAN, 0);
+	if (req)
+	{
+		nl80211_send(req, NULL, NULL);
+		nl80211_free(req);
+	}
+
+	nl80211_wait("nl80211", "scan", NL80211_CMD_NEW_SCAN_RESULTS);
+
+	req = nl80211_msg(ifname, NL80211_CMD_GET_SCAN, NLM_F_DUMP);
+	if (req)
+	{
+		nl80211_send(req, nl80211_get_scanlist_cb, &sl);
+		nl80211_free(req);
+	}
+
+	*len = sl.len * sizeof(struct iwinfo_scanlist_entry);
+	return *len ? 0 : -1;
+}
+
 int nl80211_get_scanlist(const char *ifname, char *buf, int *len)
 {
 	int freq, rssi, qmax, count;
@@ -1315,12 +1627,12 @@
 			nl80211_get_quality_max(ifname, &qmax);
 
 			/* skip header line */
-			while( *res++ != '\n' );
+			while (*res++ != '\n');
 
 			count = 0;
 
-			while( sscanf(res, "%17s %d %d %255s%*[ \t]%127[^\n]\n",
-			              bssid, &freq, &rssi, cipher, ssid) > 0 )
+			while (sscanf(res, "%17s %d %d %255s%*[ \t]%127[^\n]\n",
+			              bssid, &freq, &rssi, cipher, ssid) > 0)
 			{
 				/* BSSID */
 				e->mac[0] = strtol(&bssid[0],  NULL, 16);
@@ -1331,11 +1643,10 @@
 				e->mac[5] = strtol(&bssid[15], NULL, 16);
 
 				/* SSID */
-				memcpy(e->ssid, ssid,
-					min(strlen(ssid), sizeof(e->ssid) - 1));
+				memcpy(e->ssid, ssid, min(strlen(ssid), sizeof(e->ssid) - 1));
 
 				/* Mode (assume master) */
-				sprintf((char *)e->mode, "Master");
+				e->mode = IWINFO_OPMODE_MASTER;
 
 				/* Channel */
 				e->channel = nl80211_freq2channel(freq);
@@ -1368,7 +1679,7 @@
 				nl80211_get_scancrypto(cipher, &e->crypto);
 
 				/* advance to next line */
-				while( *res && *res++ != '\n' );
+				while (*res && *res++ != '\n');
 
 				count++;
 				e++;
@@ -1392,7 +1703,7 @@
 			if (!iwinfo_ifup(ifname))
 				return -1;
 
-			wext_get_scanlist(ifname, buf, len);
+			nl80211_get_scanlist_nl(ifname, buf, len);
 			iwinfo_ifdown(ifname);
 			return 0;
 		}
@@ -1410,7 +1721,7 @@
 			 * additional interface and there's no need to tear down the ap */
 			if (iwinfo_ifup(res))
 			{
-				wext_get_scanlist(res, buf, len);
+				nl80211_get_scanlist_nl(res, buf, len);
 				iwinfo_ifdown(res);
 			}
 
@@ -1418,7 +1729,7 @@
 			 * during scan */
 			else if (iwinfo_ifdown(ifname) && iwinfo_ifup(res))
 			{
-				wext_get_scanlist(res, buf, len);
+				nl80211_get_scanlist_nl(res, buf, len);
 				iwinfo_ifdown(res);
 				iwinfo_ifup(ifname);
 				nl80211_hostapd_hup(ifname);
@@ -1456,17 +1767,16 @@
 
 	nla_for_each_nested(band, attr[NL80211_ATTR_WIPHY_BANDS], bands_remain)
 	{
-		nla_parse(bands, NL80211_BAND_ATTR_MAX, nla_data(band),
-			nla_len(band), NULL);
+		nla_parse(bands, NL80211_BAND_ATTR_MAX,
+		          nla_data(band), nla_len(band), NULL);
 
-		nla_for_each_nested(freq,
-			bands[NL80211_BAND_ATTR_FREQS], freqs_remain)
+		nla_for_each_nested(freq, bands[NL80211_BAND_ATTR_FREQS], freqs_remain)
 		{
 			nla_parse(freqs, NL80211_FREQUENCY_ATTR_MAX,
-				nla_data(freq), nla_len(freq), NULL);
+			          nla_data(freq), nla_len(freq), NULL);
 
-			if( !freqs[NL80211_FREQUENCY_ATTR_FREQ] ||
-				freqs[NL80211_FREQUENCY_ATTR_DISABLED] )
+			if (!freqs[NL80211_FREQUENCY_ATTR_FREQ] ||
+			    freqs[NL80211_FREQUENCY_ATTR_DISABLED])
 				continue;
 
 			e->mhz = nla_get_u32(freqs[NL80211_FREQUENCY_ATTR_FREQ]);
@@ -1544,7 +1854,7 @@
 	struct iwinfo_country_entry *e = (struct iwinfo_country_entry *)buf;
 	const struct iwinfo_iso3166_label *l;
 
-	for( l = IWINFO_ISO3166_NAMES, count = 0; l->iso3166; l++, e++, count++ )
+	for (l = IWINFO_ISO3166_NAMES, count = 0; l->iso3166; l++, e++, count++)
 	{
 		e->iso3166 = l->iso3166;
 		e->ccode[0] = (l->iso3166 / 256);
@@ -1571,8 +1881,8 @@
 	{
 		nla_for_each_nested(band, attr[NL80211_ATTR_WIPHY_BANDS], bands_remain)
 		{
-			nla_parse(bands, NL80211_BAND_ATTR_MAX, nla_data(band),
-				nla_len(band), NULL);
+			nla_parse(bands, NL80211_BAND_ATTR_MAX,
+			          nla_data(band), nla_len(band), NULL);
 
 			if (bands[NL80211_BAND_ATTR_HT_CAPA])
 				caps = nla_get_u16(bands[NL80211_BAND_ATTR_HT_CAPA]);
@@ -1581,11 +1891,11 @@
 			if (caps > 0)
 				*modes |= IWINFO_80211_N;
 
-			nla_for_each_nested(freq,
-				bands[NL80211_BAND_ATTR_FREQS], freqs_remain)
+			nla_for_each_nested(freq, bands[NL80211_BAND_ATTR_FREQS],
+			                    freqs_remain)
 			{
 				nla_parse(freqs, NL80211_FREQUENCY_ATTR_MAX,
-					nla_data(freq), nla_len(freq), NULL);
+				          nla_data(freq), nla_len(freq), NULL);
 
 				if (!freqs[NL80211_FREQUENCY_ATTR_FREQ])
 					continue;
@@ -1637,3 +1947,83 @@
 
 	return -1;
 }
+
+int nl80211_get_hardware_id(const char *ifname, char *buf)
+{
+	int rv;
+	char *res;
+
+	/* Got a radioX pseudo interface, find some interface on it or create one */
+	if (!strncmp(ifname, "radio", 5))
+	{
+		/* Reuse existing interface */
+		if ((res = nl80211_phy2ifname(ifname)) != NULL)
+		{
+			rv = wext_get_hardware_id(res, buf);
+		}
+
+		/* Need to spawn a temporary iface for finding IDs */
+		else if ((res = nl80211_ifadd(ifname)) != NULL)
+		{
+			rv = wext_get_hardware_id(res, buf);
+			nl80211_ifdel(res);
+		}
+	}
+	else
+	{
+		rv = wext_get_hardware_id(ifname, buf);
+	}
+
+	/* Failed to obtain hardware IDs, search board config */
+	if (rv)
+	{
+		rv = iwinfo_hardware_id_from_mtd((struct iwinfo_hardware_id *)buf);
+	}
+
+	return rv;
+}
+
+static const struct iwinfo_hardware_entry *
+nl80211_get_hardware_entry(const char *ifname)
+{
+	struct iwinfo_hardware_id id;
+
+	if (nl80211_get_hardware_id(ifname, (char *)&id))
+		return NULL;
+
+	return iwinfo_hardware(&id);
+}
+
+int nl80211_get_hardware_name(const char *ifname, char *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = nl80211_get_hardware_entry(ifname)))
+		sprintf(buf, "Generic MAC80211");
+	else
+		sprintf(buf, "%s %s", hw->vendor_name, hw->device_name);
+
+	return 0;
+}
+
+int nl80211_get_txpower_offset(const char *ifname, int *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = nl80211_get_hardware_entry(ifname)))
+		return -1;
+
+	*buf = hw->txpower_offset;
+	return 0;
+}
+
+int nl80211_get_frequency_offset(const char *ifname, int *buf)
+{
+	const struct iwinfo_hardware_entry *hw;
+
+	if (!(hw = nl80211_get_hardware_entry(ifname)))
+		return -1;
+
+	*buf = hw->frequency_offset;
+	return 0;
+}
diff -Nru -x .svn package/iwinfo/src/iwinfo_utils.c package/iwinfo/src/iwinfo_utils.c
--- package/iwinfo/src/iwinfo_utils.c	2012-01-13 22:34:25.151006895 +0100
+++ package/iwinfo/src/iwinfo_utils.c	2012-02-25 18:58:52.335897238 +0100
@@ -124,3 +124,203 @@
 	if( ioctl_socket > -1 )
 		close(ioctl_socket);
 }
+
+struct iwinfo_hardware_entry * iwinfo_hardware(struct iwinfo_hardware_id *id)
+{
+	const struct iwinfo_hardware_entry *e;
+
+	for (e = IWINFO_HARDWARE_ENTRIES; e->vendor_name; e++)
+	{
+		if ((e->vendor_id != 0xffff) && (e->vendor_id != id->vendor_id))
+			continue;
+
+		if ((e->device_id != 0xffff) && (e->device_id != id->device_id))
+			continue;
+
+		if ((e->subsystem_vendor_id != 0xffff) &&
+			(e->subsystem_vendor_id != id->subsystem_vendor_id))
+			continue;
+
+		if ((e->subsystem_device_id != 0xffff) &&
+			(e->subsystem_device_id != id->subsystem_device_id))
+			continue;
+
+		return (struct iwinfo_hardware_entry *)e;
+	}
+
+	return NULL;
+}
+
+int iwinfo_hardware_id_from_mtd(struct iwinfo_hardware_id *id)
+{
+	FILE *mtd;
+	uint16_t *bc;
+
+	int fd, len, off;
+	char buf[128];
+
+	if (!(mtd = fopen("/proc/mtd", "r")))
+		return -1;
+
+	while (fgets(buf, sizeof(buf), mtd) > 0)
+	{
+		if (fscanf(mtd, "mtd%d: %*x %x %127s", &off, &len, buf) < 3 ||
+		    (strcmp(buf, "\"boardconfig\"") && strcmp(buf, "\"EEPROM\"")))
+		{
+			off = -1;
+			continue;
+		}
+
+		break;
+	}
+
+	fclose(mtd);
+
+	if (off < 0)
+		return -1;
+
+	snprintf(buf, sizeof(buf), "/dev/mtdblock%d", off);
+
+	if ((fd = open(buf, O_RDONLY)) < 0)
+		return -1;
+
+	bc = mmap(NULL, len, PROT_READ, MAP_PRIVATE|MAP_LOCKED, fd, 0);
+
+	if ((void *)bc != MAP_FAILED)
+	{
+		id->vendor_id = 0;
+		id->device_id = 0;
+
+		for (off = len / 2 - 0x800; off >= 0; off -= 0x800)
+		{
+			/* AR531X board data magic */
+			if ((bc[off] == 0x3533) && (bc[off + 1] == 0x3131))
+			{
+				id->vendor_id = bc[off + 0x7d];
+				id->device_id = bc[off + 0x7c];
+				id->subsystem_vendor_id = bc[off + 0x84];
+				id->subsystem_device_id = bc[off + 0x83];
+				break;
+			}
+
+			/* AR5416 EEPROM magic */
+			else if ((bc[off] == 0xA55A) || (bc[off] == 0x5AA5))
+			{
+				id->vendor_id = bc[off + 0x0D];
+				id->device_id = bc[off + 0x0E];
+				id->subsystem_vendor_id = bc[off + 0x13];
+				id->subsystem_device_id = bc[off + 0x14];
+				break;
+			}
+		}
+
+		munmap(bc, len);
+	}
+
+	close(fd);
+
+	return (id->vendor_id && id->device_id) ? 0 : -1;
+}
+
+void iwinfo_parse_rsn(struct iwinfo_crypto_entry *c, uint8_t *data, uint8_t len,
+					  uint8_t defcipher, uint8_t defauth)
+{
+	uint16_t i, count;
+
+	static unsigned char ms_oui[3]        = { 0x00, 0x50, 0xf2 };
+	static unsigned char ieee80211_oui[3] = { 0x00, 0x0f, 0xac };
+
+	data += 2;
+	len -= 2;
+
+	if (!memcmp(data, ms_oui, 3))
+		c->wpa_version += 1;
+	else if (!memcmp(data, ieee80211_oui, 3))
+		c->wpa_version += 2;
+
+	if (len < 4)
+	{
+		c->group_ciphers |= defcipher;
+		c->pair_ciphers  |= defcipher;
+		c->auth_suites   |= defauth;
+		return;
+	}
+
+	if (!memcmp(data, ms_oui, 3) || !memcmp(data, ieee80211_oui, 3))
+	{
+		switch (data[3])
+		{
+			case 1: c->group_ciphers |= IWINFO_CIPHER_WEP40;  break;
+			case 2: c->group_ciphers |= IWINFO_CIPHER_TKIP;   break;
+			case 4: c->group_ciphers |= IWINFO_CIPHER_CCMP;   break;
+			case 5: c->group_ciphers |= IWINFO_CIPHER_WEP104; break;
+			case 6:  /* AES-128-CMAC */ break;
+			default: /* proprietary */  break;
+		}
+	}
+
+	data += 4;
+	len -= 4;
+
+	if (len < 2)
+	{
+		c->pair_ciphers |= defcipher;
+		c->auth_suites  |= defauth;
+		return;
+	}
+
+	count = data[0] | (data[1] << 8);
+	if (2 + (count * 4) > len)
+		return;
+
+	for (i = 0; i < count; i++)
+	{
+		if (!memcmp(data + 2 + (i * 4), ms_oui, 3) ||
+			!memcmp(data + 2 + (i * 4), ieee80211_oui, 3))
+		{
+			switch (data[2 + (i * 4) + 3])
+			{
+				case 1: c->pair_ciphers |= IWINFO_CIPHER_WEP40;  break;
+				case 2: c->pair_ciphers |= IWINFO_CIPHER_TKIP;   break;
+				case 4: c->pair_ciphers |= IWINFO_CIPHER_CCMP;   break;
+				case 5: c->pair_ciphers |= IWINFO_CIPHER_WEP104; break;
+				case 6:  /* AES-128-CMAC */ break;
+				default: /* proprietary */  break;
+			}
+		}
+	}
+
+	data += 2 + (count * 4);
+	len -= 2 + (count * 4);
+
+	if (len < 2)
+	{
+		c->auth_suites |= defauth;
+		return;
+	}
+
+	count = data[0] | (data[1] << 8);
+	if (2 + (count * 4) > len)
+		return;
+
+	for (i = 0; i < count; i++)
+	{
+		if (!memcmp(data + 2 + (i * 4), ms_oui, 3) ||
+			!memcmp(data + 2 + (i * 4), ieee80211_oui, 3))
+		{
+			switch (data[2 + (i * 4) + 3])
+			{
+				case 1: c->auth_suites |= IWINFO_KMGMT_8021x; break;
+				case 2: c->auth_suites |= IWINFO_KMGMT_PSK;   break;
+				case 3:  /* FT/IEEE 802.1X */                 break;
+				case 4:  /* FT/PSK */                         break;
+				case 5:  /* IEEE 802.1X/SHA-256 */            break;
+				case 6:  /* PSK/SHA-256 */                    break;
+				default: /* proprietary */                    break;
+			}
+		}
+	}
+
+	data += 2 + (count * 4);
+	len -= 2 + (count * 4);
+}
diff -Nru -x .svn package/iwinfo/src/iwinfo_wext.c package/iwinfo/src/iwinfo_wext.c
--- package/iwinfo/src/iwinfo_wext.c	2012-01-13 22:34:25.116255322 +0100
+++ package/iwinfo/src/iwinfo_wext.c	2012-02-25 18:58:52.334897037 +0100
@@ -70,7 +70,7 @@
 	/* Nop */
 }
 
-int wext_get_mode(const char *ifname, char *buf)
+int wext_get_mode(const char *ifname, int *buf)
 {
 	struct iwreq wrq;
 
@@ -78,36 +78,25 @@
 	{
 		switch(wrq.u.mode)
 		{
-			case 0:
-				sprintf(buf, "Auto");
-				break;
-
 			case 1:
-				sprintf(buf, "Ad-Hoc");
+				*buf = IWINFO_OPMODE_ADHOC;
 				break;
 
 			case 2:
-				sprintf(buf, "Client");
+				*buf = IWINFO_OPMODE_CLIENT;
 				break;
 
 			case 3:
-				sprintf(buf, "Master");
-				break;
-
-			case 4:
-				sprintf(buf, "Repeater");
-				break;
-
-			case 5:
-				sprintf(buf, "Secondary");
+				*buf = IWINFO_OPMODE_MASTER;
 				break;
 
 			case 6:
-				sprintf(buf, "Monitor");
+				*buf = IWINFO_OPMODE_MONITOR;
 				break;
 
 			default:
-				sprintf(buf, "Unknown");
+				*buf = IWINFO_OPMODE_UNKNOWN;
+				break;
 		}
 
 		return 0;
@@ -462,3 +451,70 @@
 	/* No multi bssid support atm */
 	return -1;
 }
+
+static char * wext_sysfs_ifname_file(const char *ifname, const char *path)
+{
+	FILE *f;
+	static char buf[128];
+	char *rv = NULL;
+
+	snprintf(buf, sizeof(buf), "/sys/class/net/%s/%s", ifname, path);
+
+	if ((f = fopen(buf, "r")) != NULL)
+	{
+		memset(buf, 0, sizeof(buf));
+
+		if (fread(buf, 1, sizeof(buf), f))
+			rv = buf;
+
+		fclose(f);
+	}
+
+	return rv;
+}
+
+int wext_get_hardware_id(const char *ifname, char *buf)
+{
+	char *data;
+	struct iwinfo_hardware_id *id = (struct iwinfo_hardware_id *)buf;
+
+	memset(id, 0, sizeof(struct iwinfo_hardware_id));
+
+	data = wext_sysfs_ifname_file(ifname, "device/vendor");
+	if (data)
+		id->vendor_id = strtoul(data, NULL, 16);
+
+	data = wext_sysfs_ifname_file(ifname, "device/device");
+	if (data)
+		id->device_id = strtoul(data, NULL, 16);
+
+	data = wext_sysfs_ifname_file(ifname, "device/subsystem_device");
+	if (data)
+		id->subsystem_device_id = strtoul(data, NULL, 16);
+
+	data = wext_sysfs_ifname_file(ifname, "device/subsystem_vendor");
+	if (data)
+		id->subsystem_vendor_id = strtoul(data, NULL, 16);
+
+	return (id->vendor_id > 0 && id->device_id > 0) ? 0 : -1;
+}
+
+int wext_get_hardware_name(const char *ifname, char *buf)
+{
+	sprintf(buf, "Generic WEXT");
+	return 0;
+}
+
+int wext_get_txpower_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
+
+int wext_get_frequency_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
diff -Nru -x .svn package/iwinfo/src/iwinfo_wext_scan.c package/iwinfo/src/iwinfo_wext_scan.c
--- package/iwinfo/src/iwinfo_wext_scan.c	2011-12-12 14:23:17.910312993 +0100
+++ package/iwinfo/src/iwinfo_wext_scan.c	2012-02-25 18:58:52.334897037 +0100
@@ -213,132 +213,28 @@
 	return 1;
 }
 
-static inline void wext_fill_wpa(unsigned char *iebuf, int buflen, struct iwinfo_scanlist_entry *e)
+static inline void wext_fill_wpa(unsigned char *iebuf, int ielen, struct iwinfo_scanlist_entry *e)
 {
-	int ielen = iebuf[1] + 2;
-	int offset = 2; /* Skip the IE id, and the length. */
-	unsigned char wpa1_oui[3] = {0x00, 0x50, 0xf2};
-	unsigned char wpa2_oui[3] = {0x00, 0x0f, 0xac};
-	unsigned char *wpa_oui;
-	int i;
-	uint16_t ver = 0;
-	uint16_t cnt = 0;
-	int wpa1 = 0, wpa2 = 0;
-	char buf[256];
-
-	struct iwinfo_crypto_entry *ce = &e->crypto;
-
-	if(ielen > buflen)
-		ielen = buflen;
+	static unsigned char ms_oui[3] = { 0x00, 0x50, 0xf2 };
 
-	switch(iebuf[0])
+	while (ielen >= 2 && ielen >= iebuf[1])
 	{
-		case 0x30:      /* WPA2 */
-			/* Check if we have enough data */
-			if(ielen < 4)
-				return;
-
-			wpa_oui = wpa2_oui;
+		switch (iebuf[0])
+		{
+		case 48: /* RSN */
+			iwinfo_parse_rsn(&e->crypto, iebuf + 2, iebuf[1],
+			                 IWINFO_CIPHER_CCMP, IWINFO_KMGMT_8021x);
 			break;
 
-		case 0xdd:      /* WPA or else */
-			wpa_oui = wpa1_oui;
-			/* Not all IEs that start with 0xdd are WPA.
-			*        * So check that the OUI is valid. */
-			if((ielen < 8) || ((memcmp(&iebuf[offset], wpa_oui, 3) != 0)
-				&& (iebuf[offset+3] == 0x01)))
-					return;
-
-			offset += 4;
+		case 221: /* Vendor */
+			if (iebuf[1] >= 4 && !memcmp(iebuf + 2, ms_oui, 3) && iebuf[5] == 1)
+				iwinfo_parse_rsn(&e->crypto, iebuf + 6, iebuf[1] - 4,
+				                 IWINFO_CIPHER_TKIP, IWINFO_KMGMT_PSK);
 			break;
+		}
 
-		default:
-			return;
-	}
-
-	/* Pick version number (little endian) */
-	ver = iebuf[offset] | (iebuf[offset + 1] << 8);
-	offset += 2;
-
-	if(iebuf[0] == 0xdd)
-		wpa1 = 1;
-
-	if(iebuf[0] == 0x30)
-		wpa2 = 1;
-
-	if( wpa1 && (ce->wpa_version == 2) )
-		ce->wpa_version = 3;
-	else if( wpa2 && (ce->wpa_version == 1) )
-		ce->wpa_version = 3;
-	else if( wpa1 && !ce->wpa_version )
-		ce->wpa_version = 1;
-	else if( wpa2 && !ce->wpa_version )
-		ce->wpa_version = 2;
-
-	if(ielen < (offset + 4))
-	{
-		ce->group_ciphers |= (1<<2); /* TKIP */
-		ce->pair_ciphers  |= (1<<2); /* TKIP */
-		ce->auth_suites   |= (1<<2); /* PSK */
-		return;
-	}
-
-	if(memcmp(&iebuf[offset], wpa_oui, 3) != 0)
-		ce->group_ciphers |= (1<<7); /* Proprietary */
-	else
-		ce->group_ciphers |= (1<<iebuf[offset+3]);
-
-	offset += 4;
-
-	if(ielen < (offset + 2))
-	{
-		ce->pair_ciphers |= (1<<2); /* TKIP */
-		ce->auth_suites  |= (1<<2); /* PSK */
-		return;
-	}
-
-	/* Otherwise, we have some number of pairwise ciphers. */
-	cnt = iebuf[offset] | (iebuf[offset + 1] << 8);
-	offset += 2;
-
-	if(ielen < (offset + 4*cnt))
-		return;
-
-	*buf = '\0';
-	for(i = 0; i < cnt; i++)
-	{
-		if(memcmp(&iebuf[offset], wpa_oui, 3) != 0)
-			ce->pair_ciphers |= (1<<7); /* Proprietary */
-		else if(iebuf[offset+3] <= IW_IE_CYPHER_NUM)
-			ce->pair_ciphers |= (1<<iebuf[offset+3]);
-		//else
-		//	ce->pair_ciphers[ce->pair_cipher_num++] = 255; /* Unknown */
-
-		offset += 4;
-	}
-
-	/* Check if we are done */
-	if(ielen < (offset + 2))
-		return;
-
-	/* Now, we have authentication suites. */
-	cnt = iebuf[offset] | (iebuf[offset + 1] << 8);
-	offset += 2;
-	*buf = '\0';
-
-	if(ielen < (offset + 4*cnt))
-		return;
-
-	for(i = 0; i < cnt; i++)
-	{
-		if(memcmp(&iebuf[offset], wpa_oui, 3) != 0)
-			ce->auth_suites |= (1<<7); /* Proprietary */
-		else if(iebuf[offset+3] <= IW_IE_KEY_MGMT_NUM)
-			ce->auth_suites |= (1<<iebuf[offset+3]);
-		//else
-		//	ce->auth_suites[ce->auth_suite_num++] = 255; /* Unknown */
-
-		offset += 4;
+		ielen -= iebuf[1] + 2;
+		iebuf += iebuf[1] + 2;
 	}
 }
 
@@ -381,16 +277,17 @@
 			switch(event->u.mode)
 			{
 				case 1:
-					sprintf((char *) e->mode, "Ad-Hoc");
+					e->mode = IWINFO_OPMODE_ADHOC;
 					break;
 
 				case 2:
 				case 3:
-					sprintf((char *) e->mode, "Master");
+					e->mode = IWINFO_OPMODE_MASTER;
 					break;
 
 				default:
-					sprintf((char *) e->mode, "Unknown");
+					e->mode = IWINFO_OPMODE_UNKNOWN;
+					break;
 			}
 
 			break;
@@ -433,23 +330,7 @@
 			break;
 #endif
 		 case IWEVGENIE:
-			i = 0;
-
-			while(i <= (event->u.data.length - 2))
-			{
-				switch(((unsigned char *)event->u.data.pointer)[i])
-				{
-					case 0xdd:  /* WPA1 (and other) */
-					case 0x30:  /* WPA2 */
-						wext_fill_wpa((unsigned char *)event->u.data.pointer + i,
-							event->u.data.length, e);
-
-						break;
-				}
-
-				i += ((unsigned char *)event->u.data.pointer)[i+1] + 2;
-			}
-
+			wext_fill_wpa(event->u.data.pointer, event->u.data.length, e);
 			break;
 	}
 }
diff -Nru -x .svn package/iwinfo/src/iwinfo_wl.c package/iwinfo/src/iwinfo_wl.c
--- package/iwinfo/src/iwinfo_wl.c	2012-01-13 22:34:25.176285790 +0100
+++ package/iwinfo/src/iwinfo_wl.c	2012-02-25 18:58:52.336895278 +0100
@@ -37,17 +37,30 @@
 	return iwinfo_ioctl(SIOCDEVPRIVATE, &ifr);
 }
 
+static int wl_iovar(const char *name, const char *cmd, const char *arg,
+					int arglen, void *buf, int buflen)
+{
+	int cmdlen = strlen(cmd) + 1;
+
+	memcpy(buf, cmd, cmdlen);
+
+	if (arg && arglen > 0)
+		memcpy(buf + cmdlen, arg, arglen);
+
+	return wl_ioctl(name, WLC_GET_VAR, buf, buflen);
+}
+
 static struct wl_maclist * wl_read_assoclist(const char *ifname)
 {
 	struct wl_maclist *macs;
 	int maclen = 4 + WL_MAX_STA_COUNT * 6;
 
-	if( (macs = (struct wl_maclist *) malloc(maclen)) != NULL )
+	if ((macs = (struct wl_maclist *) malloc(maclen)) != NULL)
 	{
 		memset(macs, 0, maclen);
 		macs->count = WL_MAX_STA_COUNT;
 
-		if( !wl_ioctl(ifname, WLC_GET_ASSOCLIST, macs, maclen) )
+		if (!wl_ioctl(ifname, WLC_GET_ASSOCLIST, macs, maclen))
 			return macs;
 
 		free(macs);
@@ -60,11 +73,8 @@
 int wl_probe(const char *ifname)
 {
 	int magic;
-
-	if( !wl_ioctl(ifname, WLC_GET_MAGIC, &magic, sizeof(magic)) && (magic == WLC_IOCTL_MAGIC))
-		return 1;
-
-	return 0;
+	return (!wl_ioctl(ifname, WLC_GET_MAGIC, &magic, sizeof(magic)) &&
+			(magic == WLC_IOCTL_MAGIC));
 }
 
 void wl_close(void)
@@ -72,28 +82,28 @@
 	/* Nop */
 }
 
-int wl_get_mode(const char *ifname, char *buf)
+int wl_get_mode(const char *ifname, int *buf)
 {
 	int ret = -1;
 	int ap, infra, passive;
 
-	if( (ret = wl_ioctl(ifname, WLC_GET_AP, &ap, sizeof(ap))) )
+	if ((ret = wl_ioctl(ifname, WLC_GET_AP, &ap, sizeof(ap))))
 		return ret;
 
-	if( (ret = wl_ioctl(ifname, WLC_GET_INFRA, &infra, sizeof(infra))) )
+	if ((ret = wl_ioctl(ifname, WLC_GET_INFRA, &infra, sizeof(infra))))
 		return ret;
 
-	if( (ret = wl_ioctl(ifname, WLC_GET_PASSIVE, &passive, sizeof(passive))) )
+	if ((ret = wl_ioctl(ifname, WLC_GET_PASSIVE, &passive, sizeof(passive))))
 		return ret;
 
-	if( passive )
-		sprintf(buf, "Monitor");
-	else if( !infra )
-		sprintf(buf, "Ad-Hoc");
-	else if( ap )
-		sprintf(buf, "Master");
+	if (passive)
+		*buf = IWINFO_OPMODE_MONITOR;
+	else if (!infra)
+		*buf = IWINFO_OPMODE_ADHOC;
+	else if (ap)
+		*buf = IWINFO_OPMODE_MASTER;
 	else
-		sprintf(buf, "Client");
+		*buf = IWINFO_OPMODE_CLIENT;
 
 	return 0;
 }
@@ -103,7 +113,7 @@
 	int ret = -1;
 	wlc_ssid_t ssid;
 
-	if( !(ret = wl_ioctl(ifname, WLC_GET_SSID, &ssid, sizeof(ssid))) )
+	if (!(ret = wl_ioctl(ifname, WLC_GET_SSID, &ssid, sizeof(ssid))))
 		memcpy(buf, ssid.ssid, ssid.ssid_len);
 
 	return ret;
@@ -114,7 +124,7 @@
 	int ret = -1;
 	char bssid[6];
 
-	if( !(ret = wl_ioctl(ifname, WLC_GET_BSSID, bssid, 6)) )
+	if (!(ret = wl_ioctl(ifname, WLC_GET_BSSID, bssid, 6)))
 		sprintf(buf, "%02X:%02X:%02X:%02X:%02X:%02X",
 			(uint8_t)bssid[0], (uint8_t)bssid[1], (uint8_t)bssid[2],
 			(uint8_t)bssid[3], (uint8_t)bssid[4], (uint8_t)bssid[5]
@@ -135,6 +145,7 @@
 
 int wl_get_txpower(const char *ifname, int *buf)
 {
+	/* WLC_GET_VAR "qtxpower" */
 	return wext_get_txpower(ifname, buf);
 }
 
@@ -162,7 +173,7 @@
 
 	wl_ioctl(ifname, WLC_GET_BSS_INFO, tmp, WLC_IOCTL_MAXLEN);
 
-	if( !wl_ioctl(ifname, WLC_GET_AP, &ap, sizeof(ap)) && !ap )
+	if (!wl_ioctl(ifname, WLC_GET_AP, &ap, sizeof(ap)) && !ap)
 	{
 		*buf = tmp[WL_BSS_RSSI_OFFSET];
 	}
@@ -171,13 +182,13 @@
 		rssi = rssi_count = 0;
 
 		/* Calculate average rssi from conntected stations */
-		if( (macs = wl_read_assoclist(ifname)) != NULL )
+		if ((macs = wl_read_assoclist(ifname)) != NULL)
 		{
-			for( i = 0; i < macs->count; i++ )
+			for (i = 0; i < macs->count; i++)
 			{
 				memcpy(starssi.mac, &macs->ea[i], 6);
 
-				if( !wl_ioctl(ifname, WLC_GET_RSSI, &starssi, 12) )
+				if (!wl_ioctl(ifname, WLC_GET_RSSI, &starssi, 12))
 				{
 					rssi -= starssi.rssi;
 					rssi_count++;
@@ -258,10 +269,10 @@
 	switch(wpa)
 	{
 		case 0:
-			if( wsec && !wauth )
+			if (wsec && !wauth)
 				c->auth_algs |= IWINFO_AUTH_OPEN;
 
-			else if( wsec && wauth )
+			else if (wsec && wauth)
 				c->auth_algs |= IWINFO_AUTH_SHARED;
 
 			/* ToDo: evaluate WEP key lengths */
@@ -375,6 +386,26 @@
 	return 0;
 }
 
+static void wl_get_assoclist_cb(const char *ifname,
+							    struct iwinfo_assoclist_entry *e)
+{
+	wl_sta_info_t sta = { 0 };
+
+	if (!wl_iovar(ifname, "sta_info", e->mac, 6, &sta, sizeof(sta)) &&
+		(sta.ver >= 2))
+	{
+		e->inactive     = sta.idle * 1000;
+		e->rx_packets   = sta.rx_ucast_pkts;
+		e->tx_packets   = sta.tx_pkts;
+		e->rx_rate.rate = sta.rx_rate;
+		e->tx_rate.rate = sta.tx_rate;
+
+		/* ToDo: 11n */
+		e->rx_rate.mcs = -1;
+		e->tx_rate.mcs = -1;
+	}
+}
+
 int wl_get_assoclist(const char *ifname, char *buf, int *len)
 {
 	int i, j, noise;
@@ -393,22 +424,25 @@
 	wl_ioctl(ifname, WLC_GET_INFRA, &infra, sizeof(infra));
 	wl_ioctl(ifname, WLC_GET_PASSIVE, &passive, sizeof(passive));
 
-	if( wl_get_noise(ifname, &noise) )
+	if (wl_get_noise(ifname, &noise))
 		noise = 0;
 
-	if( (ap || infra || passive) && ((macs = wl_read_assoclist(ifname)) != NULL) )
+	if ((ap || infra || passive) && ((macs = wl_read_assoclist(ifname)) != NULL))
 	{
-		for( i = 0, j = 0; i < macs->count; i++, j += sizeof(struct iwinfo_assoclist_entry) )
+		for (i = 0, j = 0; i < macs->count; i++, j += sizeof(struct iwinfo_assoclist_entry))
 		{
+			memset(&entry, 0, sizeof(entry));
 			memcpy(rssi.mac, &macs->ea[i], 6);
 
-			if( !wl_ioctl(ifname, WLC_GET_RSSI, &rssi, sizeof(struct wl_sta_rssi)) )
+			if (!wl_ioctl(ifname, WLC_GET_RSSI, &rssi, sizeof(struct wl_sta_rssi)))
 				entry.signal = (rssi.rssi - 0x100);
 			else
 				entry.signal = 0;
 
 			entry.noise = noise;
 			memcpy(entry.mac, &macs->ea[i], 6);
+			wl_get_assoclist_cb(ifname, &entry);
+
 			memcpy(&buf[j], &entry, sizeof(entry));
 		}
 
@@ -416,13 +450,13 @@
 		free(macs);
 		return 0;
 	}
-	else if( (arp = fopen("/proc/net/arp", "r")) != NULL )
+	else if ((arp = fopen("/proc/net/arp", "r")) != NULL)
 	{
 		j = 0;
 
-		while( fgets(line, sizeof(line), arp) != NULL )
+		while (fgets(line, sizeof(line), arp) != NULL)
 		{
-			if( sscanf(line, "%*s 0x%*d 0x%*d %17s %*s %s", macstr, devstr) && !strcmp(devstr, ifname) )
+			if (sscanf(line, "%*s 0x%*d 0x%*d %17s %*s %s", macstr, devstr) && !strcmp(devstr, ifname))
 			{
 				rssi.mac[0] = strtol(&macstr[0],  NULL, 16);
 				rssi.mac[1] = strtol(&macstr[3],  NULL, 16);
@@ -431,7 +465,7 @@
 				rssi.mac[4] = strtol(&macstr[12], NULL, 16);
 				rssi.mac[5] = strtol(&macstr[15], NULL, 16);
 
-				if( !wl_ioctl(ifname, WLC_GET_RSSI, &rssi, sizeof(struct wl_sta_rssi)) )
+				if (!wl_ioctl(ifname, WLC_GET_RSSI, &rssi, sizeof(struct wl_sta_rssi)))
 					entry.signal = (rssi.rssi - 0x100);
 				else
 					entry.signal = 0;
@@ -455,18 +489,18 @@
 int wl_get_txpwrlist(const char *ifname, char *buf, int *len)
 {
 	struct iwinfo_txpwrlist_entry entry;
-	uint8_t dbm[8] = { 0, 6, 8, 10, 12, 14, 16, 18 };
-	uint8_t mw[8]  = { 1, 3, 6, 10, 15, 25, 39, 63 };
+	uint8_t dbm[11] = { 0, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24 };
+	uint8_t mw[11]  = { 1, 3, 6, 10, 15, 25, 39, 63, 100, 158, 251 };
 	int i;
 
-	for( i = 0; i < 8; i++ )
+	for (i = 0; i < 11; i++)
 	{
 		entry.dbm = dbm[i];
 		entry.mw  = mw[i];
 		memcpy(&buf[i*sizeof(entry)], &entry, sizeof(entry));
 	}
 
-	*len = 8 * sizeof(entry);
+	*len = 11 * sizeof(entry);
 	return 0;
 }
 
@@ -484,14 +518,14 @@
 {
 	char ccode[WLC_CNTRY_BUF_SZ];
 
-	if( !wl_ioctl(ifname, WLC_GET_COUNTRY, ccode, WLC_CNTRY_BUF_SZ) )
+	if (!wl_ioctl(ifname, WLC_GET_COUNTRY, ccode, WLC_CNTRY_BUF_SZ))
 	{
 		/* IL0 -> World */
-		if( !strcmp(ccode, "IL0") )
+		if (!strcmp(ccode, "IL0"))
 			sprintf(buf, "00");
 
 		/* YU -> RS */
-		else if( !strcmp(ccode, "YU") )
+		else if (!strcmp(ccode, "YU"))
 			sprintf(buf, "RS");
 
 		else
@@ -512,19 +546,19 @@
 
 	cl->buflen = sizeof(cdata);
 
-	if( !wl_ioctl(ifname, WLC_GET_COUNTRY_LIST, cl, cl->buflen) )
+	if (!wl_ioctl(ifname, WLC_GET_COUNTRY_LIST, cl, cl->buflen))
 	{
-		for( i = 0, count = 0; i < cl->count; i++, c++ )
+		for (i = 0, count = 0; i < cl->count; i++, c++)
 		{
 			sprintf(c->ccode, &cl->country_abbrev[i * WLC_CNTRY_BUF_SZ]);
 			c->iso3166 = c->ccode[0] * 256 + c->ccode[1];
 
 			/* IL0 -> World */
-			if( !strcmp(c->ccode, "IL0") )
+			if (!strcmp(c->ccode, "IL0"))
 				c->iso3166 = 0x3030;
 
 			/* YU -> RS */
-			else if( !strcmp(c->ccode, "YU") )
+			else if (!strcmp(c->ccode, "YU"))
 				c->iso3166 = 0x5253;
 		}
 
@@ -545,9 +579,9 @@
 	wlc_rev_info_t revinfo;
 
 	/* Multi bssid support only works on corerev >= 9 */
-	if( !wl_ioctl(ifname, WLC_GET_REVINFO, &revinfo, sizeof(revinfo)) )
+	if (!wl_ioctl(ifname, WLC_GET_REVINFO, &revinfo, sizeof(revinfo)))
 	{
-		if( revinfo.corerev >= 9 )
+		if (revinfo.corerev >= 9)
 		{
 			*buf = 1;
 			return 0;
@@ -556,3 +590,56 @@
 
 	return -1;
 }
+
+int wl_get_hardware_id(const char *ifname, char *buf)
+{
+	wlc_rev_info_t revinfo;
+	struct iwinfo_hardware_id *ids = (struct iwinfo_hardware_id *)buf;
+
+	if (wl_ioctl(ifname, WLC_GET_REVINFO, &revinfo, sizeof(revinfo)))
+		return -1;
+
+	ids->vendor_id = revinfo.vendorid;
+	ids->device_id = revinfo.deviceid;
+	ids->subsystem_vendor_id = revinfo.boardvendor;
+	ids->subsystem_device_id = revinfo.boardid;
+
+	return 0;
+}
+
+int wl_get_hardware_name(const char *ifname, char *buf)
+{
+	struct iwinfo_hardware_id ids;
+
+	if (wl_get_hardware_id(ifname, (char *)&ids))
+		return -1;
+
+	sprintf(buf, "Broadcom BCM%04X", ids.device_id);
+
+	return 0;
+}
+
+int wl_get_txpower_offset(const char *ifname, int *buf)
+{
+	FILE *p;
+	char off[8];
+
+	*buf = 0;
+
+	if ((p = popen("/usr/sbin/nvram get opo", "r")) != NULL)
+	{
+		if (fread(off, 1, sizeof(off), p))
+			*buf = strtoul(off, NULL, 16);
+
+		pclose(p);
+	}
+
+	return 0;
+}
+
+int wl_get_frequency_offset(const char *ifname, int *buf)
+{
+	/* Stub */
+	*buf = 0;
+	return -1;
+}
