Index: openwrt/package/network/services/ppp/patches/201-mppe_mppc_1.1.patch
===================================================================
--- openwrt.orig/package/network/services/ppp/patches/201-mppe_mppc_1.1.patch
+++ openwrt/package/network/services/ppp/patches/201-mppe_mppc_1.1.patch
@@ -1,1495 +0,0 @@
-pppd: add support for MPPE and MPPC encryption and compression protocols
-
-This is a forward ported version of ppp-2.4.3-mppe-mppc-1.1.patch.gz found on
-http://mppe-mppc.alphacron.de/ .
-
-Signed-off-by: Jo-Philipp Wich <jow@openwrt.org>
-
---- a/include/linux/ppp-comp.h
-+++ b/include/linux/ppp-comp.h
-@@ -36,7 +36,7 @@
-  */
- 
- /*
-- *  ==FILEVERSION 20020319==
-+ *  ==FILEVERSION 20020715==
-  *
-  *  NOTE TO MAINTAINERS:
-  *     If you modify this file at all, please set the above date.
-@@ -201,6 +201,33 @@ struct compressor {
- #define CI_MPPE			18	/* config option for MPPE */
- #define CILEN_MPPE		6	/* length of config option */
- 
-+/* MPPE/MPPC definitions by J.D.*/
-+#define MPPE_STATELESS          MPPE_H_BIT	/* configuration bit H */
-+#define MPPE_40BIT              MPPE_L_BIT	/* configuration bit L */
-+#define MPPE_56BIT              MPPE_M_BIT	/* configuration bit M */
-+#define MPPE_128BIT             MPPE_S_BIT	/* configuration bit S */
-+#define MPPE_MPPC               MPPE_C_BIT	/* configuration bit C */
-+
-+/*
-+ * Definitions for Stac LZS.
-+ */
-+
-+#define CI_LZS			17	/* config option for Stac LZS */
-+#define CILEN_LZS		5	/* length of config option */
-+
-+#define LZS_OVHD		4	/* max. LZS overhead */
-+#define LZS_HIST_LEN		2048	/* LZS history size */
-+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
-+
-+#define LZS_MODE_NONE		0
-+#define LZS_MODE_LCB		1
-+#define LZS_MODE_CRC		2
-+#define LZS_MODE_SEQ		3
-+#define LZS_MODE_EXT		4
-+
-+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
-+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
-+
- /*
-  * Definitions for other, as yet unsupported, compression methods.
-  */
---- a/include/net/ppp-comp.h
-+++ b/include/net/ppp-comp.h
-@@ -168,6 +168,33 @@ struct compressor {
- #define CI_MPPE			18	/* config option for MPPE */
- #define CILEN_MPPE		6	/* length of config option */
- 
-+/* MPPE/MPPC definitions by J.D.*/
-+#define MPPE_STATELESS          MPPE_H_BIT	/* configuration bit H */
-+#define MPPE_40BIT              MPPE_L_BIT	/* configuration bit L */
-+#define MPPE_56BIT              MPPE_M_BIT	/* configuration bit M */
-+#define MPPE_128BIT             MPPE_S_BIT	/* configuration bit S */
-+#define MPPE_MPPC               MPPE_C_BIT	/* configuration bit C */
-+
-+/*
-+ * Definitions for Stac LZS.
-+ */
-+
-+#define CI_LZS			17	/* config option for Stac LZS */
-+#define CILEN_LZS		5	/* length of config option */
-+
-+#define LZS_OVHD		4	/* max. LZS overhead */
-+#define LZS_HIST_LEN		2048	/* LZS history size */
-+#define LZS_MAX_CCOUNT		0x0FFF	/* max. coherency counter value */
-+
-+#define LZS_MODE_NONE		0
-+#define LZS_MODE_LCB		1
-+#define LZS_MODE_CRC		2
-+#define LZS_MODE_SEQ		3
-+#define LZS_MODE_EXT		4
-+
-+#define LZS_EXT_BIT_FLUSHED	0x80	/* bit A */
-+#define LZS_EXT_BIT_COMP	0x20	/* bit C */
-+
- /*
-  * Definitions for other, as yet unsupported, compression methods.
-  */
---- a/pppd/ccp.c
-+++ b/pppd/ccp.c
-@@ -62,12 +62,10 @@ static int setdeflate __P((char **));
- static char bsd_value[8];
- static char deflate_value[8];
- 
--/*
-- * Option variables.
-- */
- #ifdef MPPE
--bool refuse_mppe_stateful = 1;		/* Allow stateful mode? */
--#endif
-+static int setmppe(char **);
-+static int setnomppe(void);
-+#endif /* MPPE */
- 
- static option_t ccp_option_list[] = {
-     { "noccp", o_bool, &ccp_protent.enabled_flag,
-@@ -108,54 +106,36 @@ static option_t ccp_option_list[] = {
-       "don't allow Predictor-1", OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLR,
-       &ccp_allowoptions[0].predictor_1 },
- 
-+    { "lzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "request Stac LZS", 1, &ccp_allowoptions[0].lzs, OPT_PRIO },
-+    { "+lzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "request Stac LZS", 1, &ccp_allowoptions[0].lzs, OPT_ALIAS | OPT_PRIO },
-+    { "nolzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "don't allow Stac LZS", OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].lzs },
-+    { "-lzs", o_bool, &ccp_wantoptions[0].lzs,
-+      "don't allow Stac LZS", OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].lzs },
-+
- #ifdef MPPE
--    /* MPPE options are symmetrical ... we only set wantoptions here */
--    { "require-mppe", o_bool, &ccp_wantoptions[0].mppe,
--      "require MPPE encryption",
--      OPT_PRIO | MPPE_OPT_40 | MPPE_OPT_128 },
--    { "+mppe", o_bool, &ccp_wantoptions[0].mppe,
--      "require MPPE encryption",
--      OPT_ALIAS | OPT_PRIO | MPPE_OPT_40 | MPPE_OPT_128 },
--    { "nomppe", o_bool, &ccp_wantoptions[0].mppe,
--      "don't allow MPPE encryption", OPT_PRIO },
--    { "-mppe", o_bool, &ccp_wantoptions[0].mppe,
--      "don't allow MPPE encryption", OPT_ALIAS | OPT_PRIO },
--
--    /* We use ccp_allowoptions[0].mppe as a junk var ... it is reset later */
--    { "require-mppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 40-bit encryption", OPT_PRIO | OPT_A2OR | MPPE_OPT_40,
--      &ccp_wantoptions[0].mppe },
--    { "+mppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 40-bit encryption", OPT_PRIO | OPT_A2OR | MPPE_OPT_40,
--      &ccp_wantoptions[0].mppe },
--    { "nomppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 40-bit encryption",
--      OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_40, &ccp_wantoptions[0].mppe },
--    { "-mppe-40", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 40-bit encryption",
--      OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_40,
--      &ccp_wantoptions[0].mppe },
--
--    { "require-mppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 128-bit encryption", OPT_PRIO | OPT_A2OR | MPPE_OPT_128,
--      &ccp_wantoptions[0].mppe },
--    { "+mppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "require MPPE 128-bit encryption",
--      OPT_ALIAS | OPT_PRIO | OPT_A2OR | MPPE_OPT_128,
--      &ccp_wantoptions[0].mppe },
--    { "nomppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 128-bit encryption",
--      OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_128, &ccp_wantoptions[0].mppe },
--    { "-mppe-128", o_bool, &ccp_allowoptions[0].mppe,
--      "don't allow MPPE 128-bit encryption",
--      OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLRB | MPPE_OPT_128,
--      &ccp_wantoptions[0].mppe },
--
--    /* strange one; we always request stateless, but will we allow stateful? */
--    { "mppe-stateful", o_bool, &refuse_mppe_stateful,
--      "allow MPPE stateful mode", OPT_PRIO },
--    { "nomppe-stateful", o_bool, &refuse_mppe_stateful,
--      "disallow MPPE stateful mode", OPT_PRIO | 1 },
-+    { "mppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "request MPPC compression", 1, &ccp_allowoptions[0].mppc },
-+    { "+mppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "request MPPC compression", 1, &ccp_allowoptions[0].mppc, OPT_ALIAS },
-+    { "nomppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "don't allow MPPC compression", OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].mppc },
-+    { "-mppc", o_bool, &ccp_wantoptions[0].mppc,
-+      "don't allow MPPC compression", OPT_ALIAS | OPT_PRIOSUB | OPT_A2CLR,
-+      &ccp_allowoptions[0].mppc },
-+    { "mppe", o_special, (void *)setmppe,
-+      "request MPPE encryption" },
-+    { "+mppe", o_special, (void *)setmppe,
-+      "request MPPE encryption" },
-+    { "nomppe", o_special_noarg, (void *)setnomppe,
-+      "don't allow MPPE encryption" },
-+    { "-mppe", o_special_noarg, (void *)setnomppe,
-+      "don't allow MPPE encryption" },
- #endif /* MPPE */
- 
-     { NULL }
-@@ -241,7 +221,7 @@ static fsm_callbacks ccp_callbacks = {
-  */
- #define ANY_COMPRESS(opt)	((opt).deflate || (opt).bsd_compress \
- 				 || (opt).predictor_1 || (opt).predictor_2 \
--				 || (opt).mppe)
-+				 || (opt).lzs || (opt).mppc || (opt).mppe)
- 
- /*
-  * Local state (mainly for handling reset-reqs and reset-acks).
-@@ -344,6 +324,100 @@ setdeflate(argv)
-     return 1;
- }
- 
-+#ifdef MPPE
-+/*
-+ * Functions called from config options
-+ */
-+/* 
-+   MPPE suboptions:
-+	required - require MPPE; disconnect if peer doesn't support it
-+	stateless - use stateless mode
-+	no40 - disable 40 bit keys
-+	no56 - disable 56 bit keys
-+	no128 - disable 128 bit keys
-+*/
-+int setmppe(char **argv)
-+{
-+    int i;
-+    char *str, cmdbuf[16];
-+
-+    ccp_allowoptions[0].mppe = 1;
-+    ccp_allowoptions[0].mppe_40 = 1;
-+    ccp_allowoptions[0].mppe_56 = 1;
-+    ccp_allowoptions[0].mppe_128 = 1;
-+    ccp_allowoptions[0].mppe_stateless = 0;
-+    ccp_wantoptions[0].mppe = 0;
-+
-+    str = *argv;
-+
-+    while (1) {
-+	i = 0;
-+	memset(cmdbuf, '\0', 16);
-+	while ((i < 16) && (*str != ',') && (*str != '\0'))
-+	    cmdbuf[i++] = *str++;
-+	cmdbuf[i] = '\0';
-+	if (!strncasecmp(cmdbuf, "no40", strlen("no40"))) {
-+	    ccp_allowoptions[0].mppe_40 = 0;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "no56", strlen("no56"))) {
-+	    ccp_allowoptions[0].mppe_56 = 0;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "no128", strlen("no128"))) {
-+	    ccp_allowoptions[0].mppe_128 = 0;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "stateless", strlen("stateless"))) {
-+	    ccp_allowoptions[0].mppe_stateless = 1;
-+	    goto next_param;
-+	} else if (!strncasecmp(cmdbuf, "required", strlen("required"))) {
-+	    ccp_wantoptions[0].mppe = 1;
-+	    goto next_param;
-+	} else {
-+	    option_error("invalid parameter '%s' for mppe option", cmdbuf);
-+	    return 0;
-+	}
-+
-+    next_param:
-+	if (*str == ',') {
-+	    str++;
-+	    continue;
-+	}
-+	if (*str == '\0') {
-+	    if (!(ccp_allowoptions[0].mppe_40 || ccp_allowoptions[0].mppe_56 ||
-+		  ccp_allowoptions[0].mppe_128)) {
-+		if (ccp_wantoptions[0].mppe == 1) {
-+		    option_error("You require MPPE but you have switched off "
-+				 "all encryption key lengths.");
-+		    return 0;
-+		}
-+		ccp_wantoptions[0].mppe = ccp_allowoptions[0].mppe = 0;
-+		ccp_wantoptions[0].mppe_stateless =
-+		    ccp_allowoptions[0].mppe_stateless = 0;
-+	    } else {
-+		ccp_allowoptions[0].mppe = 1;
-+		ccp_wantoptions[0].mppe_stateless =
-+		    ccp_allowoptions[0].mppe_stateless;
-+		if (ccp_wantoptions[0].mppe == 1) {
-+		    ccp_wantoptions[0].mppe_40 = ccp_allowoptions[0].mppe_40;
-+		    ccp_wantoptions[0].mppe_56 = ccp_allowoptions[0].mppe_56;
-+		    ccp_wantoptions[0].mppe_128 = ccp_allowoptions[0].mppe_128;
-+		}
-+	    }
-+	    return 1;
-+	}
-+    }
-+}
-+
-+int setnomppe(void)
-+{
-+    ccp_wantoptions[0].mppe = ccp_allowoptions[0].mppe = 0;
-+    ccp_wantoptions[0].mppe_40 = ccp_allowoptions[0].mppe_40 = 0;
-+    ccp_wantoptions[0].mppe_56 = ccp_allowoptions[0].mppe_56 = 0;
-+    ccp_wantoptions[0].mppe_128 = ccp_allowoptions[0].mppe_128 = 0;
-+    ccp_wantoptions[0].mppe_stateless = ccp_allowoptions[0].mppe_stateless = 0;
-+    return 1;
-+}
-+#endif /* MPPE */
-+
- /*
-  * ccp_init - initialize CCP.
-  */
-@@ -378,6 +452,30 @@ ccp_init(unit)
-     ccp_allowoptions[0].bsd_bits = BSD_MAX_BITS;
- 
-     ccp_allowoptions[0].predictor_1 = 1;
-+
-+    ccp_wantoptions[0].lzs = 0; /* Stac LZS  - will be enabled in the future */
-+    ccp_wantoptions[0].lzs_mode = LZS_MODE_SEQ;
-+    ccp_wantoptions[0].lzs_hists = 1;
-+    ccp_allowoptions[0].lzs = 0; /* Stac LZS  - will be enabled in the future */
-+    ccp_allowoptions[0].lzs_mode = LZS_MODE_SEQ;
-+    ccp_allowoptions[0].lzs_hists = 1;
-+
-+#ifdef MPPE
-+    /* by default allow and request MPPC... */
-+    ccp_wantoptions[0].mppc = ccp_allowoptions[0].mppc = 1;
-+
-+    /* ... and allow but don't request MPPE */
-+    ccp_allowoptions[0].mppe = 1;
-+    ccp_allowoptions[0].mppe_40 = 1;
-+    ccp_allowoptions[0].mppe_56 = 1;
-+    ccp_allowoptions[0].mppe_128 = 1;
-+    ccp_allowoptions[0].mppe_stateless = 1;
-+    ccp_wantoptions[0].mppe = 0;
-+    ccp_wantoptions[0].mppe_40 = 0;
-+    ccp_wantoptions[0].mppe_56 = 0;
-+    ccp_wantoptions[0].mppe_128 = 0;
-+    ccp_wantoptions[0].mppe_stateless = 0;
-+#endif /* MPPE */
- }
- 
- /*
-@@ -455,11 +553,11 @@ ccp_input(unit, p, len)
-     if (oldstate == OPENED && p[0] == TERMREQ && f->state != OPENED) {
- 	notice("Compression disabled by peer.");
- #ifdef MPPE
--	if (ccp_gotoptions[unit].mppe) {
-+	if (ccp_wantoptions[unit].mppe) {
- 	    error("MPPE disabled, closing LCP");
- 	    lcp_close(unit, "MPPE disabled by peer");
- 	}
--#endif
-+#endif /* MPPE */
-     }
- 
-     /*
-@@ -487,6 +585,15 @@ ccp_extcode(f, code, id, p, len)
- 	    break;
- 	/* send a reset-ack, which the transmitter will see and
- 	   reset its compression state. */
-+
-+	/* In case of MPPE/MPPC or LZS we shouldn't send CCP_RESETACK,
-+	   but we do it in order to reset compressor; CCP_RESETACK is
-+	   then silently discarded. See functions ppp_send_frame and
-+	   ppp_ccp_peek in ppp_generic.c (Linux only !!!). All the
-+	   confusion is caused by the fact that CCP code is splited
-+	   into two parts - one part is handled by pppd, the other one
-+	   is handled by kernel. */
-+
- 	fsm_sdata(f, CCP_RESETACK, id, NULL, 0);
- 	break;
- 
-@@ -515,12 +622,11 @@ ccp_protrej(unit)
-     fsm_lowerdown(&ccp_fsm[unit]);
- 
- #ifdef MPPE
--    if (ccp_gotoptions[unit].mppe) {
-+    if (ccp_wantoptions[unit].mppe) {
- 	error("MPPE required but peer negotiation failed");
- 	lcp_close(unit, "MPPE required but peer negotiation failed");
-     }
--#endif
--
-+#endif /* MPPE */
- }
- 
- /*
-@@ -537,7 +643,7 @@ ccp_resetci(f)
-     all_rejected[f->unit] = 0;
- 
- #ifdef MPPE
--    if (go->mppe) {
-+    if (go->mppe || go->mppc) {
- 	ccp_options *ao = &ccp_allowoptions[f->unit];
- 	int auth_mschap_bits = auth_done[f->unit];
- 	int numbits;
-@@ -551,80 +657,109 @@ ccp_resetci(f)
- 	 * NB: If MPPE is required, all other compression opts are invalid.
- 	 *     So, we return right away if we can't do it.
- 	 */
-+	if (ccp_wantoptions[f->unit].mppe) {
-+	    /* Leave only the mschap auth bits set */
-+	    auth_mschap_bits &= (CHAP_MS_WITHPEER  | CHAP_MS_PEER |
-+				 CHAP_MS2_WITHPEER | CHAP_MS2_PEER);
-+	    /* Count the mschap auths */
-+	    auth_mschap_bits >>= CHAP_MS_SHIFT;
-+	    numbits = 0;
-+	    do {
-+		numbits += auth_mschap_bits & 1;
-+		auth_mschap_bits >>= 1;
-+	    } while (auth_mschap_bits);
-+	    if (numbits > 1) {
-+		error("MPPE required, but auth done in both directions.");
-+		lcp_close(f->unit, "MPPE required but not available");
-+		return;
-+	    }
-+	    if (!numbits) {
-+		error("MPPE required, but MS-CHAP[v2] auth not performed.");
-+		lcp_close(f->unit, "MPPE required but not available");
-+		return;
-+	    }
- 
--	/* Leave only the mschap auth bits set */
--	auth_mschap_bits &= (CHAP_MS_WITHPEER  | CHAP_MS_PEER |
--			     CHAP_MS2_WITHPEER | CHAP_MS2_PEER);
--	/* Count the mschap auths */
--	auth_mschap_bits >>= CHAP_MS_SHIFT;
--	numbits = 0;
--	do {
--	    numbits += auth_mschap_bits & 1;
--	    auth_mschap_bits >>= 1;
--	} while (auth_mschap_bits);
--	if (numbits > 1) {
--	    error("MPPE required, but auth done in both directions.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
--	}
--	if (!numbits) {
--	    error("MPPE required, but MS-CHAP[v2] auth not performed.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
--	}
--
--	/* A plugin (eg radius) may not have obtained key material. */
--	if (!mppe_keys_set) {
--	    error("MPPE required, but keys are not available.  "
--		  "Possible plugin problem?");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
--	}
--
--	/* LM auth not supported for MPPE */
--	if (auth_done[f->unit] & (CHAP_MS_WITHPEER | CHAP_MS_PEER)) {
--	    /* This might be noise */
--	    if (go->mppe & MPPE_OPT_40) {
--		notice("Disabling 40-bit MPPE; MS-CHAP LM not supported");
--		go->mppe &= ~MPPE_OPT_40;
--		ccp_wantoptions[f->unit].mppe &= ~MPPE_OPT_40;
-+	    /* A plugin (eg radius) may not have obtained key material. */
-+	    if (!mppe_keys_set) {
-+		error("MPPE required, but keys are not available.  "
-+		      "Possible plugin problem?");
-+		lcp_close(f->unit, "MPPE required but not available");
-+		return;
- 	    }
- 	}
- 
--	/* Last check: can we actually negotiate something? */
--	if (!(go->mppe & (MPPE_OPT_40 | MPPE_OPT_128))) {
--	    /* Could be misconfig, could be 40-bit disabled above. */
--	    error("MPPE required, but both 40-bit and 128-bit disabled.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	    return;
-+	/*
-+	 * Check whether the kernel knows about the various
-+	 * compression methods we might request. Key material
-+	 * unimportant here.
-+	 */
-+	if (go->mppc) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = 0;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_MPPC;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE, 0) <= 0)
-+		go->mppc = 0;
-+	}
-+	if (go->mppe_40) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = MPPE_STATELESS;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_40BIT;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0)
-+		go->mppe_40 = 0;
-+	}
-+	if (go->mppe_56) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = MPPE_STATELESS;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_56BIT;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0)
-+		go->mppe_56 = 0;
-+	}
-+	if (go->mppe_128) {
-+	    opt_buf[0] = CI_MPPE;
-+	    opt_buf[1] = CILEN_MPPE;
-+	    opt_buf[2] = MPPE_STATELESS;
-+	    opt_buf[3] = 0;
-+	    opt_buf[4] = 0;
-+	    opt_buf[5] = MPPE_128BIT;
-+	    if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0)
-+		go->mppe_128 = 0;
-+	}
-+	if (!go->mppe_40 && !go->mppe_56 && !go->mppe_128) {
-+	    if (ccp_wantoptions[f->unit].mppe) {
-+		error("MPPE required, but kernel has no support.");
-+		lcp_close(f->unit, "MPPE required but not available");
-+	    }
-+	    go->mppe = go->mppe_stateless = 0;
-+	} else {
-+	    /* MPPE is not compatible with other compression types */
-+	    if (ccp_wantoptions[f->unit].mppe) {
-+		ao->bsd_compress = go->bsd_compress = 0;
-+		ao->predictor_1  = go->predictor_1  = 0;
-+		ao->predictor_2  = go->predictor_2  = 0;
-+		ao->deflate	 = go->deflate	    = 0;
-+		ao->lzs		 = go->lzs	    = 0;
-+	    }
- 	}
--
--	/* sync options */
--	ao->mppe = go->mppe;
--	/* MPPE is not compatible with other compression types */
--	ao->bsd_compress = go->bsd_compress = 0;
--	ao->predictor_1  = go->predictor_1  = 0;
--	ao->predictor_2  = go->predictor_2  = 0;
--	ao->deflate      = go->deflate      = 0;
-     }
- #endif /* MPPE */
--
--    /*
--     * Check whether the kernel knows about the various
--     * compression methods we might request.
--     */
--#ifdef MPPE
--    if (go->mppe) {
--	opt_buf[0] = CI_MPPE;
--	opt_buf[1] = CILEN_MPPE;
--	MPPE_OPTS_TO_CI(go->mppe, &opt_buf[2]);
--	/* Key material unimportant here. */
--	if (ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0) <= 0) {
--	    error("MPPE required, but kernel has no support.");
--	    lcp_close(f->unit, "MPPE required but not available");
--	}
-+    if (go->lzs) {
-+	opt_buf[0] = CI_LZS;
-+	opt_buf[1] = CILEN_LZS;
-+	opt_buf[2] = go->lzs_hists >> 8;
-+	opt_buf[3] = go->lzs_hists & 0xff;
-+	opt_buf[4] = LZS_MODE_SEQ;
-+	if (ccp_test(f->unit, opt_buf, CILEN_LZS, 0) <= 0)
-+	    go->lzs = 0;
-     }
--#endif
-     if (go->bsd_compress) {
- 	opt_buf[0] = CI_BSD_COMPRESS;
- 	opt_buf[1] = CILEN_BSD_COMPRESS;
-@@ -679,7 +814,8 @@ ccp_cilen(f)
- 	+ (go->deflate? CILEN_DEFLATE: 0)
- 	+ (go->predictor_1? CILEN_PREDICTOR_1: 0)
- 	+ (go->predictor_2? CILEN_PREDICTOR_2: 0)
--	+ (go->mppe? CILEN_MPPE: 0);
-+	+ (go->lzs? CILEN_LZS: 0)
-+	+ ((go->mppe || go->mppc)? CILEN_MPPE: 0);
- }
- 
- /*
-@@ -693,6 +829,8 @@ ccp_addci(f, p, lenp)
- {
-     int res;
-     ccp_options *go = &ccp_gotoptions[f->unit];
-+    ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
-     u_char *p0 = p;
- 
-     /*
-@@ -701,22 +839,43 @@ ccp_addci(f, p, lenp)
-      * in case it gets Acked.
-      */
- #ifdef MPPE
--    if (go->mppe) {
-+    if (go->mppe || go->mppc || (!wo->mppe && ao->mppe)) {
- 	u_char opt_buf[CILEN_MPPE + MPPE_MAX_KEY_LEN];
- 
--	p[0] = opt_buf[0] = CI_MPPE;
--	p[1] = opt_buf[1] = CILEN_MPPE;
--	MPPE_OPTS_TO_CI(go->mppe, &p[2]);
--	MPPE_OPTS_TO_CI(go->mppe, &opt_buf[2]);
-+	p[0] = CI_MPPE;
-+	p[1] = CILEN_MPPE;
-+	p[2] = (go->mppe_stateless ? MPPE_STATELESS : 0);
-+	p[3] = 0;
-+	p[4] = 0;
-+	p[5] = (go->mppe_40 ? MPPE_40BIT : 0) | (go->mppe_56 ? MPPE_56BIT : 0) |
-+	    (go->mppe_128 ? MPPE_128BIT : 0) | (go->mppc ? MPPE_MPPC : 0);
-+
-+	BCOPY(p, opt_buf, CILEN_MPPE);
- 	BCOPY(mppe_recv_key, &opt_buf[CILEN_MPPE], MPPE_MAX_KEY_LEN);
- 	res = ccp_test(f->unit, opt_buf, CILEN_MPPE + MPPE_MAX_KEY_LEN, 0);
--	if (res > 0)
-+	if (res > 0) {
- 	    p += CILEN_MPPE;
--	else
-+	} else {
- 	    /* This shouldn't happen, we've already tested it! */
--	    lcp_close(f->unit, "MPPE required but not available in kernel");
-+	    go->mppe = go->mppe_40 = go->mppe_56 = go->mppe_128 =
-+		go->mppe_stateless = go->mppc = 0;
-+	    if (ccp_wantoptions[f->unit].mppe)
-+		lcp_close(f->unit, "MPPE required but not available in kernel");
-+	}
-+    }
-+#endif /* MPPE */
-+    if (go->lzs) {
-+	p[0] = CI_LZS;
-+	p[1] = CILEN_LZS;
-+	p[2] = go->lzs_hists >> 8;
-+	p[3] = go->lzs_hists & 0xff;
-+	p[4] = LZS_MODE_SEQ;
-+	res = ccp_test(f->unit, p, CILEN_LZS, 0);
-+	if (res > 0) {
-+	    p += CILEN_LZS;
-+	} else
-+	    go->lzs = 0;
-     }
--#endif
-     if (go->deflate) {
- 	p[0] = go->deflate_correct? CI_DEFLATE: CI_DEFLATE_DRAFT;
- 	p[1] = CILEN_DEFLATE;
-@@ -802,7 +961,7 @@ ccp_addci(f, p, lenp)
- 
- /*
-  * ccp_ackci - process a received configure-ack, and return
-- * 1 iff the packet was OK.
-+ * 1 if the packet was OK.
-  */
- static int
- ccp_ackci(f, p, len)
-@@ -811,24 +970,44 @@ ccp_ackci(f, p, len)
-     int len;
- {
-     ccp_options *go = &ccp_gotoptions[f->unit];
-+    ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
-     u_char *p0 = p;
- 
- #ifdef MPPE
--    if (go->mppe) {
--	u_char opt_buf[CILEN_MPPE];
--
--	opt_buf[0] = CI_MPPE;
--	opt_buf[1] = CILEN_MPPE;
--	MPPE_OPTS_TO_CI(go->mppe, &opt_buf[2]);
--	if (len < CILEN_MPPE || memcmp(opt_buf, p, CILEN_MPPE))
-+    if (go->mppe || go->mppc || (!wo->mppe && ao->mppe)) {
-+	if (len < CILEN_MPPE
-+	    || p[1] != CILEN_MPPE || p[0] != CI_MPPE
-+	    || p[2] != (go->mppe_stateless ? MPPE_STATELESS : 0)
-+	    || p[3] != 0
-+	    || p[4] != 0
-+	    || (p[5] != ((go->mppe_40 ? MPPE_40BIT : 0) |
-+			 (go->mppc ? MPPE_MPPC : 0))
-+		&& p[5] != ((go->mppe_56 ? MPPE_56BIT : 0) |
-+			    (go->mppc ? MPPE_MPPC : 0))
-+		&& p[5] != ((go->mppe_128 ? MPPE_128BIT : 0) |
-+			    (go->mppc ? MPPE_MPPC : 0))))
- 	    return 0;
-+	if (go->mppe_40 || go->mppe_56 || go->mppe_128)
-+	    go->mppe = 1;
- 	p += CILEN_MPPE;
- 	len -= CILEN_MPPE;
-+	/* Cope with first/fast ack */
-+	if (p == p0 && len == 0)
-+	    return 1;
-+    }
-+#endif /* MPPE */
-+    if (go->lzs) {
-+	if (len < CILEN_LZS || p[0] != CI_LZS || p[1] != CILEN_LZS
-+	    || p[2] != go->lzs_hists>>8 || p[3] != (go->lzs_hists&0xff)
-+	    || p[4] != LZS_MODE_SEQ)
-+	    return 0;
-+	p += CILEN_LZS;
-+	len -= CILEN_LZS;
- 	/* XXX Cope with first/fast ack */
--	if (len == 0)
-+	if (p == p0 && len == 0)
- 	    return 1;
-     }
--#endif
-     if (go->deflate) {
- 	if (len < CILEN_DEFLATE
- 	    || p[0] != (go->deflate_correct? CI_DEFLATE: CI_DEFLATE_DRAFT)
-@@ -901,6 +1080,8 @@ ccp_nakci(f, p, len, treat_as_reject)
-     int treat_as_reject;
- {
-     ccp_options *go = &ccp_gotoptions[f->unit];
-+    ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
-     ccp_options no;		/* options we've seen already */
-     ccp_options try;		/* options to ask for next time */
- 
-@@ -908,28 +1089,100 @@ ccp_nakci(f, p, len, treat_as_reject)
-     try = *go;
- 
- #ifdef MPPE
--    if (go->mppe && len >= CILEN_MPPE
--	&& p[0] == CI_MPPE && p[1] == CILEN_MPPE) {
--	no.mppe = 1;
--	/*
--	 * Peer wants us to use a different strength or other setting.
--	 * Fail if we aren't willing to use his suggestion.
--	 */
--	MPPE_CI_TO_OPTS(&p[2], try.mppe);
--	if ((try.mppe & MPPE_OPT_STATEFUL) && refuse_mppe_stateful) {
--	    error("Refusing MPPE stateful mode offered by peer");
--	    try.mppe = 0;
--	} else if (((go->mppe | MPPE_OPT_STATEFUL) & try.mppe) != try.mppe) {
--	    /* Peer must have set options we didn't request (suggest) */
--	    try.mppe = 0;
--	}
-+    if ((go->mppe || go->mppc || (!wo->mppe && ao->mppe)) &&
-+	len >= CILEN_MPPE && p[0] == CI_MPPE && p[1] == CILEN_MPPE) {
- 
--	if (!try.mppe) {
--	    error("MPPE required but peer negotiation failed");
--	    lcp_close(f->unit, "MPPE required but peer negotiation failed");
-+	if (go->mppc) {
-+	    no.mppc = 1;
-+	    if (!(p[5] & MPPE_MPPC))
-+		try.mppc = 0;
-+	}
-+
-+	if (go->mppe)
-+	    no.mppe = 1;
-+	if (go->mppe_40)
-+	    no.mppe_40 = 1;
-+	if (go->mppe_56)
-+	    no.mppe_56 = 1;
-+	if (go->mppe_128)
-+	    no.mppe_128 = 1;
-+	if (go->mppe_stateless)
-+	    no.mppe_stateless = 1;
-+
-+	if (ao->mppe_40) {
-+	    if ((p[5] & MPPE_40BIT))
-+		try.mppe_40 = 1;
-+	    else
-+		try.mppe_40 = (p[5] == 0) ? 1 : 0;
-+	}
-+	if (ao->mppe_56) {
-+	    if ((p[5] & MPPE_56BIT))
-+		try.mppe_56 = 1;
-+	    else
-+		try.mppe_56 = (p[5] == 0) ? 1 : 0;
-+	}
-+	if (ao->mppe_128) {
-+	    if ((p[5] & MPPE_128BIT))
-+		try.mppe_128 = 1;
-+	    else
-+		try.mppe_128 = (p[5] == 0) ? 1 : 0;
-+	}
-+
-+	if (ao->mppe_stateless) {
-+	    if ((p[2] & MPPE_STATELESS) || wo->mppe_stateless)
-+		try.mppe_stateless = 1;
-+	    else
-+		try.mppe_stateless = 0;
-+	}
-+
-+	if (!try.mppe_56 && !try.mppe_40 && !try.mppe_128) {
-+	    try.mppe = try.mppe_stateless = 0;
-+	    if (wo->mppe) {
-+		/* we require encryption, but peer doesn't support it
-+		   so we close connection */
-+		wo->mppc = wo->mppe = wo->mppe_stateless = wo->mppe_40 =
-+		    wo->mppe_56 = wo->mppe_128 = 0;
-+		lcp_close(f->unit, "MPPE required but cannot negotiate MPPE "
-+			  "key length");
-+	    }
-+        }
-+	if (wo->mppe && (wo->mppe_40 != try.mppe_40) &&
-+	    (wo->mppe_56 != try.mppe_56) && (wo->mppe_128 != try.mppe_128)) {
-+	    /* cannot negotiate key length */
-+	    wo->mppc = wo->mppe = wo->mppe_stateless = wo->mppe_40 =
-+		wo->mppe_56 = wo->mppe_128 = 0;
-+	    lcp_close(f->unit, "Cannot negotiate MPPE key length");
- 	}
-+	if (try.mppe_40 && try.mppe_56 && try.mppe_128)
-+	    try.mppe_40 = try.mppe_56 = 0;
-+	else
-+	    if (try.mppe_56 && try.mppe_128)
-+		try.mppe_56 = 0;
-+	    else
-+		if (try.mppe_40 && try.mppe_128)
-+		    try.mppe_40 = 0;
-+		else
-+		    if (try.mppe_40 && try.mppe_56)
-+			try.mppe_40 = 0;
-+
-+	p += CILEN_MPPE;
-+	len -= CILEN_MPPE;
-     }
- #endif /* MPPE */
-+
-+    if (go->lzs && len >= CILEN_LZS && p[0] == CI_LZS && p[1] == CILEN_LZS) {
-+	no.lzs = 1;
-+	if (((p[2]<<8)|p[3]) > 1 || (p[4] != LZS_MODE_SEQ &&
-+				     p[4] != LZS_MODE_EXT))
-+	    try.lzs = 0;
-+	else {
-+	    try.lzs_mode = p[4];
-+	    try.lzs_hists = (p[2] << 8) | p[3];
-+	}
-+	p += CILEN_LZS;
-+	len -= CILEN_LZS;
-+    }
-+
-     if (go->deflate && len >= CILEN_DEFLATE
- 	&& p[0] == (go->deflate_correct? CI_DEFLATE: CI_DEFLATE_DRAFT)
- 	&& p[1] == CILEN_DEFLATE) {
-@@ -1002,14 +1255,50 @@ ccp_rejci(f, p, len)
- 	return -1;
- 
- #ifdef MPPE
--    if (go->mppe && len >= CILEN_MPPE
-+    if ((go->mppe || go->mppc) && len >= CILEN_MPPE
- 	&& p[0] == CI_MPPE && p[1] == CILEN_MPPE) {
--	error("MPPE required but peer refused");
--	lcp_close(f->unit, "MPPE required but peer refused");
-+	ccp_options *wo = &ccp_wantoptions[f->unit];
-+	if (p[2] != (go->mppe_stateless ? MPPE_STATELESS : 0) ||
-+	    p[3] != 0 ||
-+	    p[4] != 0 ||
-+	    p[5] != ((go->mppe_40 ? MPPE_40BIT : 0) |
-+		     (go->mppe_56 ? MPPE_56BIT : 0) |
-+		     (go->mppe_128 ? MPPE_128BIT : 0) |
-+		     (go->mppc ? MPPE_MPPC : 0)))
-+	    return 0;
-+	if (go->mppc)
-+	    try.mppc = 0;
-+	if (go->mppe) {
-+	    try.mppe = 0;
-+	    if (go->mppe_40)
-+		try.mppe_40 = 0;
-+	    if (go->mppe_56)
-+		try.mppe_56 = 0;
-+	    if (go->mppe_128)
-+		try.mppe_128 = 0;
-+	    if (go->mppe_stateless)
-+		try.mppe_stateless = 0;
-+	    if (!try.mppe_56 && !try.mppe_40 && !try.mppe_128)
-+		try.mppe = try.mppe_stateless = 0;
-+	    if (wo->mppe) { /* we want MPPE but cannot negotiate key length */
-+		wo->mppc = wo->mppe = wo->mppe_stateless = wo->mppe_40 =
-+		    wo->mppe_56 = wo->mppe_128 = 0;
-+		lcp_close(f->unit, "MPPE required but cannot negotiate MPPE "
-+			  "key length");
-+	    }
-+	}
- 	p += CILEN_MPPE;
- 	len -= CILEN_MPPE;
-     }
--#endif
-+#endif /* MPPE */
-+    if (go->lzs && len >= CILEN_LZS && p[0] == CI_LZS && p[1] == CILEN_LZS) {
-+	if (p[2] != go->lzs_hists>>8 || p[3] != (go->lzs_hists&0xff) 
-+	    || p[4] != go->lzs_mode)
-+	    return 0;
-+	try.lzs = 0;
-+	p += CILEN_LZS;
-+	len -= CILEN_LZS;
-+    }
-     if (go->deflate_correct && len >= CILEN_DEFLATE
- 	&& p[0] == CI_DEFLATE && p[1] == CILEN_DEFLATE) {
- 	if (p[2] != DEFLATE_MAKE_OPT(go->deflate_size)
-@@ -1073,14 +1362,15 @@ ccp_reqci(f, p, lenp, dont_nak)
-     int dont_nak;
- {
-     int ret, newret, res;
--    u_char *p0, *retp;
-+    u_char *p0, *retp, p2, p5;
-     int len, clen, type, nb;
-     ccp_options *ho = &ccp_hisoptions[f->unit];
-     ccp_options *ao = &ccp_allowoptions[f->unit];
-+    ccp_options *wo = &ccp_wantoptions[f->unit];
- #ifdef MPPE
--    bool rej_for_ci_mppe = 1;	/* Are we rejecting based on a bad/missing */
--				/* CI_MPPE, or due to other options?       */
--#endif
-+    u_char opt_buf[CILEN_MPPE + MPPE_MAX_KEY_LEN];
-+/*     int mtu; */
-+#endif /* MPPE */
- 
-     ret = CONFACK;
-     retp = p0 = p;
-@@ -1103,106 +1393,302 @@ ccp_reqci(f, p, lenp, dont_nak)
- 	    switch (type) {
- #ifdef MPPE
- 	    case CI_MPPE:
--		if (!ao->mppe || clen != CILEN_MPPE) {
-+ 		if ((!ao->mppc && !ao->mppe) || clen != CILEN_MPPE) {
- 		    newret = CONFREJ;
- 		    break;
- 		}
--		MPPE_CI_TO_OPTS(&p[2], ho->mppe);
--
--		/* Nak if anything unsupported or unknown are set. */
--		if (ho->mppe & MPPE_OPT_UNSUPPORTED) {
--		    newret = CONFNAK;
--		    ho->mppe &= ~MPPE_OPT_UNSUPPORTED;
--		}
--		if (ho->mppe & MPPE_OPT_UNKNOWN) {
-+ 		p2 = p[2];
-+ 		p5 = p[5];
-+ 		/* not sure what they want, tell 'em what we got */
-+ 		if (((p[2] & ~MPPE_STATELESS) != 0 || p[3] != 0 || p[4] != 0 ||
-+ 		     (p[5] & ~(MPPE_40BIT | MPPE_56BIT | MPPE_128BIT |
-+ 			       MPPE_MPPC)) != 0 || p[5] == 0) ||
-+ 		    (p[2] == 0 && p[3] == 0 && p[4] == 0 &&  p[5] == 0)) {
- 		    newret = CONFNAK;
--		    ho->mppe &= ~MPPE_OPT_UNKNOWN;
--		}
--
--		/* Check state opt */
--		if (ho->mppe & MPPE_OPT_STATEFUL) {
--		    /*
--		     * We can Nak and request stateless, but it's a
--		     * lot easier to just assume the peer will request
--		     * it if he can do it; stateful mode is bad over
--		     * the Internet -- which is where we expect MPPE.
--		     */
--		   if (refuse_mppe_stateful) {
--			error("Refusing MPPE stateful mode offered by peer");
--			newret = CONFREJ;
--			break;
-+ 		    p[2] = (wo->mppe_stateless ? MPPE_STATELESS : 0);
-+		    p[3] = 0;
-+ 		    p[4] = 0;
-+ 		    p[5] = (wo->mppe_40 ? MPPE_40BIT : 0) |
-+ 			(wo->mppe_56 ? MPPE_56BIT : 0) |
-+ 			(wo->mppe_128 ? MPPE_128BIT : 0) |
-+ 			(wo->mppc ? MPPE_MPPC : 0);
-+ 		    break;
-+  		}
-+
-+ 		if ((p[5] & MPPE_MPPC)) {
-+ 		    if (ao->mppc) {
-+ 			ho->mppc = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			opt_buf[2] = opt_buf[3] = opt_buf[4] = 0;
-+ 			opt_buf[5] = MPPE_MPPC;
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE, 1) <= 0) {
-+ 			    ho->mppc = 0;
-+ 			    p[5] &= ~MPPE_MPPC;
-+ 			    newret = CONFNAK;
-+ 			}
-+ 		    } else {
-+		      newret = CONFREJ;
-+ 			if (wo->mppe || ao->mppe) {
-+ 			    p[5] &= ~MPPE_MPPC;
-+ 			    newret = CONFNAK;
-+ 			}
- 		    }
- 		}
--
--		/* Find out which of {S,L} are set. */
--		if ((ho->mppe & MPPE_OPT_128)
--		     && (ho->mppe & MPPE_OPT_40)) {
--		    /* Both are set, negotiate the strongest. */
--		    newret = CONFNAK;
--		    if (ao->mppe & MPPE_OPT_128)
--			ho->mppe &= ~MPPE_OPT_40;
--		    else if (ao->mppe & MPPE_OPT_40)
--			ho->mppe &= ~MPPE_OPT_128;
--		    else {
--			newret = CONFREJ;
--			break;
--		    }
--		} else if (ho->mppe & MPPE_OPT_128) {
--		    if (!(ao->mppe & MPPE_OPT_128)) {
--			newret = CONFREJ;
--			break;
--		    }
--		} else if (ho->mppe & MPPE_OPT_40) {
--		    if (!(ao->mppe & MPPE_OPT_40)) {
--			newret = CONFREJ;
--			break;
--		    }
-+ 		if (ao->mppe)
-+ 		    ho->mppe = 1;
-+ 
-+ 		if ((p[2] & MPPE_STATELESS)) {
-+ 		    if (ao->mppe_stateless) {
-+ 			if (wo->mppe_stateless)
-+ 			    ho->mppe_stateless = 1;
-+ 			else {
-+ 			    newret = CONFNAK;
-+ 			    if (!dont_nak)
-+ 				p[2] &= ~MPPE_STATELESS;
-+ 			}
-+ 		    } else {
-+ 			newret = CONFNAK;
-+ 			if (!dont_nak)
-+ 			    p[2] &= ~MPPE_STATELESS;
-+ 		    }
-+ 		} else {
-+ 		    if (wo->mppe_stateless && !dont_nak) {
-+ 			wo->mppe_stateless = 0;
-+ 			newret = CONFNAK;
-+ 			p[2] |= MPPE_STATELESS;
-+  		    }
-+  		}
-+  
-+ 		if ((p[5] & ~MPPE_MPPC) == (MPPE_40BIT|MPPE_56BIT|MPPE_128BIT)) {
-+  		    newret = CONFNAK;
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			p[5] &= ~(MPPE_40BIT|MPPE_56BIT);
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] |= (MPPE_40BIT|MPPE_56BIT);
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    goto check_mppe_56_40;
-+ 			}
-+ 			goto check_mppe;
-+  		    }
-+ 		    p[5] &= ~MPPE_128BIT;
-+ 		    goto check_mppe_56_40;
-+ 		}
-+ 		if ((p[5] & ~MPPE_MPPC) == (MPPE_56BIT|MPPE_128BIT)) {
-+ 		    newret = CONFNAK;
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			p[5] &= ~MPPE_56BIT;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] |= MPPE_56BIT;
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    goto check_mppe_56;
-+ 			}
-+ 			goto check_mppe;
-+  		    }
-+ 		    p[5] &= ~MPPE_128BIT;
-+ 		    goto check_mppe_56;
-+ 		}
-+ 		if ((p[5] & ~MPPE_MPPC) == (MPPE_40BIT|MPPE_128BIT)) {
-+ 		    newret = CONFNAK;
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			p[5] &= ~MPPE_40BIT;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] |= MPPE_40BIT;
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    goto check_mppe_40;
-+ 			}
-+ 			goto check_mppe;
-+ 		    }
-+ 		    p[5] &= ~MPPE_128BIT;
-+ 		    goto check_mppe_40;
-+ 		}
-+ 		if ((p[5] & ~MPPE_MPPC) == MPPE_128BIT) {
-+ 		    if (ao->mppe_128) {
-+ 			ho->mppe_128 = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_128 = 0;
-+ 			    p[5] &= ~MPPE_128BIT;
-+ 			    newret = CONFNAK;
-+ 			}
-+ 			goto check_mppe;
-+ 		    }
-+		    p[5] &= ~MPPE_128BIT;
-+ 		    newret = CONFNAK;
-+ 		    goto check_mppe;
-+ 		}
-+ 	    check_mppe_56_40:
-+		if ((p[5] & ~MPPE_MPPC) == (MPPE_40BIT|MPPE_56BIT)) {
-+ 		    newret = CONFNAK;
-+ 		    if (ao->mppe_56) {
-+ 			ho->mppe_56 = 1;
-+ 			p[5] &= ~MPPE_40BIT;
-+			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_56 = 0;
-+ 			    p[5] |= MPPE_40BIT;
-+ 			    p[5] &= ~MPPE_56BIT;
-+			    newret = CONFNAK;
-+ 			    goto check_mppe_40;
-+ 			}
-+			goto check_mppe;
-+ 		    }
-+		    p[5] &= ~MPPE_56BIT;
-+ 		    goto check_mppe_40;
-+ 		}
-+ 	    check_mppe_56:
-+		if ((p[5] & ~MPPE_MPPC) == MPPE_56BIT) {
-+ 		    if (ao->mppe_56) {
-+ 			ho->mppe_56 = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+ 			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_56 = 0;
-+ 			    p[5] &= ~MPPE_56BIT;
-+			    newret = CONFNAK;
-+ 			}
-+			goto check_mppe;
-+ 		    }
-+ 		    p[5] &= ~MPPE_56BIT;
-+ 		    newret = CONFNAK;
-+		    goto check_mppe;
-+ 		}
-+ 	    check_mppe_40:
-+		if ((p[5] & ~MPPE_MPPC) == MPPE_40BIT) {
-+ 		    if (ao->mppe_40) {
-+ 			ho->mppe_40 = 1;
-+ 			BCOPY(p, opt_buf, CILEN_MPPE);
-+			BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
-+ 			      MPPE_MAX_KEY_LEN);
-+ 			if (ccp_test(f->unit, opt_buf, CILEN_MPPE +
-+ 				     MPPE_MAX_KEY_LEN, 1) <= 0) {
-+ 			    ho->mppe_40 = 0;
-+			    p[5] &= ~MPPE_40BIT;
-+ 			    newret = CONFNAK;
-+ 			}
-+ 			goto check_mppe;
-+ 		    }
-+ 		    p[5] &= ~MPPE_40BIT;
-+ 		}
-+ 
-+ 	    check_mppe:
-+ 		if (!ho->mppe_40 && !ho->mppe_56 && !ho->mppe_128) {
-+ 		    if (wo->mppe_40 || wo->mppe_56 || wo->mppe_128) {
-+ 			newret = CONFNAK;
-+ 			p[2] |= (wo->mppe_stateless ? MPPE_STATELESS : 0);
-+			p[5] |= (wo->mppe_40 ? MPPE_40BIT : 0) |
-+ 			    (wo->mppe_56 ? MPPE_56BIT : 0) |
-+ 			    (wo->mppe_128 ? MPPE_128BIT : 0) |
-+ 			    (wo->mppc ? MPPE_MPPC : 0);
-+ 		    } else {
-+ 			ho->mppe = ho->mppe_stateless = 0;
-+ 		    }
- 		} else {
--		    /* Neither are set. */
--		    /* We cannot accept this.  */
--		    newret = CONFNAK;
--		    /* Give the peer our idea of what can be used,
--		       so it can choose and confirm */
--		    ho->mppe = ao->mppe;
--		}
--
--		/* rebuild the opts */
--		MPPE_OPTS_TO_CI(ho->mppe, &p[2]);
--		if (newret == CONFACK) {
--		    u_char opt_buf[CILEN_MPPE + MPPE_MAX_KEY_LEN];
--		    int mtu;
--
--		    BCOPY(p, opt_buf, CILEN_MPPE);
--		    BCOPY(mppe_send_key, &opt_buf[CILEN_MPPE],
--			  MPPE_MAX_KEY_LEN);
--		    if (ccp_test(f->unit, opt_buf,
--				 CILEN_MPPE + MPPE_MAX_KEY_LEN, 1) <= 0) {
--			/* This shouldn't happen, we've already tested it! */
--			error("MPPE required, but kernel has no support.");
--			lcp_close(f->unit, "MPPE required but not available");
--			newret = CONFREJ;
--			break;
--		    }
--		    /*
--		     * We need to decrease the interface MTU by MPPE_PAD
--		     * because MPPE frames **grow**.  The kernel [must]
--		     * allocate MPPE_PAD extra bytes in xmit buffers.
--		     */
--		    mtu = netif_get_mtu(f->unit);
--		    if (mtu)
--			netif_set_mtu(f->unit, mtu - MPPE_PAD);
--		    else
--			newret = CONFREJ;
--		}
--
--		/*
--		 * We have accepted MPPE or are willing to negotiate
--		 * MPPE parameters.  A CONFREJ is due to subsequent
--		 * (non-MPPE) processing.
--		 */
--		rej_for_ci_mppe = 0;
--		break;
--#endif /* MPPE */
-+ 		    /* MPPE is not compatible with other compression types */
-+ 		    if (wo->mppe) {
-+ 			ao->bsd_compress = 0;
-+ 			ao->predictor_1 = 0;
-+ 			ao->predictor_2 = 0;
-+			ao->deflate = 0;
-+ 			ao->lzs = 0;
-+ 		    }
-+ 		}
-+ 		if ((!ho->mppc || !ao->mppc) && !ho->mppe) {
-+ 		    p[2] = p2;
-+ 		    p[5] = p5;
-+  		    newret = CONFREJ;
-+  		    break;
-+  		}
-+  
-+ 		/*
-+ 		 * I have commented the code below because according to RFC1547
-+ 		 * MTU is only information for higher level protocols about
-+ 		 * "the maximum allowable length for a packet (q.v.) transmitted
-+ 		 * over a point-to-point link without incurring network layer
-+ 		 * fragmentation." Of course a PPP implementation should be able
-+ 		 * to handle overhead added by MPPE - in our case apropriate code
-+ 		 * is located in drivers/net/ppp_generic.c in the kernel sources.
-+		 *
-+ 		 * According to RFC1661:
-+ 		 * - when negotiated MRU is less than 1500 octets, a PPP
-+ 		 *   implementation must still be able to receive at least 1500
-+ 		 *   octets,
-+ 		 * - when PFC is negotiated, a PPP implementation is still
-+ 		 *   required to receive frames with uncompressed protocol field.
-+		 *
-+ 		 * So why not to handle MPPE overhead without changing MTU value?
-+ 		 * I am sure that RFC3078, unfortunately silently, assumes that.
-+ 		 */
-+ 
-+ 		/*
-+ 		 * We need to decrease the interface MTU by MPPE_PAD
-+ 		 * because MPPE frames **grow**.  The kernel [must]
-+ 		 * allocate MPPE_PAD extra bytes in xmit buffers.
-+ 		 */
-+ /*
-+ 		mtu = netif_get_mtu(f->unit);
-+ 		if (mtu) {
-+ 		    netif_set_mtu(f->unit, mtu - MPPE_PAD);
-+ 		} else {
-+		    newret = CONFREJ;
-+ 		    if (ccp_wantoptions[f->unit].mppe) {
-+ 			error("Cannot adjust MTU needed by MPPE.");
-+ 			lcp_close(f->unit, "Cannot adjust MTU needed by MPPE.");
-+ 		    }
-+ 		}
-+ */
-+ 		break;
-+  #endif /* MPPE */
-+ 
-+	    case CI_LZS:
-+ 		if (!ao->lzs || clen != CILEN_LZS) {
-+ 		    newret = CONFREJ;
-+ 		    break;
-+ 		}
-+ 
-+ 		ho->lzs = 1;
-+		ho->lzs_hists = (p[2] << 8) | p[3];
-+ 		ho->lzs_mode = p[4];
-+	if ((ho->lzs_hists != ao->lzs_hists) ||
-+		    (ho->lzs_mode != ao->lzs_mode)) {
-+ 		    newret = CONFNAK;
-+ 		    if (!dont_nak) {
-+ 			p[2] = ao->lzs_hists >> 8;
-+ 			p[3] = ao->lzs_hists & 0xff;
-+ 			p[4] = ao->lzs_mode;
-+	    } else
-+ 			break;
-+ 		}
-+ 
-+ 		if (p == p0 && ccp_test(f->unit, p, CILEN_LZS, 1) <= 0) {
-+ 		    newret = CONFREJ;
-+ 		}
-+ 		break;
- 	    case CI_DEFLATE:
- 	    case CI_DEFLATE_DRAFT:
- 		if (!ao->deflate || clen != CILEN_DEFLATE
-@@ -1344,12 +1830,6 @@ ccp_reqci(f, p, lenp, dont_nak)
- 	else
- 	    *lenp = retp - p0;
-     }
--#ifdef MPPE
--    if (ret == CONFREJ && ao->mppe && rej_for_ci_mppe) {
--	error("MPPE required but peer negotiation failed");
--	lcp_close(f->unit, "MPPE required but peer negotiation failed");
--    }
--#endif
-     return ret;
- }
- 
-@@ -1371,24 +1851,35 @@ method_name(opt, opt2)
- 	char *p = result;
- 	char *q = result + sizeof(result); /* 1 past result */
- 
--	slprintf(p, q - p, "MPPE ");
--	p += 5;
--	if (opt->mppe & MPPE_OPT_128) {
--	    slprintf(p, q - p, "128-bit ");
--	    p += 8;
--	}
--	if (opt->mppe & MPPE_OPT_40) {
--	    slprintf(p, q - p, "40-bit ");
--	    p += 7;
--	}
--	if (opt->mppe & MPPE_OPT_STATEFUL)
--	    slprintf(p, q - p, "stateful");
--	else
--	    slprintf(p, q - p, "stateless");
--
-+	if (opt->mppe) {
-+	    if (opt->mppc) {
-+		slprintf(p, q - p, "MPPC/MPPE ");
-+		p += 10;
-+	    } else {
-+		slprintf(p, q - p, "MPPE ");
-+		p += 5;
-+	    }
-+	    if (opt->mppe_128) {
-+		slprintf(p, q - p, "128-bit ");
-+		p += 8;
-+	    } else if (opt->mppe_56) {
-+		slprintf(p, q - p, "56-bit ");
-+		p += 7;
-+	    } else if (opt->mppe_40) {
-+		slprintf(p, q - p, "40-bit ");
-+		p += 7;
-+	    }
-+	    if (opt->mppe_stateless)
-+		slprintf(p, q - p, "stateless");
-+	    else
-+		slprintf(p, q - p, "stateful");
-+	} else if (opt->mppc)
-+	    slprintf(p, q - p, "MPPC");
- 	break;
-     }
--#endif
-+#endif /* MPPE */
-+    case CI_LZS:
-+	return "Stac LZS";
-     case CI_DEFLATE:
-     case CI_DEFLATE_DRAFT:
- 	if (opt2 != NULL && opt2->deflate_size != opt->deflate_size)
-@@ -1444,12 +1935,12 @@ ccp_up(f)
-     } else if (ANY_COMPRESS(*ho))
- 	notice("%s transmit compression enabled", method_name(ho, NULL));
- #ifdef MPPE
--    if (go->mppe) {
-+    if (go->mppe || go->mppc) {
- 	BZERO(mppe_recv_key, MPPE_MAX_KEY_LEN);
- 	BZERO(mppe_send_key, MPPE_MAX_KEY_LEN);
- 	continue_networks(f->unit);		/* Bring up IP et al */
-     }
--#endif
-+#endif /* MPPE */
- }
- 
- /*
-@@ -1472,7 +1963,7 @@ ccp_down(f)
- 	    lcp_close(f->unit, "MPPE disabled");
- 	}
-     }
--#endif
-+#endif /* MPPE */
- }
- 
- /*
-@@ -1532,24 +2023,28 @@ ccp_printpkt(p, plen, printer, arg)
- #ifdef MPPE
- 	    case CI_MPPE:
- 		if (optlen >= CILEN_MPPE) {
--		    u_char mppe_opts;
--
--		    MPPE_CI_TO_OPTS(&p[2], mppe_opts);
--		    printer(arg, "mppe %s %s %s %s %s %s%s",
--			    (p[2] & MPPE_H_BIT)? "+H": "-H",
--			    (p[5] & MPPE_M_BIT)? "+M": "-M",
--			    (p[5] & MPPE_S_BIT)? "+S": "-S",
--			    (p[5] & MPPE_L_BIT)? "+L": "-L",
-+		    printer(arg, "mppe %s %s %s %s %s %s",
-+			    (p[2] & MPPE_STATELESS)? "+H": "-H",
-+			    (p[5] & MPPE_56BIT)? "+M": "-M",
-+			    (p[5] & MPPE_128BIT)? "+S": "-S",
-+			    (p[5] & MPPE_40BIT)? "+L": "-L",
- 			    (p[5] & MPPE_D_BIT)? "+D": "-D",
--			    (p[5] & MPPE_C_BIT)? "+C": "-C",
--			    (mppe_opts & MPPE_OPT_UNKNOWN)? " +U": "");
--		    if (mppe_opts & MPPE_OPT_UNKNOWN)
-+			    (p[5] & MPPE_MPPC)? "+C": "-C");
-+		    if ((p[5] & ~(MPPE_56BIT | MPPE_128BIT | MPPE_40BIT |
-+				  MPPE_D_BIT | MPPE_MPPC)) ||
-+			(p[2] & ~MPPE_STATELESS))
- 			printer(arg, " (%.2x %.2x %.2x %.2x)",
- 				p[2], p[3], p[4], p[5]);
- 		    p += CILEN_MPPE;
- 		}
- 		break;
--#endif
-+#endif /* MPPE */
-+	    case CI_LZS:
-+		if (optlen >= CILEN_LZS) {
-+		    printer(arg, "lzs %.2x %.2x %.2x", p[2], p[3], p[4]);
-+		    p += CILEN_LZS;
-+		}
-+		break;
- 	    case CI_DEFLATE:
- 	    case CI_DEFLATE_DRAFT:
- 		if (optlen >= CILEN_DEFLATE) {
-@@ -1635,6 +2130,7 @@ ccp_datainput(unit, pkt, len)
- 	    error("Lost compression sync: disabling compression");
- 	    ccp_close(unit, "Lost compression sync");
- #ifdef MPPE
-+	    /* My module dosn't need this. J.D., 2003-07-06 */
- 	    /*
- 	     * If we were doing MPPE, we must also take the link down.
- 	     */
-@@ -1642,9 +2138,18 @@ ccp_datainput(unit, pkt, len)
- 		error("Too many MPPE errors, closing LCP");
- 		lcp_close(unit, "Too many MPPE errors");
- 	    }
--#endif
-+#endif /* MPPE */
- 	} else {
- 	    /*
-+	     * When LZS or MPPE/MPPC is negotiated we just send CCP_RESETREQ
-+	     * and don't wait for CCP_RESETACK
-+	     */
-+	    if ((ccp_gotoptions[f->unit].method == CI_LZS) ||
-+		(ccp_gotoptions[f->unit].method == CI_MPPE)) {
-+		fsm_sdata(f, CCP_RESETREQ, f->reqid = ++f->id, NULL, 0);
-+		return;
-+	    }
-+	    /*
- 	     * Send a reset-request to reset the peer's compressor.
- 	     * We don't do that if we are still waiting for an
- 	     * acknowledgement to a previous reset-request.
---- a/pppd/ccp.h
-+++ b/pppd/ccp.h
-@@ -37,9 +37,17 @@ typedef struct ccp_options {
-     bool predictor_2;		/* do Predictor-2? */
-     bool deflate_correct;	/* use correct code for deflate? */
-     bool deflate_draft;		/* use draft RFC code for deflate? */
-+    bool lzs;			/* do Stac LZS? */
-+    bool mppc;			/* do MPPC? */
-     bool mppe;			/* do MPPE? */
-+    bool mppe_40;		/* allow 40 bit encryption? */
-+    bool mppe_56;		/* allow 56 bit encryption? */
-+    bool mppe_128;		/* allow 128 bit encryption? */
-+    bool mppe_stateless;	/* allow stateless encryption */
-     u_short bsd_bits;		/* # bits/code for BSD Compress */
-     u_short deflate_size;	/* lg(window size) for Deflate */
-+    u_short lzs_mode;		/* LZS check mode */
-+    u_short lzs_hists;		/* number of LZS histories */
-     short method;		/* code for chosen compression method */
- } ccp_options;
- 
---- a/pppd/chap_ms.c
-+++ b/pppd/chap_ms.c
-@@ -963,13 +963,17 @@ set_mppe_enc_types(int policy, int types
-     /*
-      * Disable undesirable encryption types.  Note that we don't ENABLE
-      * any encryption types, to avoid overriding manual configuration.
-+     *
-+     * It seems that 56 bit keys are unsupported in MS-RADIUS (see RFC 2548)
-      */
-     switch(types) {
- 	case MPPE_ENC_TYPES_RC4_40:
--	    ccp_wantoptions[0].mppe &= ~MPPE_OPT_128;	/* disable 128-bit */
-+	    ccp_wantoptions[0].mppe_128 = 0;	/* disable 128-bit */
-+	    ccp_wantoptions[0].mppe_56 = 0;	/* disable 56-bit */
- 	    break;
- 	case MPPE_ENC_TYPES_RC4_128:
--	    ccp_wantoptions[0].mppe &= ~MPPE_OPT_40;	/* disable 40-bit */
-+	    ccp_wantoptions[0].mppe_56 = 0;	/* disable 56-bit */
-+	    ccp_wantoptions[0].mppe_40 = 0;	/* disable 40-bit */
- 	    break;
- 	default:
- 	    break;
Index: openwrt/package/network/services/ppp/patches/600-eaptls-mppe-0.998.patch
===================================================================
--- /dev/null
+++ openwrt/package/network/services/ppp/patches/600-eaptls-mppe-0.998.patch
@@ -0,0 +1,3109 @@
+diff -Naur ppp-2.4.7/README.eap-tls ppp-2.4.7-eaptls-mppe-0.998/README.eap-tls
+--- ppp-2.4.7/README.eap-tls	1970-01-01 01:00:00.000000000 +0100
++++ ppp-2.4.7-eaptls-mppe-0.998/README.eap-tls	2015-03-10 16:51:32.694097140 +0100
+@@ -0,0 +1,280 @@
++EAP-TLS authentication support for PPP
++======================================
++
++1. Intro
++
++    The Extensible Authentication Protocol (EAP; RFC 3748) is a
++    security protocol that can be used with PPP.  It provides a means
++    to plug in multiple optional authentication methods.
++
++    Transport Level Security (TLS; RFC 2246) provides for mutual 
++    authentication, integrity-protected ciphersuite negotiation and 
++    key exchange between two endpoints.  It also provides for optional
++    MPPE encryption.
++
++    EAP-TLS (RFC 2716) incapsulates the TLS messages in EAP packets,
++    allowing TLS mutual authentication to be used as a generic EAP
++    mechanism. It also provides optional encryption using the MPPE
++    protocol.
++
++    This patch provide EAP-TLS support to pppd.
++    This authentication method can be used in both client or server
++    mode.
++
++2. Building
++
++    To build pppd with EAP-TLS support, OpenSSL (http://www.openssl.org)
++    is required. Any version from 0.9.7 should work.
++    
++    Configure, compile, and install as usual. 
++
++3. Configuration
++
++    On the client side there are two ways to configure EAP-TLS:
++
++    1. supply the appropriate 'ca', 'cert' and 'key' command-line parameters
++
++    2. edit the /etc/ppp/eaptls-client file.
++    Insert a line for each system with which you use EAP-TLS.
++    The line is composed of this fields separated by tab:
++
++      - Client name 
++        The name used by the client for authentication, can be *
++      - Server name
++        The name of the server, can be *
++      - Client certificate file 
++        The file containing the certificate chain for the 
++        client in PEM format
++      - Server certificate file
++        If you want to specify the certificate that the 
++        server is allowed to use, put the certificate file name.
++        Else put a dash '-'.
++      - CA certificate file
++        The file containing the trusted CA certificates in PEM
++        format.
++      - Client private key file
++        The file containing the client private key in PEM format.
++
++
++    On the server side edit the /etc/ppp/eaptls-server file.
++    Insert a line for each system with which you use EAP-TLS.
++    The line is composed of this fields separated by tab:
++
++      - Client name
++        The name used by the client for authentication, can be *
++      - Server name
++        The name of the server, can be *
++      - Client certificate file
++        If you want to specify the certificate that the
++        client is allowed to use, put the certificate file name.
++        Else put a dash '-'.
++      - Server certificate file
++        The file containing the certificate chain for the
++        server in PEM format
++      - CA certificate file
++        The file containing the trusted CA certificates in PEM format.
++      - Client private key file
++        The file containing the server private key in PEM format.
++      - addresses
++        A list of IP addresses the client is allowed to use.
++
++
++    OpenSSL engine support is included starting with v0.95 of this patch. 
++    Currently the only engine tested is the 'pkcs11' engine (hardware token
++    support). To use the 'pksc11' engine:
++      - Use a special private key fileiname in the /etc/ppp/eaptls-client file:
++          <engine>:<identifier>
++        e.g.
++          pkcs11:123456
++
++      - The certificate can also be loaded from the 'pkcs11' engine using
++        a special client certificate filename in the /etc/ppp/eaptls-client file:
++          <engine>:<identifier>
++        e.g.
++          pkcs11:123456
++
++      - Create an /etc/ppp/openssl.cnf file to load the right OpenSSL engine prior
++        to starting 'pppd'. A sample openssl.cnf file is
++
++        openssl_conf = openssl_def
++
++        [ openssl_def ]
++        engines = engine_section
++
++        [ engine_section ]
++        pkcs11 = pkcs11_section
++
++        [ pkcs11_section ]
++        engine_id = pkcs11
++        dynamic_path = /usr/lib64/openssl/engines/engine_pkcs11.so
++        MODULE_PATH = /usr/lib64/libeTPkcs11.so
++        init = 0
++
++      - There are two ways to specify a password/PIN for the PKCS11 engine:
++          - inside the openssl.cnf file using
++              PIN = your-secret-pin
++            Note The keyword 'PIN' is case sensitive!
++          - Using the 'password' in the ppp options file.
++        From v0.97 of the eap-tls patch the password can also be supplied
++        using the appropriate 'eaptls_passwd_hook' (see plugins/passprompt.c
++        for an example).
++
++
++4. Options
++
++    These pppd options are available:
++
++      ca <ca-file>
++        Use the CA public certificate found in <ca-file> in PEM format
++      cert <cert-file>
++        Use the client public certificate found in <cert-file> in PEM format
++        or in engine:engine_id format
++      key <key-file>
++        Use the client private key found in <key-file> in PEM format
++        or in engine:engine_id format
++      crl <crl-file>
++        Use the Certificate Revocation List (CRL) file <crl-file> in PEM format.
++      crl-dir <dir>
++        Use CRL files from directory <dir>. It contains CRL files in PEM
++        format and each file contains a CRL. The files are looked up 
++        by the issuer name hash value. Use the c_rehash utility 
++        to create necessary links.
++      need-peer-eap
++        If the peer doesn't ask us to authenticate or doesn't use eap
++        to authenticate us, disconnect.
++
++    Note: 
++      password-encrypted certificates can be used as of v0.94 of this 
++      patch. The password for the eap-tls.key file is specified using 
++      the regular
++          password ....
++      statement in the ppp options file, or by using the appropriate
++      plugin which supplies a 'eaptls_passwd_hook' routine.
++
++5. Connecting
++
++    If you're setting up a pppd server, edit the EAP-TLS configuration file 
++    as written above and then run pppd with the 'auth' option to authenticate
++    the client. The EAP-TLS method will be used if the other eap methods can't
++    be used (no secrets).
++
++    If you're setting up a client, edit the configuration file and then run
++    pppd with 'remotename' option to specify the server name. Add the 
++    'need-peer-eap' option if you want to be sure the peer ask you to
++    authenticate (and to use eap) and to disconnect if it doesn't.
++
++6. Example
++
++    The following example can be used to connect a Linux client with the 'pptp'
++    package to a Linux server running the 'pptpd' (PoPToP) package. The server
++    was configured with a certificate with name (CN) 'pptp-server', the client
++    was configured with a certificate with name (CN) 'pptp-client', both 
++    signed by the same Certificate Authority (CA).
++
++    Server side:
++      - /etc/pptpd.conf file:
++          option /etc/ppp/options-pptpd-eaptls
++          localip 172.16.1.1
++          remoteip 172.16.1.10-20 
++      - /etc/ppp/options-pptpd-eaptls file:
++          name pptp-server
++          lock 
++          mtu 1500 
++          mru 1450
++          auth 
++          lcp-echo-failure 3 
++          lcp-echo-interval 5 
++          nodeflate 
++          nobsdcomp
++          nopredictor1
++          nopcomp
++          noaccomp
++          
++          require-eap
++          require-mppe-128
++          
++          crl /home/janjust/ppp/keys/crl.pem
++          
++          debug
++          logfile /tmp/pppd.log
++
++      - /etc/ppp/eaptls-server file:
++           * pptp-server - /etc/ppp/pptp-server.crt /etc/ppp/ca.crt /etc/ppp/pptp-server.key *
++
++      - On the server, run 
++          pptdp --conf /etc/pptpd.conf
++       
++    Client side:
++      - Run
++          pppd noauth require-eap require-mppe-128 \
++            ipcp-accept-local ipcp-accept-remote noipdefault \
++            cert  /etc/ppp/keys/pptp-client.crt \
++            key   /etc/ppp/keys/pptp-client.key \
++            ca    /etc/ppp/keys/ca.crt \
++            name pptp-client remotename pptp-server \
++            debug logfile /tmp/pppd.log
++            pty "pptp pptp-server.example.com --nolaunchpppd"
++
++    Check /var/log/messages and the files /tmp/pppd.log on both sides for debugging info.
++
++7. Notes
++
++    This is experimental code.
++    Send suggestions and comments to Jan Just Keijser <janjust@nikhef.nl>
++
++8. Changelog of ppp-<>-eaptls-mppe-* patches
++
++v0.7     (22-Nov-2005)
++ - First version of the patch to include MPPE support
++ - ppp-2.4.3 only
++v0.9     (25-Jul-2006)
++ - Bug fixes
++ - First version for ppp-2.4.4
++v0.91    (03-Sep-2006)
++ - Added missing #include for md5.h
++ - Last version for ppp-2.4.3
++v0.92    (22-Apr-2008)
++ - Fix for openssl 0.9.8 issue with md5 function overload.
++v0.93    (14-Aug-2008)
++ - Make sure 'noauth' option can be used to bypass server certificate verification.
++v0.94    (15-Oct-2008)
++ - Added support for password-protected private keys by (ab)using the 'password' field. 
++v0.95    (23-Dec-2009)
++ - First version with OpenSSL engine support.
++v0.96    (27-Jan-2010)
++ - Added fully functional support for OpenSSL engines (PKCS#11)
++ - First version for ppp-2.4.5
++v0.97    (20-Apr-2010)
++ - Some bug fixes for v0.96
++ - Added support for entering the password via a plugin. The sample plugin 
++     .../pppd/plugins/passprompt.c has been extended with EAP-TLS support.
++   The "old" methods using the password option or the /etc/ppp/openssl.cnf file still work.
++ - Added support for specifying the client CA, certificate and private key on the command-line
++   or via the ppp config file.
++v0.98    (20-Apr-2010)
++ - Fix initialisation bug when using ca/cert/key command-line options.
++ - Last version for ppp-2.4.4
++v0.99    (05-Oct-2010)
++ - Fix coredump when using multilink option.
++v0.991   (08-Aug-2011)
++ - Fix compilation issue with openssl 1.0.
++v0.992   (01-Dec-2011)
++ - Fix compilation issue with eaptls_check_hook and passwordfd plugin.
++v0.993   (24-Apr-2012)
++ - Fix compilation issue when EAP_TLS=n in pppd/Makefile.
++v0.994   (11-Jun-2012)
++ - Fix compilation issue on Ubuntu 11.10.
++v0.995   (27-May-2014)
++ - Add support for a CRL file using the command-line option 'crl' 
++   (prior only 'crl-dir' was supported).
++ - Fix segfault when pkcs11 enginename was not specified correctly.
++ - Fix segfault when client was misconfigured.
++ - Disable SSL Session Ticket support as Windows 8 does not support this.
++v0.996   (28-May-2014)
++ - Fix minor bug where SessionTicket message was printed as 'Unknown SSL3 code 4'
++ - Add EAP-TLS-specific options to pppd.8 manual page.
++ - Updated README.eap-tls file with new option and provide an example.
++v0.997   (19-Jun-2014)
++ - change SSL_OP_NO_TICKETS to SSL_OP_NO_TICKET
++ - fix bug in initialisation code with fragmented packets.
++
+diff -Naur ppp-2.4.7/etc.ppp/eaptls-client ppp-2.4.7-eaptls-mppe-0.998/etc.ppp/eaptls-client
+--- ppp-2.4.7/etc.ppp/eaptls-client	1970-01-01 01:00:00.000000000 +0100
++++ ppp-2.4.7-eaptls-mppe-0.998/etc.ppp/eaptls-client	2015-03-10 16:51:32.695097151 +0100
+@@ -0,0 +1,10 @@
++# Parameters for authentication using EAP-TLS (client)
++
++# client name (can be *)
++# server name (can be *)
++# client certificate file (required)
++# server certificate file (optional, if unused put '-')
++# CA certificate file (required)
++# client private key file (required)
++
++#client	server	/root/cert/client.crt	-	/root/cert/ca.crt	/root/cert/client.key
+diff -Naur ppp-2.4.7/etc.ppp/eaptls-server ppp-2.4.7-eaptls-mppe-0.998/etc.ppp/eaptls-server
+--- ppp-2.4.7/etc.ppp/eaptls-server	1970-01-01 01:00:00.000000000 +0100
++++ ppp-2.4.7-eaptls-mppe-0.998/etc.ppp/eaptls-server	2015-03-10 16:51:32.695097151 +0100
+@@ -0,0 +1,11 @@
++# Parameters for authentication using EAP-TLS (server)
++
++# client name (can be *)
++# server name (can be *)
++# client certificate file (optional, if unused put '-')
++# server certificate file (required)
++# CA certificate file (required)
++# server private key file (required)
++# allowed addresses (required, can be *)
++
++#client	server	-	/root/cert/server.crt	/root/cert/ca.crt	/root/cert/server.key	192.168.1.0/24
+diff -Naur ppp-2.4.7/etc.ppp/openssl.cnf ppp-2.4.7-eaptls-mppe-0.998/etc.ppp/openssl.cnf
+--- ppp-2.4.7/etc.ppp/openssl.cnf	1970-01-01 01:00:00.000000000 +0100
++++ ppp-2.4.7-eaptls-mppe-0.998/etc.ppp/openssl.cnf	2015-03-10 16:51:32.696097159 +0100
+@@ -0,0 +1,14 @@
++openssl_conf = openssl_def
++
++[ openssl_def ]
++engines = engine_section
++
++[ engine_section ]
++pkcs11 = pkcs11_section
++
++[ pkcs11_section ]
++engine_id = pkcs11
++dynamic_path = /usr/lib64/openssl/engines/engine_pkcs11.so
++MODULE_PATH = /usr/lib64/libeTPkcs11.so
++init = 0
++
+diff -Naur ppp-2.4.7/linux/Makefile.top ppp-2.4.7-eaptls-mppe-0.998/linux/Makefile.top
+--- ppp-2.4.7/linux/Makefile.top	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/linux/Makefile.top	2015-03-10 16:51:32.697097168 +0100
+@@ -26,7 +26,7 @@
+ 	cd pppdump; $(MAKE) $(MFLAGS) install
+ 
+ install-etcppp: $(ETCDIR) $(ETCDIR)/options $(ETCDIR)/pap-secrets \
+-	$(ETCDIR)/chap-secrets
++	$(ETCDIR)/chap-secrets $(ETCDIR)/eaptls-server $(ETCDIR)/eaptls-client
+ 
+ install-devel:
+ 	cd pppd; $(MAKE) $(MFLAGS) install-devel
+@@ -37,6 +37,10 @@
+ 	$(INSTALL) -c -m 600 etc.ppp/pap-secrets $@
+ $(ETCDIR)/chap-secrets:
+ 	$(INSTALL) -c -m 600 etc.ppp/chap-secrets $@
++$(ETCDIR)/eaptls-server:
++	$(INSTALL) -c -m 600 etc.ppp/eaptls-server $@
++$(ETCDIR)/eaptls-client:
++	$(INSTALL) -c -m 600 etc.ppp/eaptls-client $@
+ 
+ $(BINDIR):
+ 	$(INSTALL) -d -m 755 $@
+diff -Naur ppp-2.4.7/pppd/Makefile.linux ppp-2.4.7-eaptls-mppe-0.998/pppd/Makefile.linux
+--- ppp-2.4.7/pppd/Makefile.linux	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/Makefile.linux	2015-03-10 16:51:32.697097168 +0100
+@@ -76,6 +76,9 @@
+ # Use libutil
+ USE_LIBUTIL=y
+ 
++# Enable EAP-TLS authentication (requires libssl and libcrypto)
++USE_EAPTLS=y
++
+ MAXOCTETS=y
+ 
+ INCLUDE_DIRS= -I../include
+@@ -115,6 +118,15 @@
+ PPPDOBJS += sha1.o
+ endif
+ 
++# EAP-TLS
++ifdef USE_EAPTLS
++CFLAGS += -DUSE_EAPTLS=1 -I/usr/kerberos/include
++LIBS += -lssl -lcrypto
++PPPDSRC += eap-tls.c
++HEADERS += eap-tls.h
++PPPDOBJS += eap-tls.o
++endif
++
+ ifdef HAS_SHADOW
+ CFLAGS   += -DHAS_SHADOW
+ #LIBS     += -lshadow $(LIBS)
+diff -Naur ppp-2.4.7/pppd/auth.c ppp-2.4.7-eaptls-mppe-0.998/pppd/auth.c
+--- ppp-2.4.7/pppd/auth.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/auth.c	2015-03-10 16:51:32.699097185 +0100
+@@ -109,6 +109,9 @@
+ #include "upap.h"
+ #include "chap-new.h"
+ #include "eap.h"
++#ifdef USE_EAPTLS
++#include "eap-tls.h"
++#endif
+ #ifdef CBCP_SUPPORT
+ #include "cbcp.h"
+ #endif
+@@ -183,6 +186,11 @@
+ /* Hook for a plugin to get the CHAP password for authenticating us */
+ int (*chap_passwd_hook) __P((char *user, char *passwd)) = NULL;
+ 
++#ifdef USE_EAPTLS
++/* Hook for a plugin to get the EAP-TLS password for authenticating us */
++int (*eaptls_passwd_hook) __P((char *user, char *passwd)) = NULL;
++#endif
++
+ /* Hook for a plugin to say whether it is OK if the peer
+    refuses to authenticate. */
+ int (*null_auth_hook) __P((struct wordlist **paddrs,
+@@ -238,6 +246,14 @@
+ bool explicit_user = 0;		/* Set if "user" option supplied */
+ bool explicit_passwd = 0;	/* Set if "password" option supplied */
+ char remote_name[MAXNAMELEN];	/* Peer's name for authentication */
++#ifdef USE_EAPTLS
++char *cacert_file  = NULL;	/* CA certificate file (pem format) */
++char *cert_file    = NULL;	/* client certificate file (pem format) */
++char *privkey_file = NULL;	/* client private key file (pem format) */
++char *crl_dir      = NULL;	/* directory containing CRL files */
++char *crl_file     = NULL;	/* Certificate Revocation List (CRL) file (pem format) */
++bool need_peer_eap = 0;			/* Require peer to authenticate us */
++#endif
+ 
+ static char *uafname;		/* name of most recent +ua file */
+ 
+@@ -254,6 +270,19 @@
+ static int  have_chap_secret __P((char *, char *, int, int *));
+ static int  have_srp_secret __P((char *client, char *server, int need_ip,
+     int *lacks_ipp));
++
++#ifdef USE_EAPTLS
++static int  have_eaptls_secret_server
++__P((char *client, char *server, int need_ip, int *lacks_ipp));
++static int  have_eaptls_secret_client __P((char *client, char *server));
++static int  scan_authfile_eaptls __P((FILE * f, char *client, char *server,
++			       char *cli_cert, char *serv_cert,
++			       char *ca_cert, char *pk,
++			       struct wordlist ** addrs,
++			       struct wordlist ** opts,
++			       char *filename, int flags));
++#endif
++
+ static int  ip_addr_check __P((u_int32_t, struct permitted_ip *));
+ static int  scan_authfile __P((FILE *, char *, char *, char *,
+ 			       struct wordlist **, struct wordlist **,
+@@ -401,6 +430,15 @@
+       "Set telephone number(s) which are allowed to connect",
+       OPT_PRIV | OPT_A2LIST },
+ 
++#ifdef USE_EAPTLS
++    { "ca", o_string, &cacert_file,   "EAP-TLS CA certificate in PEM format" },
++    { "cert", o_string, &cert_file,   "EAP-TLS client certificate in PEM format" },
++    { "key", o_string, &privkey_file, "EAP-TLS client private key in PEM format" },
++    { "crl-dir", o_string, &crl_dir,  "Use CRLs in directory" },
++    { "crl", o_string, &crl_file,     "Use specific CRL file" },
++    { "need-peer-eap", o_bool, &need_peer_eap,
++      "Require the peer to authenticate us", 1 },
++#endif /* USE_EAPTLS */
+     { NULL }
+ };
+ 
+@@ -730,6 +768,9 @@
+     lcp_options *wo = &lcp_wantoptions[unit];
+     lcp_options *go = &lcp_gotoptions[unit];
+     lcp_options *ho = &lcp_hisoptions[unit];
++#ifdef USE_EAPTLS
++    lcp_options *ao = &lcp_allowoptions[unit];
++#endif
+     int i;
+     struct protent *protp;
+ 
+@@ -764,6 +805,22 @@
+ 	}
+     }
+ 
++#ifdef USE_EAPTLS
++    if (need_peer_eap && !ao->neg_eap) {
++	warn("eap required to authenticate us but no suitable secrets");
++	lcp_close(unit, "couldn't negotiate eap");
++	status = EXIT_AUTH_TOPEER_FAILED;
++	return;
++    }
++
++    if (need_peer_eap && !ho->neg_eap) {
++	warn("peer doesn't want to authenticate us with eap");
++	lcp_close(unit, "couldn't negotiate eap");
++	status = EXIT_PEER_AUTH_FAILED;
++	return;
++    }
++#endif
++
+     new_phase(PHASE_AUTHENTICATE);
+     auth = 0;
+     if (go->neg_eap) {
+@@ -1277,6 +1334,15 @@
+ 				    our_name, 1, &lacks_ip);
+     }
+ 
++#ifdef USE_EAPTLS
++    if (!can_auth && wo->neg_eap) {
++	can_auth =
++	    have_eaptls_secret_server((explicit_remote ? remote_name :
++				       NULL), our_name, 1, &lacks_ip);
++
++    }
++#endif
++
+     if (auth_required && !can_auth && noauth_addrs == NULL) {
+ 	if (default_auth) {
+ 	    option_error(
+@@ -1331,7 +1397,11 @@
+ 	passwd[0] != 0 ||
+ 	(hadchap == 1 || (hadchap == -1 && have_chap_secret(user,
+ 	    (explicit_remote? remote_name: NULL), 0, NULL))) ||
+-	have_srp_secret(user, (explicit_remote? remote_name: NULL), 0, NULL));
++	have_srp_secret(user, (explicit_remote? remote_name: NULL), 0, NULL)
++#ifdef USE_EAPTLS
++		|| have_eaptls_secret_client(user, (explicit_remote? remote_name: NULL))
++#endif
++	);
+ 
+     hadchap = -1;
+     if (go->neg_upap && !uselogin && !have_pap_secret(NULL))
+@@ -1346,8 +1416,14 @@
+ 	    !have_chap_secret((explicit_remote? remote_name: NULL), our_name,
+ 		1, NULL))) &&
+ 	!have_srp_secret((explicit_remote? remote_name: NULL), our_name, 1,
+-	    NULL))
++	    NULL)
++#ifdef USE_EAPTLS
++	 && !have_eaptls_secret_server((explicit_remote? remote_name: NULL),
++				   our_name, 1, NULL)
++#endif
++		)
+ 	go->neg_eap = 0;
++
+ }
+ 
+ 
+@@ -1707,6 +1783,7 @@
+ }
+ 
+ 
++
+ /*
+  * get_secret - open the CHAP secret file and return the secret
+  * for authenticating the given client on the given server.
+@@ -2359,3 +2436,335 @@
+ 
+     auth_script_pid = run_program(script, argv, 0, auth_script_done, NULL, 0);
+ }
++
++
++#ifdef USE_EAPTLS
++static int
++have_eaptls_secret_server(client, server, need_ip, lacks_ipp)
++    char *client;
++    char *server;
++    int need_ip;
++    int *lacks_ipp;
++{
++    FILE *f;
++    int ret;
++    char *filename;
++    struct wordlist *addrs;
++    char servcertfile[MAXWORDLEN];
++    char clicertfile[MAXWORDLEN];
++    char cacertfile[MAXWORDLEN];
++    char pkfile[MAXWORDLEN];
++
++    filename = _PATH_EAPTLSSERVFILE;
++    f = fopen(filename, "r");
++    if (f == NULL)
++		return 0;
++
++    if (client != NULL && client[0] == 0)
++		client = NULL;
++    else if (server != NULL && server[0] == 0)
++		server = NULL;
++
++    ret =
++	scan_authfile_eaptls(f, client, server, clicertfile, servcertfile,
++			     cacertfile, pkfile, &addrs, NULL, filename,
++			     0);
++
++    fclose(f);
++
++/*
++    if (ret >= 0 && !eaptls_init_ssl(1, cacertfile, servcertfile,
++				clicertfile, pkfile))
++		ret = -1;
++*/
++
++	if (ret >= 0 && need_ip && !some_ip_ok(addrs)) {
++		if (lacks_ipp != 0)
++			*lacks_ipp = 1;
++		ret = -1;
++    }
++    if (addrs != 0)
++		free_wordlist(addrs);
++
++    return ret >= 0;
++}
++
++
++static int
++have_eaptls_secret_client(client, server)
++    char *client;
++    char *server;
++{
++    FILE *f;
++    int ret;
++    char *filename;
++    struct wordlist *addrs = NULL;
++    char servcertfile[MAXWORDLEN];
++    char clicertfile[MAXWORDLEN];
++    char cacertfile[MAXWORDLEN];
++    char pkfile[MAXWORDLEN];
++
++    if (client != NULL && client[0] == 0)
++		client = NULL;
++    else if (server != NULL && server[0] == 0)
++		server = NULL;
++
++	if (cacert_file && cert_file && privkey_file)
++		return 1;
++
++    filename = _PATH_EAPTLSCLIFILE;
++    f = fopen(filename, "r");
++    if (f == NULL)
++		return 0;
++
++    ret =
++	scan_authfile_eaptls(f, client, server, clicertfile, servcertfile,
++			     cacertfile, pkfile, &addrs, NULL, filename,
++			     0);
++    fclose(f);
++
++/*
++    if (ret >= 0 && !eaptls_init_ssl(0, cacertfile, clicertfile,
++				servcertfile, pkfile))
++		ret = -1;
++*/
++
++    if (addrs != 0)
++		free_wordlist(addrs);
++
++    return ret >= 0;
++}
++
++
++static int
++scan_authfile_eaptls(f, client, server, cli_cert, serv_cert, ca_cert, pk,
++		     addrs, opts, filename, flags)
++    FILE *f;
++    char *client;
++    char *server;
++    char *cli_cert;
++    char *serv_cert;
++    char *ca_cert;
++    char *pk;
++    struct wordlist **addrs;
++    struct wordlist **opts;
++    char *filename;
++    int flags;
++{
++    int newline;
++    int got_flag, best_flag;
++    struct wordlist *ap, *addr_list, *alist, **app;
++    char word[MAXWORDLEN];
++
++    if (addrs != NULL)
++	*addrs = NULL;
++    if (opts != NULL)
++	*opts = NULL;
++    addr_list = NULL;
++    if (!getword(f, word, &newline, filename))
++	return -1;		/* file is empty??? */
++    newline = 1;
++    best_flag = -1;
++    for (;;) {
++	/*
++	 * Skip until we find a word at the start of a line.
++	 */
++	while (!newline && getword(f, word, &newline, filename));
++	if (!newline)
++	    break;		/* got to end of file */
++
++	/*
++	 * Got a client - check if it's a match or a wildcard.
++	 */
++	got_flag = 0;
++	if (client != NULL && strcmp(word, client) != 0 && !ISWILD(word)) {
++	    newline = 0;
++	    continue;
++	}
++	if (!ISWILD(word))
++	    got_flag = NONWILD_CLIENT;
++
++	/*
++	 * Now get a server and check if it matches.
++	 */
++	if (!getword(f, word, &newline, filename))
++	    break;
++	if (newline)
++	    continue;
++	if (!ISWILD(word)) {
++	    if (server != NULL && strcmp(word, server) != 0)
++		continue;
++	    got_flag |= NONWILD_SERVER;
++	}
++
++	/*
++	 * Got some sort of a match - see if it's better than what
++	 * we have already.
++	 */
++	if (got_flag <= best_flag)
++	    continue;
++
++	/*
++	 * Get the cli_cert
++	 */
++	if (!getword(f, word, &newline, filename))
++	    break;
++	if (newline)
++	    continue;
++	if (strcmp(word, "-") != 0) {
++	    strlcpy(cli_cert, word, MAXWORDLEN);
++	} else
++	    cli_cert[0] = 0;
++
++	/*
++	 * Get serv_cert
++	 */
++	if (!getword(f, word, &newline, filename))
++	    break;
++	if (newline)
++	    continue;
++	if (strcmp(word, "-") != 0) {
++	    strlcpy(serv_cert, word, MAXWORDLEN);
++	} else
++	    serv_cert[0] = 0;
++
++	/*
++	 * Get ca_cert
++	 */
++	if (!getword(f, word, &newline, filename))
++	    break;
++	if (newline)
++	    continue;
++	strlcpy(ca_cert, word, MAXWORDLEN);
++
++	/*
++	 * Get pk
++	 */
++	if (!getword(f, word, &newline, filename))
++	    break;
++	if (newline)
++	    continue;
++	strlcpy(pk, word, MAXWORDLEN);
++
++
++	/*
++	 * Now read address authorization info and make a wordlist.
++	 */
++	app = &alist;
++	for (;;) {
++	    if (!getword(f, word, &newline, filename) || newline)
++		break;
++	    ap = (struct wordlist *)
++		malloc(sizeof(struct wordlist) + strlen(word) + 1);
++	    if (ap == NULL)
++		novm("authorized addresses");
++	    ap->word = (char *) (ap + 1);
++	    strcpy(ap->word, word);
++	    *app = ap;
++	    app = &ap->next;
++	}
++	*app = NULL;
++	/*
++	 * This is the best so far; remember it.
++	 */
++	best_flag = got_flag;
++	if (addr_list)
++	    free_wordlist(addr_list);
++	addr_list = alist;
++
++	if (!newline)
++	    break;
++    }
++
++    /* scan for a -- word indicating the start of options */
++    for (app = &addr_list; (ap = *app) != NULL; app = &ap->next)
++	if (strcmp(ap->word, "--") == 0)
++	    break;
++    /* ap = start of options */
++    if (ap != NULL) {
++	ap = ap->next;		/* first option */
++	free(*app);		/* free the "--" word */
++	*app = NULL;		/* terminate addr list */
++    }
++    if (opts != NULL)
++	*opts = ap;
++    else if (ap != NULL)
++	free_wordlist(ap);
++    if (addrs != NULL)
++	*addrs = addr_list;
++    else if (addr_list != NULL)
++	free_wordlist(addr_list);
++
++    return best_flag;
++}
++
++
++int
++get_eaptls_secret(unit, client, server, clicertfile, servcertfile,
++		  cacertfile, pkfile, am_server)
++    int unit;
++    char *client;
++    char *server;
++    char *clicertfile;
++    char *servcertfile;
++    char *cacertfile;
++    char *pkfile;
++    int am_server;
++{
++    FILE *fp;
++    int ret;
++    char *filename         = NULL;
++    struct wordlist *addrs = NULL;
++    struct wordlist *opts  = NULL;
++
++	/* in client mode the ca+cert+privkey can also be specified as options */
++	if (!am_server && cacert_file && cert_file && privkey_file )
++	{
++		strlcpy( clicertfile, cert_file, MAXWORDLEN );
++		strlcpy( cacertfile, cacert_file, MAXWORDLEN );
++		strlcpy( pkfile, privkey_file, MAXWORDLEN );
++		servcertfile[0] = '\0';
++	}
++	else
++	{
++		filename = (am_server ? _PATH_EAPTLSSERVFILE : _PATH_EAPTLSCLIFILE);
++		addrs = NULL;
++
++		fp = fopen(filename, "r");
++		if (fp == NULL)
++		{
++			error("Can't open eap-tls secret file %s: %m", filename);
++			return 0;
++   	 	}
++
++		check_access(fp, filename);
++
++		ret = scan_authfile_eaptls(fp, client, server, clicertfile, servcertfile,
++				cacertfile, pkfile, &addrs, &opts, filename, 0);
++
++		fclose(fp);
++
++		if (ret < 0) return 0;
++	}
++
++    if (eaptls_passwd_hook)
++    {
++		dbglog( "Calling eaptls password hook" );
++		if ( (*eaptls_passwd_hook)(pkfile, passwd) < 0)
++		{
++	   		 error("Unable to obtain EAP-TLS password for %s (%s) from plugin", 
++				client, pkfile);
++		    return 0;
++		}
++	}
++    if (am_server)
++		set_allowed_addrs(unit, addrs, opts);
++    else if (opts != NULL)
++		free_wordlist(opts);
++    if (addrs != NULL)
++		free_wordlist(addrs);
++
++    return 1;
++}
++#endif
++
+diff -Naur ppp-2.4.7/pppd/ccp.c ppp-2.4.7-eaptls-mppe-0.998/pppd/ccp.c
+--- ppp-2.4.7/pppd/ccp.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/ccp.c	2015-03-10 16:51:32.701097215 +0100
+@@ -540,6 +540,9 @@
+     if (go->mppe) {
+ 	ccp_options *ao = &ccp_allowoptions[f->unit];
+ 	int auth_mschap_bits = auth_done[f->unit];
++#ifdef USE_EAPTLS
++	int auth_eap_bits = auth_done[f->unit];
++#endif
+ 	int numbits;
+ 
+ 	/*
+@@ -567,8 +570,23 @@
+ 	    lcp_close(f->unit, "MPPE required but not available");
+ 	    return;
+ 	}
++
++#ifdef USE_EAPTLS
++    /*
++     * MPPE is also possible in combination with EAP-TLS.
++     * It is not possible to detect if we're doing EAP or EAP-TLS
++     * at this stage, hence we accept all forms of EAP. If TLS is
++     * not used then the MPPE keys will not be derived anyway.
++     */
++	/* Leave only the eap auth bits set */
++	auth_eap_bits &= (EAP_WITHPEER | EAP_PEER );
++
++	if ((numbits == 0) && (auth_eap_bits == 0)) {
++	    error("MPPE required, but MS-CHAP[v2] nor EAP-TLS auth are performed.");
++#else
+ 	if (!numbits) {
+-	    error("MPPE required, but MS-CHAP[v2] auth not performed.");
++		error("MPPE required, but MS-CHAP[v2] auth not performed.");
++#endif
+ 	    lcp_close(f->unit, "MPPE required but not available");
+ 	    return;
+ 	}
+diff -Naur ppp-2.4.7/pppd/chap-md5.c ppp-2.4.7-eaptls-mppe-0.998/pppd/chap-md5.c
+--- ppp-2.4.7/pppd/chap-md5.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/chap-md5.c	2015-03-10 16:51:32.702097231 +0100
+@@ -36,7 +36,11 @@
+ #include "chap-new.h"
+ #include "chap-md5.h"
+ #include "magic.h"
++#ifdef USE_EAPTLS
++#include "eap-tls.h"
++#else
+ #include "md5.h"
++#endif /* USE_EAPTLS */
+ 
+ #define MD5_HASH_SIZE		16
+ #define MD5_MIN_CHALLENGE	16
+diff -Naur ppp-2.4.7/pppd/eap-tls.c ppp-2.4.7-eaptls-mppe-0.998/pppd/eap-tls.c
+--- ppp-2.4.7/pppd/eap-tls.c	1970-01-01 01:00:00.000000000 +0100
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/eap-tls.c	2015-03-10 16:51:32.704097257 +0100
+@@ -0,0 +1,1212 @@
++/*
++ * eap-tls.c - EAP-TLS implementation for PPP
++ *
++ * Copyright (c) Beniamino Galvani 2005 All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ *
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in
++ *    the documentation and/or other materials provided with the
++ *    distribution.
++ *
++ * 3. The name(s) of the authors of this software must not be used to
++ *    endorse or promote products derived from this software without
++ *    prior written permission.
++ *
++ * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
++ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
++ * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
++ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
++ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
++ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ *
++ */
++
++#include <string.h>
++#include <unistd.h>
++#include <sys/types.h>
++#include <sys/stat.h>
++#include <fcntl.h>
++
++#include <openssl/conf.h>
++#include <openssl/engine.h>
++#include <openssl/hmac.h>
++#include <openssl/err.h>
++#include <openssl/x509v3.h>
++
++#include "pppd.h"
++#include "eap.h"
++#include "eap-tls.h"
++#include "fsm.h"
++#include "lcp.h"
++#include "pathnames.h"
++
++/* The openssl configuration file and engines can be loaded only once */
++static CONF   *ssl_config  = NULL;
++static ENGINE *cert_engine = NULL;
++static ENGINE *pkey_engine = NULL;
++
++#ifdef MPPE
++
++/*
++ * TLS PRF from RFC 2246
++ */
++static void P_hash(const EVP_MD *evp_md,
++		   const unsigned char *secret, unsigned int secret_len,
++		   const unsigned char *seed,   unsigned int seed_len,
++		   unsigned char *out, unsigned int out_len)
++{
++	HMAC_CTX ctx_a, ctx_out;
++	unsigned char a[HMAC_MAX_MD_CBLOCK];
++	unsigned int size;
++
++	HMAC_CTX_init(&ctx_a);
++	HMAC_CTX_init(&ctx_out);
++	HMAC_Init_ex(&ctx_a, secret, secret_len, evp_md, NULL);
++	HMAC_Init_ex(&ctx_out, secret, secret_len, evp_md, NULL);
++
++	size = HMAC_size(&ctx_out);
++
++	/* Calculate A(1) */
++	HMAC_Update(&ctx_a, seed, seed_len);
++	HMAC_Final(&ctx_a, a, NULL);
++
++	while (1) {
++		/* Calculate next part of output */
++		HMAC_Update(&ctx_out, a, size);
++		HMAC_Update(&ctx_out, seed, seed_len);
++
++		/* Check if last part */
++		if (out_len < size) {
++			HMAC_Final(&ctx_out, a, NULL);
++			memcpy(out, a, out_len);
++			break;
++		}
++
++		/* Place digest in output buffer */
++		HMAC_Final(&ctx_out, out, NULL);
++		HMAC_Init_ex(&ctx_out, NULL, 0, NULL, NULL);
++		out += size;
++		out_len -= size;
++
++		/* Calculate next A(i) */
++		HMAC_Init_ex(&ctx_a, NULL, 0, NULL, NULL);
++		HMAC_Update(&ctx_a, a, size);
++		HMAC_Final(&ctx_a, a, NULL);
++	}
++
++	HMAC_CTX_cleanup(&ctx_a);
++	HMAC_CTX_cleanup(&ctx_out);
++	memset(a, 0, sizeof(a));
++}
++
++static void PRF(const unsigned char *secret, unsigned int secret_len,
++		const unsigned char *seed,   unsigned int seed_len,
++		unsigned char *out, unsigned char *buf, unsigned int out_len)
++{
++        unsigned int i;
++        unsigned int len = (secret_len + 1) / 2;
++	const unsigned char *s1 = secret;
++	const unsigned char *s2 = secret + (secret_len - len);
++
++	P_hash(EVP_md5(),  s1, len, seed, seed_len, out, out_len);
++	P_hash(EVP_sha1(), s2, len, seed, seed_len, buf, out_len);
++
++	for (i=0; i < out_len; i++) {
++	        out[i] ^= buf[i];
++	}
++}
++
++#define EAPTLS_MPPE_KEY_LEN     32
++
++/*
++ *  Generate keys according to RFC 2716 and add to reply
++ */
++void eaptls_gen_mppe_keys(struct eaptls_session *ets, const char *prf_label,
++                          int client)
++{
++    unsigned char out[4*EAPTLS_MPPE_KEY_LEN], buf[4*EAPTLS_MPPE_KEY_LEN];
++    unsigned char seed[64 + 2*SSL3_RANDOM_SIZE];
++    unsigned char *p = seed;
++	SSL			  *s = ets->ssl;
++    size_t prf_size;
++
++    prf_size = strlen(prf_label);
++
++    memcpy(p, prf_label, prf_size);
++    p += prf_size;
++
++    memcpy(p, s->s3->client_random, SSL3_RANDOM_SIZE);
++    p += SSL3_RANDOM_SIZE;
++    prf_size += SSL3_RANDOM_SIZE;
++
++    memcpy(p, s->s3->server_random, SSL3_RANDOM_SIZE);
++    prf_size += SSL3_RANDOM_SIZE;
++
++    PRF(s->session->master_key, s->session->master_key_length,
++        seed, prf_size, out, buf, sizeof(out));
++
++    /* 
++     * We now have the master send and receive keys.
++     * From these, generate the session send and receive keys.
++     * (see RFC3079 / draft-ietf-pppext-mppe-keys-03.txt for details)
++     */
++    if (client)
++    {
++	    p = out;
++		BCOPY( p, mppe_send_key, sizeof(mppe_send_key) );
++		p += EAPTLS_MPPE_KEY_LEN;
++    	BCOPY( p, mppe_recv_key, sizeof(mppe_recv_key) );
++    }
++    else
++    {
++	    p = out;
++    	BCOPY( p, mppe_recv_key, sizeof(mppe_recv_key) );
++		p += EAPTLS_MPPE_KEY_LEN;
++		BCOPY( p, mppe_send_key, sizeof(mppe_send_key) );
++    }
++
++    mppe_keys_set = 1;
++}
++
++#endif
++
++void log_ssl_errors( void )
++{
++	unsigned long ssl_err = ERR_get_error();
++
++    if (ssl_err != 0)
++		dbglog("EAP-TLS SSL error stack:");
++	while (ssl_err != 0) {
++		dbglog( ERR_error_string( ssl_err, NULL ) );
++		ssl_err = ERR_get_error();
++	}
++}
++
++
++int password_callback (char *buf, int size, int rwflag, void *u)
++{
++	if (buf)
++	{
++		strncpy (buf, passwd, size);
++		return strlen (buf);
++	}
++	return 0;
++}
++
++
++CONF *eaptls_ssl_load_config( void )
++{
++    CONF        *config;
++    int          ret_code;
++    long         error_line = 33;
++
++    config = NCONF_new( NULL );
++	dbglog( "Loading OpenSSL config file" );
++    ret_code = NCONF_load( config, _PATH_OPENSSLCONFFILE, &error_line );
++    if (ret_code == 0)
++    {
++        warn( "EAP-TLS: Error in OpenSSL config file %s at line %d", _PATH_OPENSSLCONFFILE, error_line );
++        NCONF_free( config );
++        config = NULL;
++        ERR_clear_error();
++    }
++
++	dbglog( "Loading OpenSSL built-ins" );
++    ENGINE_load_builtin_engines();
++    OPENSSL_load_builtin_modules();
++   
++	dbglog( "Loading OpenSSL configured modules" );
++    if (CONF_modules_load( config, NULL, 0 ) <= 0 )
++    {
++        warn( "EAP-TLS: Error loading OpenSSL modules" );
++	    log_ssl_errors();
++        config = NULL;
++    }
++
++    return config;
++}
++
++ENGINE *eaptls_ssl_load_engine( char *engine_name )
++{
++	ENGINE      *e = NULL;
++
++	dbglog( "Enabling OpenSSL auto engines" );
++	ENGINE_register_all_complete();
++
++	dbglog( "Loading OpenSSL '%s' engine support", engine_name );
++	e = ENGINE_by_id( engine_name );
++    if (!e) 
++	{
++		dbglog( "EAP-TLS: Cannot load '%s' engine support, trying 'dynamic'", engine_name );
++		e = ENGINE_by_id( "dynamic" );
++		if (e)
++		{
++			if (!ENGINE_ctrl_cmd_string(e, "SO_PATH", engine_name, 0)
++   	         || !ENGINE_ctrl_cmd_string(e, "LOAD", NULL, 0))
++			{
++				warn( "EAP-TLS: Error loading dynamic engine '%s'", engine_name );
++		        log_ssl_errors();
++				ENGINE_free(e);
++				e = NULL;
++			}
++		}
++		else
++		{
++			warn( "EAP-TLS: Cannot load dynamic engine support" );
++		}
++	}
++
++    if (e)
++	{
++		dbglog( "Initialising engine" );
++		if(!ENGINE_set_default(e, ENGINE_METHOD_ALL))
++		{
++			warn( "EAP-TLS: Cannot use that engine" );
++			log_ssl_errors();
++			ENGINE_free(e);
++			e = NULL;
++		}
++	}
++
++    return e;
++}
++
++/*
++ * Initialize the SSL stacks and tests if certificates, key and crl
++ * for client or server use can be loaded.
++ */
++SSL_CTX *eaptls_init_ssl(int init_server, char *cacertfile,
++			char *certfile, char *peer_certfile, char *privkeyfile)
++{
++	char		*cert_engine_name = NULL;
++	char		*cert_identifier = NULL;
++	char		*pkey_engine_name = NULL;
++	char		*pkey_identifier = NULL;
++	SSL_CTX		*ctx;
++	X509_STORE	*certstore;
++	X509_LOOKUP	*lookup;
++	X509		*tmp;
++
++	/*
++	 * Without these can't continue 
++	 */
++	if (!cacertfile[0])
++    {
++		error("EAP-TLS: CA certificate missing");
++		return NULL;
++    }
++
++	if (!certfile[0])
++    {
++		error("EAP-TLS: User certificate missing");
++		return NULL;
++    }
++
++	if (!privkeyfile[0])
++    {
++		error("EAP-TLS: User private key missing");
++		return NULL;
++    }
++
++	SSL_library_init();
++	SSL_load_error_strings();
++
++	ctx = SSL_CTX_new(TLSv1_method());
++
++	if (!ctx) {
++		error("EAP-TLS: Cannot initialize SSL CTX context");
++		goto fail;
++	}
++
++	/* if the certificate filename is of the form engine:id. e.g.
++		pkcs11:12345
++	   then we try to load and use this engine.
++	   If the certificate filename starts with a / or . then we
++	   ALWAYS assume it is a file and not an engine/pkcs11 identifier
++	 */
++	if ( index( certfile, '/' ) == NULL && index( certfile, '.') == NULL )
++	{
++		cert_identifier = index( certfile, ':' );
++
++		if (cert_identifier)
++		{
++			cert_engine_name = certfile;
++			*cert_identifier = '\0';
++			cert_identifier++;
++
++			dbglog( "Found certificate engine '%s'", cert_engine_name );
++			dbglog( "Found certificate identifier '%s'", cert_identifier );
++		}
++	}
++
++	/* if the privatekey filename is of the form engine:id. e.g.
++		pkcs11:12345
++	   then we try to load and use this engine.
++	   If the privatekey filename starts with a / or . then we
++	   ALWAYS assume it is a file and not an engine/pkcs11 identifier
++	 */
++	if ( index( privkeyfile, '/' ) == NULL && index( privkeyfile, '.') == NULL )
++	{
++		pkey_identifier = index( privkeyfile, ':' );
++
++		if (pkey_identifier)
++		{
++			pkey_engine_name = privkeyfile;
++			*pkey_identifier = '\0';
++			pkey_identifier++;
++
++			dbglog( "Found privatekey engine '%s'", pkey_engine_name );
++			dbglog( "Found privatekey identifier '%s'", pkey_identifier );
++		}
++	}
++
++	if (cert_identifier && pkey_identifier)
++	{
++		if (strlen( cert_identifier ) == 0)
++		{
++			if (strlen( pkey_identifier ) == 0)
++				error( "EAP-TLS: both the certificate and privatekey identifiers are missing!" );
++			else
++			{
++				dbglog( "Substituting privatekey identifier for certificate identifier" );
++				cert_identifier = pkey_identifier;
++			}
++		}
++		else
++		{
++			if (strlen( pkey_identifier ) == 0)
++			{
++				dbglog( "Substituting certificate identifier for privatekey identifier" );
++				pkey_identifier = cert_identifier;
++			}
++		}
++
++	}
++
++	/* load the openssl config file only once */
++	if (!ssl_config)
++	{
++		if (cert_engine_name || pkey_engine_name)
++			ssl_config = eaptls_ssl_load_config();
++
++		if (ssl_config && cert_engine_name)
++			cert_engine = eaptls_ssl_load_engine( cert_engine_name );
++
++		if (ssl_config && pkey_engine_name)
++		{
++			/* don't load the same engine twice */
++			if ( cert_engine && strcmp( cert_engine_name, pkey_engine_name) == 0 )
++				pkey_engine = cert_engine;
++			else
++				pkey_engine = eaptls_ssl_load_engine( pkey_engine_name );
++		}
++	}
++
++    SSL_CTX_set_default_passwd_cb (ctx, password_callback);
++
++	if (!SSL_CTX_load_verify_locations(ctx, cacertfile, NULL))
++	{
++		error("EAP-TLS: Cannot load or verify CA file %s", cacertfile);
++		goto fail;
++	}
++
++    if (init_server)
++		SSL_CTX_set_client_CA_list(ctx, SSL_load_client_CA_file(cacertfile));
++
++	if (cert_engine)
++	{
++		struct
++		{
++			const char *s_slot_cert_id;
++			X509 *cert;
++		} cert_info;
++
++		cert_info.s_slot_cert_id = cert_identifier;
++		cert_info.cert = NULL;
++		
++		if (!ENGINE_ctrl_cmd( cert_engine, "LOAD_CERT_CTRL", 0, &cert_info, NULL, 0 ) )
++		{
++			error( "EAP-TLS: Error loading certificate with id '%s' from engine", cert_identifier );
++			goto fail;
++		}
++
++		if (cert_info.cert)
++		{
++		    dbglog( "Got the certificate, adding it to SSL context" );
++			dbglog( "subject = %s", X509_NAME_oneline( X509_get_subject_name( cert_info.cert ), NULL, 0 ) );
++			if (SSL_CTX_use_certificate(ctx, cert_info.cert) <= 0)
++			{
++				error("EAP-TLS: Cannot use PKCS11 certificate %s", cert_identifier);
++				goto fail;
++			}
++		}
++		else
++		{
++			warn("EAP-TLS: Cannot load PKCS11 key %s", cert_identifier);
++			log_ssl_errors();
++		}
++	}
++	else
++	{
++		if (!SSL_CTX_use_certificate_file(ctx, certfile, SSL_FILETYPE_PEM))
++		{
++			error( "EAP-TLS: Cannot use public certificate %s", certfile );
++			goto fail;
++		}
++	}
++
++	if (pkey_engine)
++	{
++		EVP_PKEY   *pkey = NULL;
++		PW_CB_DATA  cb_data;
++
++		cb_data.password = passwd;
++		cb_data.prompt_info = pkey_identifier;
++
++		dbglog( "Loading private key '%s' from engine", pkey_identifier );
++		pkey = ENGINE_load_private_key(pkey_engine, pkey_identifier, NULL, &cb_data);
++		if (pkey)
++		{
++		    dbglog( "Got the private key, adding it to SSL context" );
++			if (SSL_CTX_use_PrivateKey(ctx, pkey) <= 0)
++			{
++				error("EAP-TLS: Cannot use PKCS11 key %s", pkey_identifier);
++				goto fail;
++			}
++		}
++		else
++		{
++			warn("EAP-TLS: Cannot load PKCS11 key %s", pkey_identifier);
++			log_ssl_errors();
++		}
++	}
++	else
++	{
++		if (!SSL_CTX_use_PrivateKey_file(ctx, privkeyfile, SSL_FILETYPE_PEM))
++		{ 
++			error("EAP-TLS: Cannot use private key %s", privkeyfile);
++			goto fail;
++		}
++	}
++
++	if (SSL_CTX_check_private_key(ctx) != 1) {
++		error("EAP-TLS: Private key %s fails security check", privkeyfile);
++		goto fail;
++	}
++
++    /* Explicitly set the NO_TICKETS flag to support Win7/Win8 clients */
++	SSL_CTX_set_options(ctx, SSL_OP_NO_SSLv2 | SSL_OP_NO_SSLv3
++#ifdef SSL_OP_NO_TICKET
++    | SSL_OP_NO_TICKET
++#endif
++);
++	SSL_CTX_set_verify_depth(ctx, 5);
++	SSL_CTX_set_verify(ctx,
++			   SSL_VERIFY_PEER |
++			   SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
++			   &ssl_verify_callback);
++
++	if (crl_dir) {
++		if (!(certstore = SSL_CTX_get_cert_store(ctx))) {
++			error("EAP-TLS: Failed to get certificate store");
++			goto fail;
++		}
++
++		if (!(lookup =
++		     X509_STORE_add_lookup(certstore, X509_LOOKUP_hash_dir()))) {
++			error("EAP-TLS: Store lookup for CRL failed");
++
++			goto fail;
++		}
++
++		X509_LOOKUP_add_dir(lookup, crl_dir, X509_FILETYPE_PEM);
++		X509_STORE_set_flags(certstore, X509_V_FLAG_CRL_CHECK);
++	}
++
++    if (crl_file) {
++        FILE     *fp  = NULL;
++        X509_CRL *crl = NULL;
++
++        fp = fopen(crl_file, "r");
++        if (!fp) {
++            error("EAP-TLS: Cannot open CRL file '%s'", crl_file);
++            goto fail;
++        }
++
++        crl = PEM_read_X509_CRL(fp, NULL, NULL, NULL);
++        if (!crl) {
++            error("EAP-TLS: Cannot read CRL file '%s'", crl_file);
++            goto fail;
++        }
++
++		if (!(certstore = SSL_CTX_get_cert_store(ctx))) {
++			error("EAP-TLS: Failed to get certificate store");
++			goto fail;
++		}
++        if (!X509_STORE_add_crl(certstore, crl)) {
++            error("EAP-TLS: Cannot add CRL to certificate store");
++            goto fail;
++        }
++		X509_STORE_set_flags(certstore, X509_V_FLAG_CRL_CHECK);
++
++    }
++
++	/*
++	 * If a peer certificate file was specified, it must be valid, else fail 
++	 */
++	if (peer_certfile[0]) {
++		if (!(tmp = get_X509_from_file(peer_certfile))) {
++			error("EAP-TLS: Error loading client certificate from file %s",
++			     peer_certfile);
++			goto fail;
++		}
++		X509_free(tmp);
++	}
++
++	return ctx;
++
++fail:
++	log_ssl_errors();
++	SSL_CTX_free(ctx);
++	return NULL;
++}
++
++/*
++ * Determine the maximum packet size by looking at the LCP handshake
++ */
++
++int eaptls_get_mtu(int unit)
++{
++	int mtu, mru;
++
++	lcp_options *wo = &lcp_wantoptions[unit];
++	lcp_options *go = &lcp_gotoptions[unit];
++	lcp_options *ho = &lcp_hisoptions[unit];
++	lcp_options *ao = &lcp_allowoptions[unit];
++
++	mtu = ho->neg_mru? ho->mru: PPP_MRU;
++	mru = go->neg_mru? MAX(wo->mru, go->mru): PPP_MRU;
++    mtu = MIN(MIN(mtu, mru), ao->mru)- PPP_HDRLEN - 10;
++
++	dbglog("MTU = %d", mtu);
++ 	return mtu;
++}
++
++
++/*
++ * Init the ssl handshake (server mode)
++ */
++int eaptls_init_ssl_server(eap_state * esp)
++{
++	struct eaptls_session *ets;
++	char servcertfile[MAXWORDLEN];
++	char clicertfile[MAXWORDLEN];
++	char cacertfile[MAXWORDLEN];
++	char pkfile[MAXWORDLEN];
++	/*
++	 * Allocate new eaptls session 
++	 */
++	esp->es_server.ea_session = malloc(sizeof(struct eaptls_session));
++	if (!esp->es_server.ea_session)
++		fatal("Allocation error");
++	ets = esp->es_server.ea_session;
++
++	if (!esp->es_server.ea_peer) {
++		error("EAP-TLS: Error: client name not set (BUG)");
++		return 0;
++	}
++
++	strncpy(ets->peer, esp->es_server.ea_peer, MAXWORDLEN);
++
++	dbglog( "getting eaptls secret" );
++	if (!get_eaptls_secret(esp->es_unit, esp->es_server.ea_peer,
++			       esp->es_server.ea_name, clicertfile,
++			       servcertfile, cacertfile, pkfile, 1)) {
++		error( "EAP-TLS: Cannot get secret/password for client \"%s\", server \"%s\"",
++				esp->es_server.ea_peer, esp->es_server.ea_name );
++		return 0;
++	}
++
++	ets->mtu = eaptls_get_mtu(esp->es_unit);
++
++	ets->ctx = eaptls_init_ssl(1, cacertfile, servcertfile, clicertfile, pkfile);
++	if (!ets->ctx)
++		goto fail;
++
++	if (!(ets->ssl = SSL_new(ets->ctx)))
++		goto fail;
++
++	/*
++	 * Set auto-retry to avoid timeouts on BIO_read
++	 */
++	SSL_set_mode(ets->ssl, SSL_MODE_AUTO_RETRY);
++
++	/*
++	 * Initialize the BIOs we use to read/write to ssl engine 
++	 */
++	ets->into_ssl = BIO_new(BIO_s_mem());
++	ets->from_ssl = BIO_new(BIO_s_mem());
++	SSL_set_bio(ets->ssl, ets->into_ssl, ets->from_ssl);
++
++	SSL_set_msg_callback(ets->ssl, ssl_msg_callback);
++	SSL_set_msg_callback_arg(ets->ssl, ets);
++
++	/*
++	 * Attach the session struct to the connection, so we can later
++	 * retrieve it when doing certificate verification
++	 */
++	SSL_set_ex_data(ets->ssl, 0, ets);
++
++	SSL_set_accept_state(ets->ssl);
++
++	ets->data = NULL;
++	ets->datalen = 0;
++	ets->alert_sent = 0;
++	ets->alert_recv = 0;
++
++	/*
++	 * If we specified the client certificate file, store it in ets->peercertfile,
++	 * so we can check it later in ssl_verify_callback()
++	 */
++	if (clicertfile[0])
++		strncpy(&ets->peercertfile[0], clicertfile, MAXWORDLEN);
++	else
++		ets->peercertfile[0] = 0;
++
++	return 1;
++
++fail:
++	SSL_CTX_free(ets->ctx);
++	return 0;
++}
++
++/*
++ * Init the ssl handshake (client mode)
++ */
++int eaptls_init_ssl_client(eap_state * esp)
++{
++	struct eaptls_session *ets;
++	char servcertfile[MAXWORDLEN];
++	char clicertfile[MAXWORDLEN];
++	char cacertfile[MAXWORDLEN];
++	char pkfile[MAXWORDLEN];
++
++	/*
++	 * Allocate new eaptls session 
++	 */
++	esp->es_client.ea_session = malloc(sizeof(struct eaptls_session));
++	if (!esp->es_client.ea_session)
++		fatal("Allocation error");
++	ets = esp->es_client.ea_session;
++
++	/*
++	 * If available, copy server name in ets; it will be used in cert
++	 * verify 
++	 */
++	if (esp->es_client.ea_peer)
++		strncpy(ets->peer, esp->es_client.ea_peer, MAXWORDLEN);
++	else
++		ets->peer[0] = 0;
++	
++	ets->mtu = eaptls_get_mtu(esp->es_unit);
++
++	dbglog( "calling get_eaptls_secret" );
++	if (!get_eaptls_secret(esp->es_unit, esp->es_client.ea_name,
++			       ets->peer, clicertfile,
++			       servcertfile, cacertfile, pkfile, 0)) {
++		error( "EAP-TLS: Cannot get secret/password for client \"%s\", server \"%s\"",
++				esp->es_client.ea_name, ets->peer );
++		return 0;
++	}
++
++	dbglog( "calling eaptls_init_ssl" );
++	ets->ctx = eaptls_init_ssl(0, cacertfile, clicertfile, servcertfile, pkfile);
++	if (!ets->ctx)
++		goto fail;
++
++	ets->ssl = SSL_new(ets->ctx);
++
++	if (!ets->ssl)
++		goto fail;
++
++	/*
++	 * Initialize the BIOs we use to read/write to ssl engine 
++	 */
++	dbglog( "Initializing SSL BIOs" );
++	ets->into_ssl = BIO_new(BIO_s_mem());
++	ets->from_ssl = BIO_new(BIO_s_mem());
++	SSL_set_bio(ets->ssl, ets->into_ssl, ets->from_ssl);
++
++	SSL_set_msg_callback(ets->ssl, ssl_msg_callback);
++	SSL_set_msg_callback_arg(ets->ssl, ets);
++
++	/*
++	 * Attach the session struct to the connection, so we can later
++	 * retrieve it when doing certificate verification
++	 */
++	SSL_set_ex_data(ets->ssl, 0, ets);
++
++	SSL_set_connect_state(ets->ssl);
++
++	ets->data = NULL;
++	ets->datalen = 0;
++	ets->alert_sent = 0;
++	ets->alert_recv = 0;
++
++	/*
++	 * If we specified the server certificate file, store it in
++	 * ets->peercertfile, so we can check it later in
++	 * ssl_verify_callback() 
++	 */
++	if (servcertfile[0])
++		strncpy(ets->peercertfile, servcertfile, MAXWORDLEN);
++	else
++		ets->peercertfile[0] = 0;
++
++	return 1;
++
++fail:
++	dbglog( "eaptls_init_ssl_client: fail" );
++	SSL_CTX_free(ets->ctx);
++	return 0;
++
++}
++
++void eaptls_free_session(struct eaptls_session *ets)
++{
++	if (ets->ssl)
++		SSL_free(ets->ssl);
++
++	if (ets->ctx)
++		SSL_CTX_free(ets->ctx);
++
++	free(ets);
++}
++
++/*
++ * Handle a received packet, reassembling fragmented messages and
++ * passing them to the ssl engine
++ */
++int eaptls_receive(struct eaptls_session *ets, u_char * inp, int len)
++{
++	u_char flags;
++	u_int tlslen;
++	u_char dummy[65536];
++
++	GETCHAR(flags, inp);
++	len--;
++
++    if (flags & EAP_TLS_FLAGS_LI && !ets->data) {
++ 
++		/*
++		 * This is the first packet of a message
++		*/
++ 
++		GETLONG(tlslen, inp);
++		len -= 4;
++
++		if (tlslen > EAP_TLS_MAX_LEN) {
++			error("Error: tls message length > %d, truncated",
++				EAP_TLS_MAX_LEN);
++			tlslen = EAP_TLS_MAX_LEN;
++		}
++
++		/*
++		 * Allocate memory for the whole message
++		*/
++		ets->data = malloc(tlslen);
++		if (!ets->data)
++			fatal("EAP TLS: allocation error\n");
++
++		ets->datalen = 0;
++		ets->tlslen = tlslen;
++
++	}
++	else if (flags & EAP_TLS_FLAGS_LI && ets->data) {
++		/*
++		 * Non first with LI (strange...)
++		*/
++ 
++		GETLONG(tlslen, inp);
++		len -= 4;
++ 
++	}
++	else if (!ets->data) {
++		/*
++		 * A non fragmented message without LI flag
++		*/
++ 
++		ets->data = malloc(len);
++		if (!ets->data)
++			fatal("EAP TLS: allocation error\n");
++ 
++		ets->datalen = 0;
++		ets->tlslen = len;
++	}
++
++	if (flags & EAP_TLS_FLAGS_MF)
++		ets->frag = 1;
++	else
++		ets->frag = 0;
++
++	if (len + ets->datalen > ets->tlslen) {
++		warn("EAP TLS: received data > TLS message length");
++		return 1;
++	}
++
++	BCOPY(inp, ets->data + ets->datalen, len);
++	ets->datalen += len;
++
++	if (!ets->frag) {
++
++		/*
++		 * If we have the whole message, pass it to ssl 
++		 */
++
++		if (ets->datalen != ets->tlslen) {
++			warn("EAP TLS: received data != TLS message length");
++			return 1;
++		}
++
++		if (BIO_write(ets->into_ssl, ets->data, ets->datalen) == -1)
++			log_ssl_errors();
++
++		SSL_read(ets->ssl, dummy, 65536);
++
++		free(ets->data);
++		ets->data = NULL;
++		ets->datalen = 0;
++	}
++
++	return 0;
++}
++
++/*
++ * Return an eap-tls packet in outp.
++ * A TLS message read from the ssl engine is buffered in ets->data.
++ * At each call we control if there is buffered data and send a 
++ * packet of mtu bytes.
++ */
++int eaptls_send(struct eaptls_session *ets, u_char ** outp)
++{
++	bool first = 0;
++	int size;
++	u_char fromtls[65536];
++	int res;
++	u_char *start;
++
++	start = *outp;
++
++	if (!ets->data) {
++
++		if(!ets->alert_sent)
++			SSL_read(ets->ssl, fromtls, 65536);
++
++		/*
++		 * Read from ssl 
++		 */
++		if ((res = BIO_read(ets->from_ssl, fromtls, 65536)) == -1)
++			fatal("No data from BIO_read");
++
++		ets->datalen = res;
++
++		ets->data = malloc(ets->datalen);
++		BCOPY(fromtls, ets->data, ets->datalen);
++
++		ets->offset = 0;
++		first = 1;
++
++	}
++
++	size = ets->datalen - ets->offset;
++    
++	if (size > ets->mtu) {
++		size = ets->mtu;
++		ets->frag = 1;
++	} else
++		ets->frag = 0;
++
++	PUTCHAR(EAPT_TLS, *outp);
++
++	/*
++	 * Set right flags and length if necessary 
++	 */
++	if (ets->frag && first) {
++		PUTCHAR(EAP_TLS_FLAGS_LI | EAP_TLS_FLAGS_MF, *outp);
++		PUTLONG(ets->datalen, *outp);
++	} else if (ets->frag) {
++		PUTCHAR(EAP_TLS_FLAGS_MF, *outp);
++	} else
++		PUTCHAR(0, *outp);
++
++	/*
++	 * Copy the data in outp 
++	 */
++	BCOPY(ets->data + ets->offset, *outp, size);
++	INCPTR(size, *outp);
++
++	/*
++	 * Copy the packet in retransmission buffer 
++	 */
++	BCOPY(start, &ets->rtx[0], *outp - start);
++	ets->rtx_len = *outp - start;
++
++	ets->offset += size;
++
++	if (ets->offset >= ets->datalen) {
++
++		/*
++		 * The whole message has been sent 
++		 */
++
++		free(ets->data);
++		ets->data = NULL;
++		ets->datalen = 0;
++		ets->offset = 0;
++	}
++
++	return 0;
++}
++
++/*
++ * Get the sent packet from the retransmission buffer
++ */
++void eaptls_retransmit(struct eaptls_session *ets, u_char ** outp)
++{
++	BCOPY(ets->rtx, *outp, ets->rtx_len);
++	INCPTR(ets->rtx_len, *outp);
++}
++
++/*
++ * Verify a certificate.
++ * Most of the work (signatures and issuer attributes checking)
++ * is done by ssl; we check the CN in the peer certificate 
++ * against the peer name.
++ */
++int ssl_verify_callback(int preverify_ok, X509_STORE_CTX * ctx)
++{
++	char subject[256];
++	char cn_str[256];
++	X509 *peer_cert;
++	int err, depth;
++	int ok = preverify_ok;
++	SSL *ssl;
++	struct eaptls_session *ets;
++
++	peer_cert = X509_STORE_CTX_get_current_cert(ctx);
++	err = X509_STORE_CTX_get_error(ctx);
++	depth = X509_STORE_CTX_get_error_depth(ctx);
++
++	dbglog("certificate verify depth: %d", depth);
++
++    if (auth_required && !ok) {
++		X509_NAME_oneline(X509_get_subject_name(peer_cert),
++				  subject, 256);
++
++		X509_NAME_get_text_by_NID(X509_get_subject_name(peer_cert),
++					  NID_commonName, cn_str, 256);
++
++		dbglog("Certificate verification error:\n depth: %d CN: %s"
++		       "\n err: %d (%s)\n", depth, cn_str, err,
++		       X509_verify_cert_error_string(err));
++
++		return 0;
++	}
++
++	ssl = X509_STORE_CTX_get_ex_data(ctx,
++				       SSL_get_ex_data_X509_STORE_CTX_idx());
++
++	ets = (struct eaptls_session *)SSL_get_ex_data(ssl, 0);
++
++	if (ets == NULL) {
++		error("Error: SSL_get_ex_data returned NULL");
++		return 0;
++	}
++
++	log_ssl_errors();
++
++	if (!depth) {		/* This is the peer certificate */
++
++		X509_NAME_oneline(X509_get_subject_name(peer_cert),
++				  subject, 256);
++
++		X509_NAME_get_text_by_NID(X509_get_subject_name(peer_cert),
++					  NID_commonName, cn_str, 256);
++
++		/*
++		 * If acting as client and the name of the server wasn't specified
++		 * explicitely, we can't verify the server authenticity 
++		 */
++		if (!ets->peer[0]) {
++			warn("Peer name not specified: no check");
++			return 1;
++		}
++
++		/*
++		 * Check the CN 
++		 */
++		if (strcmp(cn_str, ets->peer)) {
++			error
++			    ("Certificate verification error: CN (%s) != peer_name (%s)",
++			     cn_str, ets->peer);
++			return 0;
++		}
++
++		warn("Certificate CN: %s , peer name %s", cn_str, ets->peer);
++
++		/*
++		 * If a peer certificate file was specified, here we check it 
++		 */
++		if (ets->peercertfile[0]) {
++			if (ssl_cmp_certs(&ets->peercertfile[0], peer_cert)
++			    != 0) {
++				error
++				    ("Peer certificate doesn't match stored certificate");
++				return 0;
++			}
++		}
++	}
++
++	return 1;
++}
++
++/*
++ * Compare a certificate with the one stored in a file
++ */
++int ssl_cmp_certs(char *filename, X509 * a)
++{
++	X509 *b;
++	int ret;
++
++	if (!(b = get_X509_from_file(filename)))
++		return 1;
++
++	ret = X509_cmp(a, b);
++	X509_free(b);
++
++	return ret;
++
++}
++
++X509 *get_X509_from_file(char *filename)
++{
++	FILE *fp;
++	X509 *ret;
++
++	if (!(fp = fopen(filename, "r")))
++		return NULL;
++
++	ret = PEM_read_X509(fp, NULL, NULL, NULL);
++
++	fclose(fp);
++
++	return ret;
++}
++
++/*
++ * Every sent & received message this callback function is invoked,
++ * so we know when alert messages have arrived or are sent and
++ * we can print debug information about TLS handshake.
++ */
++void
++ssl_msg_callback(int write_p, int version, int content_type,
++		 const void *buf, size_t len, SSL * ssl, void *arg)
++{
++	char string[256];
++	struct eaptls_session *ets = (struct eaptls_session *)arg;
++	unsigned char code;
++
++	if(write_p)
++		strcpy(string, " -> ");
++	else
++		strcpy(string, " <- ");
++
++	
++	switch(content_type) {
++
++	case SSL3_RT_ALERT:	
++		strcat(string, "Alert: ");	
++		code = ((const unsigned char *)buf)[1];
++
++		if (write_p) {
++			ets->alert_sent = 1;
++			ets->alert_sent_desc = code;
++		} else {
++			ets->alert_recv = 1;
++			ets->alert_recv_desc = code;
++		}
++
++		strcat(string, SSL_alert_desc_string_long(code));
++		break;
++
++	case SSL3_RT_CHANGE_CIPHER_SPEC:
++		strcat(string, "ChangeCipherSpec");
++		break;
++
++	case SSL3_RT_HANDSHAKE:
++
++		strcat(string, "Handshake: ");
++		code = ((const unsigned char *)buf)[0];
++
++		switch(code) {
++			case SSL3_MT_HELLO_REQUEST:
++				strcat(string,"Hello Request");
++				break;
++			case SSL3_MT_CLIENT_HELLO:
++				strcat(string,"Client Hello");
++				break;
++			case SSL3_MT_SERVER_HELLO:
++				strcat(string,"Server Hello");
++				break;
++#ifdef SSL3_MT_NEWSESSION_TICKET
++			case SSL3_MT_NEWSESSION_TICKET:
++				strcat(string,"New Session Ticket");
++				break;
++#endif
++			case SSL3_MT_CERTIFICATE:
++				strcat(string,"Certificate");
++				break;
++			case SSL3_MT_SERVER_KEY_EXCHANGE:
++				strcat(string,"Server Key Exchange");
++				break;
++			case SSL3_MT_CERTIFICATE_REQUEST:
++				strcat(string,"Certificate Request");
++				break;
++			case SSL3_MT_SERVER_DONE:
++				strcat(string,"Server Hello Done");
++								break;
++			case SSL3_MT_CERTIFICATE_VERIFY:
++				strcat(string,"Certificate Verify");
++				break;
++			case SSL3_MT_CLIENT_KEY_EXCHANGE:
++				strcat(string,"Client Key Exchange");
++				break;
++			case SSL3_MT_FINISHED:
++				strcat(string,"Finished");
++				break;
++
++			default:
++				sprintf( string, "Handshake: Unknown SSL3 code received: %d", code );
++		}
++		break;
++
++	default:
++		sprintf( string, "SSL message contains unknown content type: %d", content_type );
++		
++	}
++
++	/* Alert messages must always be displayed */
++	if(content_type == SSL3_RT_ALERT)
++		error("%s", string);
++	else
++		dbglog("%s", string);
++}
++
+diff -Naur ppp-2.4.7/pppd/eap-tls.h ppp-2.4.7-eaptls-mppe-0.998/pppd/eap-tls.h
+--- ppp-2.4.7/pppd/eap-tls.h	1970-01-01 01:00:00.000000000 +0100
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/eap-tls.h	2015-03-10 16:51:32.705097268 +0100
+@@ -0,0 +1,107 @@
++/*
++ * eap-tls.h
++ *
++ * Copyright (c) Beniamino Galvani 2005 All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ *
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ *
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in
++ *    the documentation and/or other materials provided with the
++ *    distribution.
++ *
++ * 3. The name(s) of the authors of this software must not be used to
++ *    endorse or promote products derived from this software without
++ *    prior written permission.
++ *
++ * THE AUTHORS OF THIS SOFTWARE DISCLAIM ALL WARRANTIES WITH REGARD TO
++ * THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
++ * AND FITNESS, IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY
++ * SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
++ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN
++ * AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING
++ * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
++ *
++ */
++
++#ifndef __EAP_TLS_H__
++#define __EAP_TLS_H__
++
++#include "eap.h"
++
++#include <openssl/ssl.h>
++#include <openssl/bio.h>
++#include <openssl/md5.h>
++
++#define EAP_TLS_FLAGS_LI        128	/* length included flag */
++#define EAP_TLS_FLAGS_MF        64	/* more fragments flag */
++#define EAP_TLS_FLAGS_START     32	/* start flag */
++
++#define EAP_TLS_MAX_LEN         65536	/* max eap tls packet size */
++
++struct eaptls_session
++{
++	u_char *data;		/* buffered data */
++	int datalen;		/* buffered data len */
++	int offset;		/* from where to send */
++	int tlslen;		/* total length of tls data */
++	bool frag;		/* packet is fragmented */
++	SSL_CTX *ctx;
++	SSL *ssl;		/* ssl connection */
++	BIO *from_ssl;
++	BIO *into_ssl;
++	char peer[MAXWORDLEN];	/* peer name */
++	char peercertfile[MAXWORDLEN];
++	bool alert_sent;
++	u_char alert_sent_desc;
++	bool alert_recv;
++	u_char alert_recv_desc;
++	char rtx[65536];	/* retransmission buffer */
++	int rtx_len;
++	int mtu;		/* unit mtu */
++};
++
++typedef struct pw_cb_data
++{
++	const void *password;
++	const char *prompt_info;
++} PW_CB_DATA;
++
++
++int ssl_verify_callback(int, X509_STORE_CTX *);
++void ssl_msg_callback(int write_p, int version, int ct, const void *buf,
++		      size_t len, SSL * ssl, void *arg);
++
++X509 *get_X509_from_file(char *filename);
++int ssl_cmp_certs(char *filename, X509 * a);
++
++SSL_CTX *eaptls_init_ssl(int init_server, char *cacertfile,
++            char *certfile, char *peer_certfile, char *privkeyfile);
++int eaptls_init_ssl_server(eap_state * esp);
++int eaptls_init_ssl_client(eap_state * esp);
++void eaptls_free_session(struct eaptls_session *ets);
++
++int eaptls_receive(struct eaptls_session *ets, u_char * inp, int len);
++int eaptls_send(struct eaptls_session *ets, u_char ** outp);
++void eaptls_retransmit(struct eaptls_session *ets, u_char ** outp);
++
++int get_eaptls_secret(int unit, char *client, char *server,
++		      char *clicertfile, char *servcertfile, char *cacertfile,
++		      char *pkfile, int am_server);
++
++#ifdef MPPE
++#include "mppe.h"   /* MPPE_MAX_KEY_LEN */
++extern u_char mppe_send_key[MPPE_MAX_KEY_LEN];
++extern u_char mppe_recv_key[MPPE_MAX_KEY_LEN];
++extern int mppe_keys_set;
++
++void eaptls_gen_mppe_keys(struct eaptls_session *ets, const char *prf_label, int client);
++
++#endif
++
++#endif
+diff -Naur ppp-2.4.7/pppd/eap.c ppp-2.4.7-eaptls-mppe-0.998/pppd/eap.c
+--- ppp-2.4.7/pppd/eap.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/eap.c	2015-03-10 16:51:32.708097305 +0100
+@@ -43,6 +43,11 @@
+  * Based on draft-ietf-pppext-eap-srp-03.txt.
+  */
+ 
++/*
++ * Modification by Beniamino Galvani, Mar 2005
++ * Implemented EAP-TLS authentication
++ */
++
+ #define RCSID	"$Id: eap.c,v 1.4 2004/11/09 22:39:25 paulus Exp $"
+ 
+ /*
+@@ -62,8 +67,12 @@
+ 
+ #include "pppd.h"
+ #include "pathnames.h"
+-#include "md5.h"
+ #include "eap.h"
++#ifdef USE_EAPTLS
++#include "eap-tls.h"
++#else
++#include "md5.h"
++#endif /* USE_EAPTLS */
+ 
+ #ifdef USE_SRP
+ #include <t_pwd.h>
+@@ -209,6 +218,9 @@
+ 	esp->es_server.ea_id = (u_char)(drand48() * 0x100);
+ 	esp->es_client.ea_timeout = EAP_DEFREQTIME;
+ 	esp->es_client.ea_maxrequests = EAP_DEFALLOWREQ;
++#ifdef USE_EAPTLS
++	esp->es_client.ea_using_eaptls = 0;
++#endif /* USE_EAPTLS */
+ }
+ 
+ /*
+@@ -436,8 +448,16 @@
+ 	u_char vals[2];
+ 	struct b64state bs;
+ #endif /* USE_SRP */
++#ifdef USE_EAPTLS
++	struct eaptls_session *ets;
++	int secret_len;
++	char secret[MAXWORDLEN];
++#endif /* USE_EAPTLS */
+ 
+ 	esp->es_server.ea_timeout = esp->es_savedtime;
++#ifdef USE_EAPTLS
++	esp->es_server.ea_prev_state = esp->es_server.ea_state;
++#endif /* USE_EAPTLS */
+ 	switch (esp->es_server.ea_state) {
+ 	case eapBadAuth:
+ 		return;
+@@ -562,9 +582,79 @@
+ 			break;
+ 		}
+ #endif /* USE_SRP */
++#ifdef USE_EAPTLS
++                if (!get_secret(esp->es_unit, esp->es_server.ea_peer,
++                    esp->es_server.ea_name, secret, &secret_len, 1)) {
++
++			esp->es_server.ea_state = eapTlsStart;
++			break;
++		}
++#endif /* USE_EAPTLS */
++
+ 		esp->es_server.ea_state = eapMD5Chall;
+ 		break;
+ 
++#ifdef USE_EAPTLS
++	case eapTlsStart:
++		/* Initialize ssl session */
++		if(!eaptls_init_ssl_server(esp)) {
++			esp->es_server.ea_state = eapBadAuth;
++			break;
++		}
++
++		esp->es_server.ea_state = eapTlsRecv;
++		break;
++
++	case eapTlsRecv:
++		ets = (struct eaptls_session *) esp->es_server.ea_session;
++
++		if(ets->alert_sent) {
++			esp->es_server.ea_state = eapTlsSendAlert;
++			break;
++		}
++
++		if (status) {
++			esp->es_server.ea_state = eapBadAuth;
++			break;
++		}
++		ets = (struct eaptls_session *) esp->es_server.ea_session;
++
++		if(ets->frag)
++			esp->es_server.ea_state = eapTlsSendAck;
++		else
++			esp->es_server.ea_state = eapTlsSend;
++		break;
++
++	case eapTlsSend:
++		ets = (struct eaptls_session *) esp->es_server.ea_session;
++
++		if(ets->frag)
++			esp->es_server.ea_state = eapTlsRecvAck;
++		else
++			if(SSL_is_init_finished(ets->ssl)) 
++				esp->es_server.ea_state = eapTlsRecvClient; 
++			else
++				esp->es_server.ea_state = eapTlsRecv;
++		break;
++
++	case eapTlsSendAck:
++			esp->es_server.ea_state = eapTlsRecv;
++		break;
++
++	case eapTlsRecvAck:
++                if (status) {
++                        esp->es_server.ea_state = eapBadAuth;
++                        break;
++                }
++
++		esp->es_server.ea_state = eapTlsSend;
++		break;
++
++	case eapTlsSendAlert:
++		esp->es_server.ea_state = eapTlsRecvAlertAck;
++		break;
++#endif /* USE_EAPTLS */
++
+ 	case eapSRP1:
+ #ifdef USE_SRP
+ 		ts = (struct t_server *)esp->es_server.ea_session;
+@@ -718,6 +808,30 @@
+ 		INCPTR(esp->es_server.ea_namelen, outp);
+ 		break;
+ 
++#ifdef USE_EAPTLS
++	case eapTlsStart:
++		PUTCHAR(EAPT_TLS, outp);
++		PUTCHAR(EAP_TLS_FLAGS_START, outp);
++		eap_figure_next_state(esp, 0);
++		break;
++
++	case eapTlsSend:
++		eaptls_send(esp->es_server.ea_session, &outp);
++		eap_figure_next_state(esp, 0);
++		break;
++
++	case eapTlsSendAck:
++		PUTCHAR(EAPT_TLS, outp);
++		PUTCHAR(0, outp);
++		eap_figure_next_state(esp, 0);
++		break;
++
++	case eapTlsSendAlert:
++		eaptls_send(esp->es_server.ea_session, &outp);
++		eap_figure_next_state(esp, 0);
++		break;
++#endif /* USE_EAPTLS */
++
+ #ifdef USE_SRP
+ 	case eapSRP1:
+ 		PUTCHAR(EAPT_SRP, outp);
+@@ -904,11 +1018,57 @@
+ eap_server_timeout(arg)
+ void *arg;
+ {
++#ifdef USE_EAPTLS
++	u_char *outp;
++	u_char *lenloc;
++	int outlen;
++#endif /* USE_EAPTLS */
++
+ 	eap_state *esp = (eap_state *) arg;
+ 
+ 	if (!eap_server_active(esp))
+ 		return;
+ 
++#ifdef USE_EAPTLS
++	switch(esp->es_server.ea_prev_state) {
++
++	/* 
++	 *  In eap-tls the state changes after a request, so we return to
++	 *  previous state ...
++	 */
++	case(eapTlsStart):
++	case(eapTlsSendAck):
++		esp->es_server.ea_state = esp->es_server.ea_prev_state;
++		break;
++
++	/*
++	 *  ... or resend the stored data
++	 */
++	case(eapTlsSend):
++	case(eapTlsSendAlert):
++		outp = outpacket_buf;
++		MAKEHEADER(outp, PPP_EAP);
++		PUTCHAR(EAP_REQUEST, outp);
++		PUTCHAR(esp->es_server.ea_id, outp);
++		lenloc = outp;
++		INCPTR(2, outp);
++
++		eaptls_retransmit(esp->es_server.ea_session, &outp);
++
++		outlen = (outp - outpacket_buf) - PPP_HDRLEN;
++		PUTSHORT(outlen, lenloc);
++		output(esp->es_unit, outpacket_buf, outlen + PPP_HDRLEN);
++		esp->es_server.ea_requests++;
++
++		if (esp->es_server.ea_timeout > 0)
++			TIMEOUT(eap_server_timeout, esp, esp->es_server.ea_timeout);
++
++		return;
++	default:
++		break;
++	}
++#endif /* USE_EAPTLS */
++
+ 	/* EAP ID number must not change on timeout. */
+ 	eap_send_request(esp);
+ }
+@@ -1166,6 +1326,81 @@
+ }
+ #endif /* USE_SRP */
+ 
++#ifdef USE_EAPTLS
++/*
++ * Send an EAP-TLS response message with tls data
++ */
++static void
++eap_tls_response(esp, id)
++eap_state *esp;
++u_char id;
++{
++        u_char *outp;
++        int outlen;
++	u_char *lenloc;
++
++        outp = outpacket_buf;
++
++        MAKEHEADER(outp, PPP_EAP);
++
++        PUTCHAR(EAP_RESPONSE, outp);
++        PUTCHAR(id, outp);
++
++	lenloc = outp;
++	INCPTR(2, outp);        
++
++	/*
++	   If the id in the request is unchanged, we must retransmit
++	   the old data
++	*/
++	if(id == esp->es_client.ea_id)
++		eaptls_retransmit(esp->es_client.ea_session, &outp);
++	else
++		eaptls_send(esp->es_client.ea_session, &outp);
++
++	outlen = (outp - outpacket_buf) - PPP_HDRLEN;
++	PUTSHORT(outlen, lenloc);
++
++	output(esp->es_unit, outpacket_buf, PPP_HDRLEN + outlen);
++
++	esp->es_client.ea_id = id;
++
++}
++
++/*
++ * Send an EAP-TLS ack
++ */
++static void
++eap_tls_sendack(esp, id)
++eap_state *esp;
++u_char id;
++{
++	u_char *outp;
++	int outlen;
++	u_char *lenloc;
++
++	outp = outpacket_buf;
++
++	MAKEHEADER(outp, PPP_EAP);
++
++	PUTCHAR(EAP_RESPONSE, outp);
++	PUTCHAR(id, outp);
++	esp->es_client.ea_id = id;
++
++	lenloc = outp;
++	INCPTR(2, outp);
++
++	PUTCHAR(EAPT_TLS, outp);
++	PUTCHAR(0, outp);
++
++	outlen = (outp - outpacket_buf) - PPP_HDRLEN;
++	PUTSHORT(outlen, lenloc);
++
++	output(esp->es_unit, outpacket_buf, PPP_HDRLEN + outlen);
++
++}
++#endif /* USE_EAPTLS */
++
+ static void
+ eap_send_nak(esp, id, type)
+ eap_state *esp;
+@@ -1320,6 +1555,11 @@
+ 	char rhostname[256];
+ 	MD5_CTX mdContext;
+ 	u_char hash[MD5_SIGNATURE_SIZE];
++#ifdef USE_EAPTLS
++	u_char flags;
++	struct eaptls_session *ets = esp->es_client.ea_session;
++#endif /* USE_EAPTLS */
++
+ #ifdef USE_SRP
+ 	struct t_client *tc;
+ 	struct t_num sval, gval, Nval, *Ap, Bval;
+@@ -1456,6 +1696,90 @@
+ 		    esp->es_client.ea_namelen);
+ 		break;
+ 
++#ifdef USE_EAPTLS
++	case EAPT_TLS:
++
++		switch(esp->es_client.ea_state) {
++
++		case eapListen:
++
++			GETCHAR(flags, inp);
++			if(flags & EAP_TLS_FLAGS_START){
++
++				esp->es_client.ea_using_eaptls = 1;
++
++                                if (explicit_remote){
++                                        esp->es_client.ea_peer = strdup(remote_name);
++                                        esp->es_client.ea_peerlen = strlen(remote_name);
++                                } else
++                                        esp->es_client.ea_peer = NULL;
++
++				/* Init ssl session */
++				if(!eaptls_init_ssl_client(esp)) {
++					dbglog("cannot init ssl");
++					eap_send_nak(esp, id, EAPT_TLS);
++					esp->es_client.ea_using_eaptls = 0;
++					break;
++				}
++
++				ets = esp->es_client.ea_session;
++				eap_tls_response(esp, id);
++				esp->es_client.ea_state = (ets->frag ? eapTlsRecvAck :
++								eapTlsRecv);
++				break;
++			}
++
++			/* The server has sent a bad start packet. */
++			eap_send_nak(esp, id, EAPT_TLS);
++			break;
++
++		case eapTlsRecvAck:
++			eap_tls_response(esp, id);
++			esp->es_client.ea_state = (ets->frag ? eapTlsRecvAck : 
++							eapTlsRecv);
++			break;
++
++		case eapTlsRecv:
++			eaptls_receive(ets, inp, len);
++
++			if(ets->frag) {
++				eap_tls_sendack(esp, id);
++				esp->es_client.ea_state = eapTlsRecv;
++				break;
++			}
++
++			if(ets->alert_recv) {
++				eap_tls_sendack(esp, id);
++				esp->es_client.ea_state = eapTlsRecvFailure;
++				break;
++			}
++
++			/* Check if TLS handshake is finished */
++			if(SSL_is_init_finished(ets->ssl)){
++#ifdef MPPE
++ 				eaptls_gen_mppe_keys( ets, "client EAP encryption", 1 );
++#endif
++				eaptls_free_session(ets);
++				eap_tls_sendack(esp, id);
++				esp->es_client.ea_state = eapTlsRecvSuccess;
++				break;
++			}
++
++			eap_tls_response(esp,id);
++                        esp->es_client.ea_state = (ets->frag ? eapTlsRecvAck :
++                                                        eapTlsRecv);
++
++                        break;
++
++		default:
++			eap_send_nak(esp, id, EAPT_TLS);
++			esp->es_client.ea_using_eaptls = 0;
++			break;
++		}
++
++		break;
++#endif /* USE_EAPTLS */
++
+ #ifdef USE_SRP
+ 	case EAPT_SRP:
+ 		if (len < 1) {
+@@ -1737,6 +2061,11 @@
+ 	u_char dig[SHA_DIGESTSIZE];
+ #endif /* USE_SRP */
+ 
++#ifdef USE_EAPTLS
++	struct eaptls_session *ets;
++	u_char flags;
++#endif /* USE_EAPTLS */
++
+ 	if (esp->es_server.ea_id != id) {
+ 		dbglog("EAP: discarding Response %d; expected ID %d", id,
+ 		    esp->es_server.ea_id);
+@@ -1776,6 +2105,60 @@
+ 		eap_figure_next_state(esp, 0);
+ 		break;
+ 
++#ifdef USE_EAPTLS
++	case EAPT_TLS:
++		switch(esp->es_server.ea_state) {
++
++		case eapTlsRecv:
++			ets = (struct eaptls_session *) esp->es_server.ea_session;
++			eap_figure_next_state(esp, 
++				eaptls_receive(esp->es_server.ea_session, inp, len));
++
++			if(ets->alert_recv) {
++				eap_send_failure(esp);
++				break;
++			}
++			break;
++
++		case eapTlsRecvAck:
++			if(len > 1) {
++				dbglog("EAP-TLS ACK with extra data");
++			}
++			eap_figure_next_state(esp, 0);
++			break;
++
++		case eapTlsRecvClient:
++			/* Receive authentication response from client */
++
++			GETCHAR(flags, inp);
++
++			if(len == 1 && !flags) {	/* Ack = ok */
++#ifdef MPPE
++ 				eaptls_gen_mppe_keys( esp->es_server.ea_session, "client EAP encryption", 0 );
++#endif
++				eap_send_success(esp);
++			}
++			else {			/* failure */
++				eaptls_receive(esp->es_server.ea_session, inp, len);
++				warn("Server authentication failed");
++				eap_send_failure(esp);
++			}
++
++			eaptls_free_session(esp->es_server.ea_session);
++
++			break;
++
++		case eapTlsRecvAlertAck:
++			eap_send_failure(esp);
++			break;
++
++		default:
++			eap_figure_next_state(esp, 1);
++			break;
++		}
++		break;
++#endif /* USE_EAPTLS */
++
+ 	case EAPT_NOTIFICATION:
+ 		dbglog("EAP unexpected Notification; response discarded");
+ 		break;
+@@ -1807,6 +2190,13 @@
+ 			esp->es_server.ea_state = eapMD5Chall;
+ 			break;
+ 
++#ifdef USE_EAPTLS
++			/* Send EAP-TLS start packet */
++		case EAPT_TLS:
++			esp->es_server.ea_state = eapTlsStart;
++			break;
++#endif /* USE_EAPTLS */
++
+ 		default:
+ 			dbglog("EAP: peer requesting unknown Type %d", vallen);
+ 			switch (esp->es_server.ea_state) {
+@@ -2018,13 +2408,27 @@
+ int id;
+ int len;
+ {
+-	if (esp->es_client.ea_state != eapOpen && !eap_client_active(esp)) {
++	if (esp->es_client.ea_state != eapOpen && !eap_client_active(esp)
++#ifdef USE_EAPTLS
++		&& esp->es_client.ea_state != eapTlsRecvSuccess
++#endif /* USE_EAPTLS */
++		) {
+ 		dbglog("EAP unexpected success message in state %s (%d)",
+ 		    eap_state_name(esp->es_client.ea_state),
+ 		    esp->es_client.ea_state);
+ 		return;
+ 	}
+ 
++#ifdef USE_EAPTLS
++	if(esp->es_client.ea_using_eaptls && esp->es_client.ea_state != 
++		eapTlsRecvSuccess) {
++		dbglog("EAP-TLS unexpected success message in state %s (%d)",
++                    eap_state_name(esp->es_client.ea_state),
++                    esp->es_client.ea_state);
++		return;
++	}
++#endif /* USE_EAPTLS */
++
+ 	if (esp->es_client.ea_timeout > 0) {
+ 		UNTIMEOUT(eap_client_timeout, (void *)esp);
+ 	}
+@@ -2150,6 +2554,9 @@
+ 	int code, id, len, rtype, vallen;
+ 	u_char *pstart;
+ 	u_int32_t uval;
++#ifdef USE_EAPTLS
++	u_char flags;
++#endif /* USE_EAPTLS */
+ 
+ 	if (inlen < EAP_HEADERLEN)
+ 		return (0);
+@@ -2214,6 +2621,24 @@
+ 			}
+ 			break;
+ 
++#ifdef USE_EAPTLS
++		case EAPT_TLS:
++			if (len < 1)
++				break;
++			GETCHAR(flags, inp);
++			len--;
++
++                        if(flags == 0 && len == 0){
++                                printer(arg, " Ack");
++                                break;
++                        }
++
++			printer(arg, flags & EAP_TLS_FLAGS_LI ? " L":" -");
++			printer(arg, flags & EAP_TLS_FLAGS_MF ? "M":"-");
++			printer(arg, flags & EAP_TLS_FLAGS_START ? "S":"- ");
++			break;
++#endif /* USE_EAPTLS */
++
+ 		case EAPT_SRP:
+ 			if (len < 3)
+ 				goto truncated;
+@@ -2325,6 +2750,25 @@
+ 			}
+ 			break;
+ 
++#ifdef USE_EAPTLS
++		case EAPT_TLS:
++			if (len < 1)
++				break;
++			GETCHAR(flags, inp);
++			len--;
++
++                        if(flags == 0 && len == 0){
++                                printer(arg, " Ack");
++                                break;
++                        }
++
++			printer(arg, flags & EAP_TLS_FLAGS_LI ? " L":" -");
++			printer(arg, flags & EAP_TLS_FLAGS_MF ? "M":"-");
++			printer(arg, flags & EAP_TLS_FLAGS_START ? "S":"- ");
++
++			break;
++#endif /* USE_EAPTLS */
++
+ 		case EAPT_NAK:
+ 			if (len <= 0) {
+ 				printer(arg, " <missing hint>");
+@@ -2426,3 +2870,4 @@
+ 
+ 	return (inp - pstart);
+ }
++
+diff -Naur ppp-2.4.7/pppd/eap.h ppp-2.4.7-eaptls-mppe-0.998/pppd/eap.h
+--- ppp-2.4.7/pppd/eap.h	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/eap.h	2015-03-10 16:51:32.709097318 +0100
+@@ -84,6 +84,16 @@
+ 	eapClosed,	/* Authentication not in use */
+ 	eapListen,	/* Client ready (and timer running) */
+ 	eapIdentify,	/* EAP Identify sent */
++	eapTlsStart,	/* Send EAP-TLS start packet */
++	eapTlsRecv,	/* Receive EAP-TLS tls data */
++	eapTlsSendAck,	/* Send EAP-TLS ack */
++	eapTlsSend,	/* Send EAP-TLS tls data */
++	eapTlsRecvAck,	/* Receive EAP-TLS ack */
++	eapTlsRecvClient, 	/* Receive EAP-TLS auth response from client*/
++	eapTlsSendAlert,	/* Send EAP-TLS tls alert (server)*/
++	eapTlsRecvAlertAck,	/* Receive EAP-TLS ack after sending alert */
++	eapTlsRecvSuccess,	/* Receive EAP success */
++	eapTlsRecvFailure,	/* Receive EAP failure */
+ 	eapSRP1,	/* Sent EAP SRP-SHA1 Subtype 1 */
+ 	eapSRP2,	/* Sent EAP SRP-SHA1 Subtype 2 */
+ 	eapSRP3,	/* Sent EAP SRP-SHA1 Subtype 3 */
+@@ -95,9 +105,18 @@
+ 
+ #define	EAP_STATES	\
+ 	"Initial", "Pending", "Closed", "Listen", "Identify", \
++	"TlsStart", "TlsRecv", "TlsSendAck", "TlsSend", "TlsRecvAck", "TlsRecvClient",\
++	"TlsSendAlert", "TlsRecvAlertAck" , "TlsRecvSuccess", "TlsRecvFailure", \
+ 	"SRP1", "SRP2", "SRP3", "MD5Chall", "Open", "SRP4", "BadAuth"
+ 
+-#define	eap_client_active(esp)	((esp)->es_client.ea_state == eapListen)
++#ifdef USE_EAPTLS
++#define	eap_client_active(esp)	((esp)->es_client.ea_state != eapInitial &&\
++				 (esp)->es_client.ea_state != eapPending &&\
++				 (esp)->es_client.ea_state != eapClosed)
++#else
++#define eap_client_active(esp)	((esp)->es_client.ea_state == eapListen)
++#endif /* USE_EAPTLS */
++
+ #define	eap_server_active(esp)	\
+ 	((esp)->es_server.ea_state >= eapIdentify && \
+ 	 (esp)->es_server.ea_state <= eapMD5Chall)
+@@ -112,11 +131,17 @@
+ 	u_short ea_namelen;	/* Length of our name */
+ 	u_short ea_peerlen;	/* Length of peer's name */
+ 	enum eap_state_code ea_state;
++#ifdef USE_EAPTLS
++	enum eap_state_code ea_prev_state;
++#endif
+ 	u_char ea_id;		/* Current id */
+ 	u_char ea_requests;	/* Number of Requests sent/received */
+ 	u_char ea_responses;	/* Number of Responses */
+ 	u_char ea_type;		/* One of EAPT_* */
+ 	u_int32_t ea_keyflags;	/* SRP shared key usage flags */
++#ifdef USE_EAPTLS
++	bool ea_using_eaptls;
++#endif
+ };
+ 
+ /*
+@@ -139,7 +164,12 @@
+  * Timeouts.
+  */
+ #define	EAP_DEFTIMEOUT		3	/* Timeout (seconds) for rexmit */
++#ifdef USE_EAPTLS
++#define	EAP_DEFTRANSMITS	30	/* max # times to transmit */
++					/* certificates can be long ... */
++#else
+ #define	EAP_DEFTRANSMITS	10	/* max # times to transmit */
++#endif /* USE_EAPTLS */
+ #define	EAP_DEFREQTIME		20	/* Time to wait for peer request */
+ #define	EAP_DEFALLOWREQ		20	/* max # times to accept requests */
+ 
+diff -Naur ppp-2.4.7/pppd/md5.c ppp-2.4.7-eaptls-mppe-0.998/pppd/md5.c
+--- ppp-2.4.7/pppd/md5.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/md5.c	2015-03-10 16:51:32.710097331 +0100
+@@ -33,6 +33,8 @@
+  ***********************************************************************
+  */
+ 
++#ifndef USE_EAPTLS
++
+ #include <string.h>
+ #include "md5.h"
+ 
+@@ -305,3 +307,5 @@
+  ** End of md5.c                                                      **
+  ******************************** (cut) ********************************
+  */
++#endif /* USE_EAPTLS */
++
+diff -Naur ppp-2.4.7/pppd/md5.h ppp-2.4.7-eaptls-mppe-0.998/pppd/md5.h
+--- ppp-2.4.7/pppd/md5.h	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/md5.h	2015-03-10 16:51:32.710097331 +0100
+@@ -36,6 +36,7 @@
+  ** documentation and/or software.                                    **
+  ***********************************************************************
+  */
++#ifndef USE_EAPTLS
+ 
+ #ifndef __MD5_INCLUDE__
+ 
+@@ -63,3 +64,5 @@
+ 
+ #define __MD5_INCLUDE__
+ #endif /* __MD5_INCLUDE__ */
++
++#endif /* USE_EAPTLS */
+diff -Naur ppp-2.4.7/pppd/pathnames.h ppp-2.4.7-eaptls-mppe-0.998/pppd/pathnames.h
+--- ppp-2.4.7/pppd/pathnames.h	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/pathnames.h	2015-03-10 16:51:32.711097344 +0100
+@@ -21,6 +21,13 @@
+ #define _PATH_UPAPFILE 	 _ROOT_PATH "/etc/ppp/pap-secrets"
+ #define _PATH_CHAPFILE 	 _ROOT_PATH "/etc/ppp/chap-secrets"
+ #define _PATH_SRPFILE 	 _ROOT_PATH "/etc/ppp/srp-secrets"
++
++#ifdef USE_EAPTLS
++#define _PATH_EAPTLSCLIFILE	_ROOT_PATH "/etc/ppp/eaptls-client"
++#define _PATH_EAPTLSSERVFILE	_ROOT_PATH "/etc/ppp/eaptls-server"
++#define _PATH_OPENSSLCONFFILE	_ROOT_PATH "/etc/ppp/openssl.cnf"
++#endif /* USE_EAPTLS */
++
+ #define _PATH_SYSOPTIONS _ROOT_PATH "/etc/ppp/options"
+ #define _PATH_IPUP	 _ROOT_PATH "/etc/ppp/ip-up"
+ #define _PATH_IPDOWN	 _ROOT_PATH "/etc/ppp/ip-down"
+diff -Naur ppp-2.4.7/pppd/plugins/Makefile.linux ppp-2.4.7-eaptls-mppe-0.998/pppd/plugins/Makefile.linux
+--- ppp-2.4.7/pppd/plugins/Makefile.linux	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/plugins/Makefile.linux	2015-03-10 16:51:32.712097357 +0100
+@@ -4,6 +4,9 @@
+ LDFLAGS	= -shared
+ INSTALL	= install
+ 
++# EAP-TLS
++CFLAGS += -DUSE_EAPTLS=1
++
+ DESTDIR = $(INSTROOT)@DESTDIR@
+ BINDIR = $(DESTDIR)/sbin
+ MANDIR = $(DESTDIR)/share/man/man8
+diff -Naur ppp-2.4.7/pppd/plugins/passprompt.c ppp-2.4.7-eaptls-mppe-0.998/pppd/plugins/passprompt.c
+--- ppp-2.4.7/pppd/plugins/passprompt.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/plugins/passprompt.c	2015-03-10 16:51:32.712097357 +0100
+@@ -107,4 +107,7 @@
+ {
+     add_options(options);
+     pap_passwd_hook = promptpass;
++#ifdef USE_EAPTLS
++    eaptls_passwd_hook = promptpass;
++#endif
+ }
+diff -Naur ppp-2.4.7/pppd/plugins/passwordfd.c ppp-2.4.7-eaptls-mppe-0.998/pppd/plugins/passwordfd.c
+--- ppp-2.4.7/pppd/plugins/passwordfd.c	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/plugins/passwordfd.c	2015-03-10 16:51:32.713097370 +0100
+@@ -79,4 +79,8 @@
+ 
+     chap_check_hook = pwfd_check;
+     chap_passwd_hook = pwfd_passwd;
++
++#ifdef USE_EAPTLS
++    eaptls_passwd_hook = pwfd_passwd;
++#endif
+ }
+diff -Naur ppp-2.4.7/pppd/pppd.8 ppp-2.4.7-eaptls-mppe-0.998/pppd/pppd.8
+--- ppp-2.4.7/pppd/pppd.8	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/pppd.8	2015-03-10 16:51:32.715097396 +0100
+@@ -248,6 +248,12 @@
+ compression in the corresponding direction.  Use \fInobsdcomp\fR or
+ \fIbsdcomp 0\fR to disable BSD-Compress compression entirely.
+ .TP
++.B ca \fIca-file
++(EAP-TLS) Use the file \fIca-file\fR as the X.509 Certificate Authority
++(CA) file (in PEM format), needed for setting up an EAP-TLS connection.
++This option is used on the client-side in conjunction with the \fBcert\fR
++and \fBkey\fR options.
++.TP
+ .B cdtrcts
+ Use a non-standard hardware flow control (i.e. DTR/CTS) to control
+ the flow of data on the serial port.  If neither the \fIcrtscts\fR,
+@@ -259,6 +265,12 @@
+ bi-directional flow control. The sacrifice is that this flow
+ control mode does not permit using DTR as a modem control line.
+ .TP
++.B cert \fIcertfile
++(EAP-TLS) Use the file \fIcertfile\fR as the X.509 certificate (in PEM
++format), needed for setting up an EAP-TLS connection. This option is
++used on the client-side in conjunction with the \fBca\fR and 
++\fBkey\fR options.
++.TP
+ .B chap\-interval \fIn
+ If this option is given, pppd will rechallenge the peer every \fIn\fR
+ seconds.
+@@ -287,6 +299,18 @@
+ 1000 (1 second).  This wait period only applies if the \fBconnect\fR
+ or \fBpty\fR option is used.
+ .TP
++.B crl \fIfilename
++(EAP-TLS) Use the file \fIfilename\fR as the Certificate Revocation List
++to check for the validity of the peer's certificate. This option is not
++mandatory for setting up an EAP-TLS connection. Also see the \fBcrl-dir\fR
++option.
++.TP
++.B crl-dir \fIdirectory
++(EAP-TLS) Use the directory \fIdirectory\fR to scan for CRL files in
++has format ($hash.r0) to check for the validity of the peer's certificate.
++This option is not mandatory for setting up an EAP-TLS connection.
++Also see the \fBcrl\fR option.
++.TP
+ .B debug
+ Enables connection debugging facilities.
+ If this option is given, pppd will log the contents of all
+@@ -551,6 +575,12 @@
+ the kernel are logged by syslog(1) to a file as directed in the
+ /etc/syslog.conf configuration file.
+ .TP
++.B key \fIkeyfile
++(EAP-TLS) Use the file \fIkeyfile\fR as the private key file (in PEM
++format), needed for setting up an EAP-TLS connection. This option is
++used on the client-side in conjunction with the \fBca\fR and 
++\fBcert\fR options.
++.TP
+ .B ktune
+ Enables pppd to alter kernel settings as appropriate.  Under Linux,
+ pppd will enable IP forwarding (i.e. set /proc/sys/net/ipv4/ip_forward
+@@ -709,6 +739,9 @@
+ Disable Address/Control compression in both directions (send and
+ receive).
+ .TP
++.B need-peer-eap
++(EAP-TLS) Require the peer to verify our authentication credentials.
++.TP
+ .B noauth
+ Do not require the peer to authenticate itself.  This option is
+ privileged.
+diff -Naur ppp-2.4.7/pppd/pppd.h ppp-2.4.7-eaptls-mppe-0.998/pppd/pppd.h
+--- ppp-2.4.7/pppd/pppd.h	2014-08-09 14:31:39.000000000 +0200
++++ ppp-2.4.7-eaptls-mppe-0.998/pppd/pppd.h	2015-03-10 16:51:32.716097409 +0100
+@@ -325,6 +325,11 @@
+ extern bool	dryrun;		/* check everything, print options, exit */
+ extern int	child_wait;	/* # seconds to wait for children at end */
+ 
++#ifdef USE_EAPTLS
++extern char	*crl_dir;
++extern char	*crl_file;
++#endif /* USE_EAPTLS */
++
+ #ifdef MAXOCTETS
+ extern unsigned int maxoctets;	     /* Maximum octetes per session (in bytes) */
+ extern int       maxoctets_dir;      /* Direction :
+@@ -741,6 +746,10 @@
+ extern int (*chap_passwd_hook) __P((char *user, char *passwd));
+ extern void (*multilink_join_hook) __P((void));
+ 
++#ifdef USE_EAPTLS
++extern int (*eaptls_passwd_hook) __P((char *user, char *passwd));
++#endif
++
+ /* Let a plugin snoop sent and received packets.  Useful for L2TP */
+ extern void (*snoop_recv_hook) __P((unsigned char *p, int len));
+ extern void (*snoop_send_hook) __P((unsigned char *p, int len));
